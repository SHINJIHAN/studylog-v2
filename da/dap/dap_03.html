<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="파이썬을 활용한 데이터 분석과 응용">
<meta name="dcterms.date" content="2025-12-02">

<title>주성분 분석(PCA) – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">주성분 분석(PCA)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>파이썬을 활용한 데이터 분석과 응용 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 2, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#목표-및-원리" id="toc-목표-및-원리" class="nav-link active" data-scroll-target="#목표-및-원리">01 목표 및 원리</a>
  <ul class="collapse">
  <li><a href="#주성분-생성" id="toc-주성분-생성" class="nav-link" data-scroll-target="#주성분-생성">1. 주성분 생성</a></li>
  <li><a href="#표준화" id="toc-표준화" class="nav-link" data-scroll-target="#표준화">2 표준화</a></li>
  <li><a href="#선형-변환" id="toc-선형-변환" class="nav-link" data-scroll-target="#선형-변환">3. 선형 변환</a></li>
  <li><a href="#분산-최대화" id="toc-분산-최대화" class="nav-link" data-scroll-target="#분산-최대화">4. 분산 최대화</a></li>
  <li><a href="#공분산-행렬과-고유값-분해" id="toc-공분산-행렬과-고유값-분해" class="nav-link" data-scroll-target="#공분산-행렬과-고유값-분해">5. 공분산 행렬과 고유값 분해</a></li>
  <li><a href="#차원-축소" id="toc-차원-축소" class="nav-link" data-scroll-target="#차원-축소">6. 차원 축소</a></li>
  </ul></li>
  <li><a href="#biplot" id="toc-biplot" class="nav-link" data-scroll-target="#biplot">03 Biplot</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><code>Principal Component Analysis, PCA</code><br> 상관관계가 존재할 수 있는 (p)개의 관찰 변수를 <strong>선형 변환</strong>하여<br> 서로 상관관계가 없는 새로운 인공 변수(주성분)를 생성하는 통계적 기법이다.<br></p>
<p>고차원 데이터에서는 변수 간 상관 관계가 분석과 해석을 복잡하게 만들 수 있으므로,<br> PCA를 통해 데이터 구조를 단순화하고, <strong>차원 축소</strong>를 수행함으로써 데이터 시각화, 노이즈 제거, 변수 간 다중공선성 문제 해결이 가능하다.<br></p>
<hr>
<section id="목표-및-원리" class="level1">
<h1>01 목표 및 원리</h1>
<section id="주성분-생성" class="level2">
<h2 class="anchored" data-anchor-id="주성분-생성">1. 주성분 생성</h2>
<p>주성분 분석의 목적은 다음과 같이 정의할 수 있다:</p>
<ol type="1">
<li><p>상관관계가 존재할 수 있는 <span class="math inline">\(p\)</span> 개의 원본 관찰 변수 <span class="math inline">\(X = [x_1, x_2, \dots, x_p]\)</span> 를 <strong>선형 변환(linear transformation)</strong>하여, 서로 상관관계가 없는 새로운 변수 집합 <span class="math inline">\(Z = [z_1, z_2, \dots, z_p]\)</span> 를 생성한다.</p></li>
<li><p>변환된 변수 <span class="math inline">\(Z\)</span> 는 서로 <strong>직교(orthogonal)</strong>하므로 상관성이 제거되며, 이를 통해 차원 축소와 데이터 구조 파악을 보다 효과적으로 수행할 수 있다.</p></li>
<li><p>각 주성분 <span class="math inline">\(z_k\)</span> 는 <strong>원자료의 분산을 최대한 보존</strong>하도록 선택되며, 주성분의 순서는 설명하는 분산의 크기에 따라 결정된다.</p></li>
</ol>
</section>
<section id="표준화" class="level2">
<h2 class="anchored" data-anchor-id="표준화">2 표준화</h2>
<p><code>Standardization</code><br> PCA 수행 시 변수의 단위와 스케일이 다를 경우, 표준화를 먼저 수행해야 한다.<br> 표준화 방법:</p>
<p><span class="math display">\[
x'_i = \frac{x_i - \bar{x}}{s_x}, \quad i = 1,2,\dots,n
\]</span></p>
<ul>
<li><span class="math inline">\(x_i\)</span> : 원 변수 값</li>
<li><span class="math inline">\(\bar{x}\)</span> : 변수의 평균</li>
<li><span class="math inline">\(s_x\)</span> : 변수의 표준편차</li>
</ul>
<p>표준화 후 변수는 평균 0, 분산 1을 갖게 되어 PCA에서 각 변수의 영향력이 균등하게 반영된다.</p>
<p>데이터 행렬은 다음과 같이 표현한다.</p>
<ul>
<li><p><strong>원본 데이터 행렬:</strong> <span class="math inline">\(X \in \mathbb{R}^{p \times n}\)</span></p>
<ul>
<li><span class="math inline">\(p\)</span>: 관찰 변수의 수</li>
<li><span class="math inline">\(n\)</span>: 관측치(샘플)의 수</li>
</ul></li>
</ul>
</section>
<section id="선형-변환" class="level2">
<h2 class="anchored" data-anchor-id="선형-변환">3. 선형 변환</h2>
<p>주성분 <span class="math inline">\(z_k\)</span> 는 원본 변수의 <strong>선형 결합</strong>으로 정의되며 다음과 같이 표현된다.</p>
<p><span class="math display">\[
z_k = a_{1k} x_1 + a_{2k} x_2 + \dots + a_{pk} x_p
= \mathbf{a}_k^T \mathbf{x}, \quad k = 1, 2, \dots, p
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{x} \in \mathbb{R}^p\)</span>: 원본 데이터 벡터</li>
<li><span class="math inline">\(\mathbf{a}_k \in \mathbb{R}^p\)</span>: k번째 주성분의 로딩(loading) 벡터</li>
<li><span class="math inline">\(\mathbf{a}_k^T \mathbf{a}_j = 0 ( k \neq j )\)</span>: 주성분 간 직교성</li>
</ul>
<blockquote class="blockquote">
<p>예시: 첫 번째 관측치 (n_1)의 첫 번째 주성분 좌표 (z_{1,1} = x_1^T v_1 = -0.2152) → (n_1)이 첫 번째 주성분 축 (v_1) 상에서 어디에 위치하는지를 나타내는 스칼라 값이다.</p>
</blockquote>
</section>
<section id="분산-최대화" class="level2">
<h2 class="anchored" data-anchor-id="분산-최대화">4. 분산 최대화</h2>
<p>첫 번째 주성분 <span class="math inline">\(z_1\)</span>: <strong>전체 분산을 최대한 설명하는 방향</strong>이 되도록 선택.<br> 두 번째 주성분 <span class="math inline">\(z_2\)</span>: <span class="math inline">\(z_1\)</span> 과 직교한다는 제약 아래 <strong>남아 있는 분산을 최대한 설명하는 방향</strong>으로 정의됨.<br> 이러한 방식으로 각 주성분은 계층적으로 결정된다.</p>
<p>따라서 k번째 주성분의 로딩 벡터 <span class="math inline">\(\mathbf{a}_k\)</span> 는 다음 최적화 문제를 통해 구해진다.</p>
<p><strong>일반식 (k번째 주성분)</strong></p>
<p><span class="math display">\[
\mathbf{a}*k
= \arg\max*{\mathbf{a}}
\mathrm{Var}(\mathbf{a}^T \mathbf{x}),
\quad
\text{subject to }
\mathbf{a}^T \mathbf{a} = 1,;
\mathbf{a}^T \mathbf{a}_j = 0,; j &lt; k
\]</span></p>
<p><strong>특수식 (첫 번째 주성분)</strong><br> 첫 번째 주성분은 이전 주성분이 없으므로 직교 조건이 필요 없습니다.</p>
<p><span class="math display">\[
\mathbf{a}_1
= \arg\max_{\mathbf{a}}
\mathrm{Var}(\mathbf{a}^T \mathbf{x}),
\quad
\text{subject to }
\mathbf{a}^T \mathbf{a} = 1
\]</span></p>
<ul>
<li><span class="math inline">\(|\mathbf{a}|^2 = \mathbf{a}^T \mathbf{a} = 1\)</span>: Lagrange 승수법 적용을 위한 제약 조건</li>
</ul>
</section>
<section id="공분산-행렬과-고유값-분해" class="level2">
<h2 class="anchored" data-anchor-id="공분산-행렬과-고유값-분해">5. 공분산 행렬과 고유값 분해</h2>
<ol type="1">
<li><strong>Lagrange 승수법 적용 → 고유값 문제 도출</strong></li>
</ol>
<p>첫 번째 주성분에 대해 Lagrange 함수를 구성한다.</p>
<p><span class="math display">\[
L(\mathbf{a},\lambda)
= \mathbf{a}^T \Sigma \mathbf{a} - \lambda (\mathbf{a}^T\mathbf{a}-1)
\]</span></p>
<p>편미분하여 최적 조건을 구하면, 다음 고유값 문제가 얻어진다.</p>
<p><span class="math display">\[
\frac{\partial L}{\partial \mathbf{a}} = 2\Sigma\mathbf{a} - 2\lambda \mathbf{a} = 0
\quad \Rightarrow \quad \Sigma \mathbf{a} = \lambda \mathbf{a}
\]</span></p>
<p>즉, <strong>주성분 로딩 벡터는 공분산 행렬의 고유벡터</strong>이다. * <strong>추가</strong>: 여기서 <span class="math inline">\(|\mathbf{a}|^2 = 1\)</span> 조건은 <strong>단위벡터(normalized vector)</strong>로 만들어 주성분 크기 비교가 가능하게 하는 역할을 한다.</p>
<ol start="2" type="1">
<li><strong>공분산 행렬 계산</strong></li>
</ol>
<p>데이터 행렬 <span class="math inline">\(X \in \mathbb{R}^{p \times n}\)</span> 에 대해 공분산 행렬은 다음으로 정의된다.<br> <span class="math inline">\(\Sigma\)</span>는 실대칭 행렬이므로 고유값 분해가 가능하다.</p>
<p><span class="math display">\[
\Sigma = \frac{1}{n-1} XX^T
\]</span></p>
<ul>
<li><strong>추가</strong>
<ul>
<li><span class="math inline">\(X \in \mathbb{R}^{p \times n}\)</span> 가 아닌 <span class="math inline">\(n \times p\)</span> 형태라면<br> <span class="math inline">\(\Sigma = \frac{1}{n-1} X^T X\)</span> 로 계산해야 함.<br> → 구현 시 데이터 행렬 차원 주의</li>
<li><span class="math inline">\(\Sigma\)</span> 는 대칭 행렬(Symmetric matrix)<br> → 고유벡터는 서로 직교(orthogonal)하며 정규화 가능</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>고유값·고유벡터 해석 → 주성분의 분산</strong></li>
</ol>
<p>고유값 분해에서 얻어진 값:</p>
<p><span class="math display">\[
\Sigma \mathbf{a}_k = \lambda_k \mathbf{a}_k
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{a}_k\)</span>: k번째 주성분 방향(loading vector)</li>
<li><span class="math inline">\(\lambda_k\)</span>: 해당 주성분이 설명하는 분산</li>
</ul>
<p>주성분 순서: 고유값 크기 순서대로 정렬<br> → <span class="math inline">\(\lambda_1 \ge \lambda_2 \ge \dots \ge \lambda_p\)</span></p>
<p>다음과 같이 분산과 연결된다: <span class="math display">\[
\mathrm{Var}(z_k) = \lambda_k
\]</span></p>
</section>
<section id="차원-축소" class="level2">
<h2 class="anchored" data-anchor-id="차원-축소">6. 차원 축소</h2>
<p><code>Dimensionality Reduction</code><br> PCA는 고차원 데이터에서 <strong>분산을 많이 설명하는 주성분만 선택</strong>하여 차원을 축소하는 기법이다.<br> 원래의 <span class="math inline">\(p\)</span> 차원 데이터 중 정보를 가장 많이 보존하는 상위 <span class="math inline">\(m\)</span> 개의 주성분( <span class="math inline">\(m &lt; p\)</span> )을 선택한다.</p>
<ol type="1">
<li><strong>설명되는 분산 비율</strong> <code>EVR, Explained Variance Ratio</code><br> 공분산 행렬의 고유값 <span class="math inline">\(\lambda_k\)</span> 는 k번째 주성분이 설명하는 분산을 의미한다.<br> 따라서 EVR은 다음과 같이 정의된다.</li>
</ol>
<p><span class="math display">\[
\text{EVR}_k
= \frac{\lambda_k}{\sum_{i=1}^p \lambda_i},
\quad k = 1,2,\dots,p
\]</span></p>
<ol start="2" type="1">
<li><strong>누적 설명 분산 비율</strong> <code>Cumulative EVR</code><br> 차원 축소의 선택 기준은 누적 EVR이다.</li>
</ol>
<p><span class="math display">\[
\text{Cumulative EVR}_m
= \sum*{k=1}^m \text{EVR}_k
\]</span></p>
<p>일반적으로 <strong>전체 분산의 80~90%를 설명하는 m개의 주성분</strong>을 선택하면<br> 정보 손실 없이 효과적인 차원 축소가 가능하다.</p>
<ol start="3" type="1">
<li><strong>새로운 좌표계로의 사영</strong> <code>projection</code><br> 선택된 상위 <span class="math inline">\(m\)</span> 개의 주성분 벡터</li>
</ol>
<p><span class="math display">\[
A_m = [\mathbf{a}_1, \dots, \mathbf{a}_m] \in \mathbb{R}^{p \times m}
\]</span></p>
<p>사용하여 원본 데이터 <span class="math inline">\(X \in \mathbb{R}^{p \times n}\)</span> 를 <strong>새로운 좌표계(주성분 축)</strong>로 투사(projection)한다. 각 관측치 <span class="math inline">\(x_i \in \mathbb{R}^p\)</span> (i번째 열) 는 다음과 같이 <span class="math inline">\(m\)</span> 차원 좌표 <span class="math inline">\(z_i \in \mathbb{R}^m\)</span> 로 변환된다:</p>
<p><span class="math display">\[
z_i = A_m^T x_i
\]</span></p>
<ul>
<li><span class="math inline">\(m\)</span> : 선택된 주성분 수 (차원 축소 후)</li>
<li><span class="math inline">\(z_i\)</span> : 관측치 (i)의 주성분 좌표</li>
<li>예: 5개의 주성분을 선택하면 각 관측치는 5차원 좌표를 가지게 됨</li>
</ul>
<p><span class="math display">\[
Z_m = A_m^T X \in \mathbb{R}^{m \times n}
\]</span></p>
<ul>
<li><span class="math inline">\(A_m = [\mathbf{a}_1, \dots, \mathbf{a}_m]\)</span>: 상위 m개의 주성분 로딩 벡터</li>
<li><span class="math inline">\(Z_m\)</span>: 축소된 차원에서의 데이터 표현</li>
</ul>
<p>각 주성분은 원본 데이터의 분산을 최대한 유지하며 서로 직교하기 때문에,<br> <span class="math inline">\(Z_m\)</span> 은 <strong>상호 독립적인 새로운 좌표계에서의 데이터</strong>가 된다.</p>
<ol start="4" type="1">
<li><strong>해석</strong></li>
</ol>
<ul>
<li><p>각 주성분은 원본 변수들의 <strong>선형 결합</strong>으로 구성되므로,<br> 가중치(로딩) 벡터 <span class="math inline">\(\mathbf{a}_k\)</span> 를 확인하면 해당 주성분이 어떤 변수에 의해 형성되었는지 해석 가능하다.</p></li>
<li><p>예: <span class="math inline">\(\mathbf{a}_1 = [0.5, 0.5, -0.3, \dots]\)</span> → 첫 번째 주성분은 첫 두 변수의 기여도가 높음을 의미</p></li>
<li><p>필요 시, 시각화를 통해 각 주성분과 원자료 변수의 관계를 분석 가능.</p></li>
<li><p>(z_{i,k})는 관측치 (i)를 주성분 (k) 축에 사영한 값</p></li>
<li><p>시각화 시, 좌표 값의 크기는 축 방향으로 관측치가 얼마나 멀리 위치하는지를 나타냄</p></li>
<li><p>고유벡터 성분의 부호와 크기는 원 변수들이 주성분에 미치는 영향도를 나타냄</p></li>
<li><p>부호는 방향성을 의미하며, 절대 크기를 통해 상대적 기여도를 판단 가능</p></li>
<li><p>각 관측치의 (z_{i,k}) 값은 주성분 축 상의 위치를 나타냄</p></li>
<li><p>2차원 또는 3차원 시각화 시, 좌표 값은 관측치가 새로운 축 상에서 가지는 위치와 변동성을 직관적으로 보여줌</p></li>
<li><p>예: (z_{1,1})을 x축으로, (z_{1,2})를 y축으로 하여 관측치를 점으로 표현하면, 주성분 상에서의 데이터 분포를 시각화 가능</p></li>
</ul>
<ol start="5" type="1">
<li><strong>실무 활용</strong></li>
</ol>
<ul>
<li><p>PCA는 <strong>고차원 데이터의 시각화, 노이즈 제거, 변수 간 다중공선성 해결, 머신러닝 전처리</strong>에 활용됨</p></li>
<li><p>실무 적용 시 유의사항:</p>
<ol type="1">
<li>원자료 변수 단위가 서로 다른 경우 <strong>표준화(Standardization)</strong> 필요</li>
<li>PCA는 <strong>비지도 학습</strong>이므로 목적 변수(y)를 고려하지 않음</li>
<li>차원 축소 후 선택된 주성분이 실제 업무 의미와 일치하는지 확인 필요</li>
<li>주성분 해석 시, 원본 변수와의 관계를 반드시 확인하여 의미 있는 인사이트를 확보</li>
</ol></li>
</ul>
<ol start="6" type="1">
<li>전처리 차원 축소 vs PCA 차원 축소</li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 37%">
<col style="width: 58%">
</colgroup>
<thead>
<tr class="header">
<th>구분</th>
<th>전처리 차원 축소</th>
<th>PCA 차원 축소</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>목적</td>
<td>불필요 변수 제거, 단위 조정 등</td>
<td>분산 최대 보존, 상관관계 제거, 통계적 차원 축소</td>
</tr>
<tr class="even">
<td>방식</td>
<td>경험적/규칙적</td>
<td>선형 변환 기반, 수학적 최적화</td>
</tr>
<tr class="odd">
<td>결과</td>
<td>원 변수 일부 제거</td>
<td>주성분으로 변환된 새로운 좌표</td>
</tr>
<tr class="even">
<td>활용</td>
<td>데이터 정제, 단순화</td>
<td>시각화, 피처 선택, 노이즈 제거, 모델 전처리</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="biplot" class="level1">
<h1>03 Biplot</h1>
<p>다변량 데이터에서 차원 축소를 수행한 후 반드시 고려해야 하는 중요한 시각화 도구이다. 이 플롯에서는 주성분 축을 기준으로 데이터 포인트를 시각화하며, 동시에 주성분 벡터를 원래 변수의 방향과 크기를 나타내는 화살표로 표시한다. 각 원변수 벡터에는 레이블을 붙여 변수의 의미를 명확히 부여할 수 있다. 파이썬에서는 전용 함수가 제공되지 않기 때문에, 화살표는 보통 임의로 지정하여 추가한다. 이를 통해 주성분 축과 데이터 분포를 중심으로 각 변수가 어느 방향으로, 얼마나 퍼져나가는지를 확인할 수 있다.</p>
<p>전통적인 PCA 해석에서는 제1축과 제2축의 방향성을 수학적 계산으로 구분하지만, biplot에서는 화살표가 가리키거나 겹치거나 맞닿은 군집 간에서 변수가 유사하게 증가하거나 감소하며, 반대 방향에 위치한 경우에는 전혀 다른 변동성을 보인다. 이러한 시각적 해석 방식은 컨설팅 분야에서 자주 활용되며, 제1축과 제2축에 대한 라벨링과 4분면 구분을 통해 해석을 보다 직관적으로 수행할 수 있다.</p>
<hr>
<p>데이터가 적으므로 데이터 증강을 통해 정규분포를 따르는 노이즈 생성한다. 비율 서로 알맞게 설정. 강건성을 보기 위해서. 여러개 중에 비교하여 월드의 효용성 입증. 2로도 한 번 해보기 어떤 패턴이 나타나는지?? 가우시안 메소드, 베이지안 메소드.(약간 효능감이 떨어진다) 가중치(중심점)가 0.5이상인 것만 표시함 k-mean, 가우시안, 베이지안의 혼동행렬을 출력. 해석 방식이 조금 달라짐. 결과적으로 k-mean, 가우시안이 보다 효능감 있게 분리한다. 여기서 차이가 발생하는 데 이 이유는 각각 중심기준으로 원형태, 타원 형태로 그 기준이 달라서 차이가 나는 것임. 그러나 베이지안이 너무 디테일하게 한다고 특성을 무시하면서 억지로 그룹을 맞추려고 하는 것은 그러면 안된다.</p>
<hr>
<p>시나리오, 할수 있다 없다를 떠나서. CEO관점에서 뭐가 궁금한가? 가설을 여러개 세우고 묶는다. 그리고 단계별로 가지치기하면서 한다. 뭐가 빠져있지? 뭘 붙이지? 어떤 식을 세워야 하는가?</p>
<hr>
<p>종이나 변수에 대해 자세히 설명하기 갭통계량에서는 2를 할 이유는 없다, 적당히 큰 것이 좋기 때문. 기울기가 기준이 아님.</p>
<p>미국 대학의 최신의 데이터를 가져와서 쓰기. 증강한 데이터 패턴. 보여주기, 원데이터의 기초통계량과의 차이 등. 미적분학, 행렬, 벡터. 몇 백만, 십만개로 해야 됨.</p>
<p>아이디어. 데이터 주입. 그럼 분석결과와 시각화 나옴. 클릭하면 파이썬 코드 나옴.</p>
<p>SVM에서도 라그랑주 승수법으로 풀어주는 기법이 있다. RBF커널도 사용. 가장 성능이 좋다고 나옴.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>