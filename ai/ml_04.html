<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-17">

<title>머신러닝: 실무 사례 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">머신러닝: 실무 사례</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 17, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>반도체 HBM 공정과 스마트 CCTV를 중심으로 머신러닝의 실제 활용에 대해 다루고자 한다.</p>
<p>01 제조 공정 혁신</p>
<p>1 . 과거 제조업 현장 오랜 기간 아날로그 방식의 공정 관리에 의존해 왔으나 글로벌 경쟁 심화와 공정 복잡성 증가로 인해 단순 수작업이나 경험 중심의 운영만으로는 품질과 효율성을 확보하기 어려워졌다.</p>
<p>이에 따라 디지털 전환(DX) 과 인공지능 전환(AX) 은 제조업 경쟁력 강화를 위한 핵심 과제로 부상하였다.</p>
<p>DX와 AI 트랜스포메이션의 개념을 정리하고, 실제 사례로서 반도체 HBM 적층 공정의 기술적 차이를 분석한다.</p>
<p>2 . Digital Transformation (DX) 기존의 아날로그 및 비체계적 공정을 시스템화된 디지털 관리 체계와 데이터베이스 기반 운영으로 전환하는 과정이다.</p>
<p>공정, 설비, 품질 관리 정보를 실시간으로 수집·저장 운영 데이터의 추적성(traceability) 확보 표준화된 관리 체계 구축을 통해 오류 및 낭비 최소화 제조업에서 DX는 스마트 팩토리로의 진입을 위한 기초 단계라 할 수 있다.</p>
<p>3 . AI Transformation (AX) DX 위에 구축된 데이터 인프라는 AI 분석을 통한 고도화로 확장된다. 이것은 다음 단계들을 포함한다.</p>
<p>센서 및 IoT 장치를 통한 빅데이터 수집 실시간 데이터 시각화 및 공정 모니터링 이상치(anomaly) 탐지 및 자동 알림 데이터 기반 원인 분석 및 해결 방안 제시 공정 최적화 및 예측 유지보수 이러한 체계는 설비 수준이 낮은 공장에서도 점진적 도입이 가능하며, 데이터 기반 의사결정을 통해 전사적 품질 및 생산성 개선 효과를 제공한다.</p>
<p>4 . 사례 분석: HBM 적층 공정 고대역폭 메모리(HBM)는 여러 개의 DRAM 다이를 수직으로 적층하여 초고속 데이터 전송을 가능케 하는 핵심 기술이다. 하지만 적층 단수가 증가할수록 수율(yield) 저하가 주요 문제로 지적된다.</p>
<p>① SK하이닉스</p>
<p>MR-MUF 공정을 활용하여 적층 단수 증가에도 수율 저하를 최소화한 것으로 평가된다.</p>
<p>일부 보고에 따르면 12단 적층에서도 비교적 안정적인 수율 확보가 가능하다.</p>
<p>② 삼성전자</p>
<p>TC-NCF 기반 공정을 채택했으며, 접합 안정성 확보 및 void 제어 문제로 인해 수율 측면에서 난제를 겪고 있는 것으로 알려져 있다. 다만, 최근에는 Cu-to-Cu 본딩 등 새로운 기술을 병행 도입하고 있다.</p>
<p>공개된 산업 보고 및 전문가 분석에 따르면, “삼성은 수율이 70% 미만, SK는 상대적으로 높은 수율 확보”라는 평가가 존재하나, 이는 공식 수치가 아닌 시장 리서치 기반 추정에 가깝다.</p>
<p>‘HBM’ 골든타임 노리는 엇갈린 시선···삼전 ‘포괄적’ vs SK하닉 ‘트렌드’</p>
<p>[이뉴스투데이 김진영 기자] AI 반도체 시장이 급속도로 확대되는 가운데 고대역폭메모리(HBM)의 중요성이 커지고 있다. 삼성전자와 SK하이닉스는 모두 AI 생태계 확장을 목표로 하고 있지만 HBM을</p>
<p>www.enewstoday.co.kr</p>
<p>AI 시대의 새로운 심장: 삼성전자와 SK하이닉스, HBM과 차세대 메모리 기술로 펼치는 반도체 패권</p>
<p>AI 시대의 HBM 기술 혁명! 삼성전자와 SK하이닉스의 패권 경쟁, 차세대 메모리의 미래를 탐구합니다. 한국 반도체의 도약을 확인하세요!</p>
<p>skywork.ai 따라서 기술적 차이와 경향성은 확인되지만, 구체적인 수치는 신뢰도 높은 자료가 부족하므로 주의가 필요하다.</p>
<p>5 . 결론 DX 와 AX 는 제조업 혁신의 핵심 경로로, 단순한 디지털화에서 나아가 AI 기반 예측·최적화 체계로의 전환을 의미한다.</p>
<p>이는 설비 수준과 무관하게 단계적으로 도입이 가능하며, 스마트 팩토리 구현의 기반이 된다.</p>
<p>HBM 사례는 AX 의 필요성을 잘 보여준다. 고난도의 적층 공정에서는 공정 변수와 결함 데이터를 정밀하게 수집·분석해야 수율을 안정적으로 확보할 수 있다. SK와 삼성의 공정 차이는 이러한 데이터 기반 접근의 중요성을 방증한다.</p>
<p>따라서 제조업의 경쟁력 확보를 위해서는 DX → AX → 스마트 팩토리로 이어지는 단계적 전략이 필수적이며, 이는 단순한 시스템 도입을 넘어 데이터와 AI 중심의 운영 철학 전환을 요구한다.</p>
<p>02 서울시 스마트 CCTV 시스템 서울시는 2020년부터 지능형 CCTV를 도입하여 교통 흐름 분석, 범죄 예방, 실시간 교통 신호 제어 등을 시도하였으나, 초기 도입 단계에서 AI 모델이 실제 현장 환경에서 기대 이하의 성능을 보였다.</p>
<p>이는 모델이 주로 실내 환경이나 정형화된 데이터에만 학습되어, 다양한 날씨, 시간대, 사람의 행동 패턴 등 실제 환경의 변수를 충분히 반영하지 못했기 때문이다.</p>
<p>서울시는 이러한 문제를 해결하기 위해 산·학·연과 자치구가 참여하는 ‘지능형 CCTV 활성화 계획’ 을 수립하고, 맞춤형 이벤트 설정, 오탐 데이터 학습, 사물·사람 구분 학습 등을 추진하였다.</p>
<p>지능형CCTV로 만드는 디지털 안전도시 서울</p>
<p>서울시가 시민 안전 강화 및 범죄 등 예방을 위해 올해 AI기반 지능형 CCTV를 대폭 늘리고, 시민들의 정보접근성을 높여줄 공공와이파이를 확대할 계획입니다. 서울시는 또 유동인구가 많은 곳 등</p>
<p>scpm.seoul.go.kr</p>
<p>서울시, ’지능형 CCTV’로 지자체 ICT 우수사례 대통령상 수상</p>
<p>서울시가 ’제30회 지방자치단체 정보통신 우수사례 발표대회’에서 지능형 CCTV 오탐지 문제 해결로 대통령상인 최우수상을 수상했다. 관제 효율과 시민 안전망 강화가 높이 평가됐다. 서울시는</p>
<p>www.etnews.com 그 결과, 지능형 CCTV의 상황 판별 정확도는 36% → 71%로 향상되었고, 관제요원의 이벤트 확인률도 37% → 82%로 높아졌다.</p>
<p>불필요한 탐지 건수는 월 454만 → 53만 건으로 줄어들며 약 8.8배 감소하였다. 이러한 개선은 사건 처리 건수를 이전보다 6배 이상 증가된 성과를 가져왔다.</p>
<p>또한, 서울시는 2026년부터 지능형 CCTV에 생성형 AI를 접목하는 시범사업을 추진하여, 기존 CCTV가 단순히 ‘이상 유무’ 만을 판별하는 수준에서 ‘왜 이상한지, 어떤 맥락인지’ 를 설명할 수 있는 단계로 진화할 계획이다.</p>
<p>이러한 사례는 AI 기반 CCTV 시스템의 효용성을 높이기 위해서는 다양한 상황을 반영한 데이터 수집과 모델 훈련이 필수적임을 보여준다.</p>
<p>정상 상황뿐 아니라 예외적 상황까지 포함하는 데이터 기반의 모델 훈련이 가장 중요한 요소로 고려되어야 한다.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>