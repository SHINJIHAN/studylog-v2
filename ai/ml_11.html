<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-22">

<title>로지스틱 분류 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">로지스틱 분류</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 22, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>[주제] 에 대해 다루고자 한다.</p>
<p>01 최적화 알고리즘</p>
<p>Alec Radford’s animations for optimization algorithms</p>
<p>Alec Radford has created some great animations comparing optimization algorithms SGD , Momentum , NAG , Adagrad , Adadelta , RMSprop (unfo…</p>
<p>www.denizyuret.com 기본 SGD 외에 다음과 같은 변형을 자주 사용한다.</p>
<p>SGD (확률적 경사하강) — 큰 데이터셋에 효율적 Momentum — 관성 도입으로 수렴 가속 및 진동 완화 AdaGrad — 좌표별 학습률 적응 Adam — 1차·2차 모멘트를 사용한 적응형 방법 (실무에서 널리 사용; 성능·안정성 우수)</p>
<ol type="1">
<li>모델 검증과 일반화 7.1 K-Fold 교차검증 모델 성능 평가를 위해 데이터를 K개의 폴드(fold)로 나누고, 순차적으로 하나의 폴드를 검증셋으로, 나머지를 학습셋으로 사용한다.</li>
</ol>
<p>데이터를 K등분 (예: 5-fold → 5등분) 각 iteration마다 서로 다른 폴드를 검증셋으로 지정 K번 반복 후 평균 성능 산출 특수 사례: LOOCV(Leave-One-Out CV)</p>
<p>데이터 포인트 하나를 검증셋으로, 나머지를 학습셋으로 사용 데이터가 적을 때 모델 평가를 정밀하게 할 수 있음 7.2 학습률(Learning Rate)과 데이터 전처리 학습률은 경사하강법의 파라미터 갱신 속도를 조절하며, 과도하면 발산, 너무 작으면 수렴 속도가 느려진다. 데이터 전처리는 모델 안정성과 성능 향상에 중요하며, 일반적으로 정규화(normalization), 스케일링(scaling), 결측치 처리 등을 포함한다. 7.3 오버피팅 방지 모델이 학습 데이터에만 과적합되는 것을 방지하기 위해 다양한 전략을 사용한다.</p>
<p>데이터 증강(Data Augmentation): 학습 데이터 변형을 통해 다양성을 확보 특징 수 축소(Feature Selection/Reduction): 불필요한 입력 제거 정규화(Regularization): L1/L2 정규화, 드롭아웃(Dropout) 등 이 과정을 통해 모델은 학습 데이터뿐 아니라 미지의 데이터에서도 일반화 성능을 발휘할 수 있다.</p>
<p>03 퍼셉트론과 다층 신경망 Perceptron &amp;Multi-Layer Neural Network</p>
<p>1 . 신경망의 구조와 활성화 함수 인공신경망(NN)은 생물학적 뉴런을 모사하여 입력 신호를 처리한다.</p>
<p>입력 신호(x0,x1,…x_0, x_1, ​,x1​,…): 다른 뉴런(axon)으로부터 전달되는 신호 가중치(w0,w1,…w_0, w_1, ​,w1​,…): 각 신호의 중요도를 나타내며, 시냅스(synapse)와 유사 가중합(dendrite): 각 입력에 가중치를 곱한 후 합산 <span class="math display">\[z = \sum_i w_i x_i + b\]</span></p>
<p>활성화 함수(Activation Function, f): 뉴런의 세포체(cell body)가 총합 입력을 해석하여 출력 신호 생성 <span class="math display">\[y = f(z) = f\Big(\sum_i w_i x_i + b\Big)\]</span></p>
<p>출력 y는 다음 뉴런(axon)으로 전달되며, 이 신호가 0인지 1인지 또는 확률값인지 결정한다. 이 구조를 MLP이라고 하며, 다층 구성으로 비선형 문제를 해결할 수 있다.</p>
<p>2 . 역사적 배경 Frank Rosenblatt (1957): 퍼셉트론(Perceptron) 제안 — 단층 신경망 기반의 이진 분류기 Widrow &amp; Hoff (1960): ADALINE(Adaptive Linear Neuron) / MADALINE — 가중치 적응 학습 규칙 제안 Widrow-Hoff Rule (Delta Rule) 가중치 학습 과정은 다음과 같다.</p>
<p>가중치 초기화Wi(0)을 임의값으로 설정W_i(0) Wi​(0)을 임의값으로 설정 입력 패턴과 목표 출력 제시 출력 계산 (Hard Limiter) <span class="math display">\[y(t) = f_h\Big(\sum_{i=0}^{n-1} w_i(t) X_i(t) - \epsilon\Big)\]</span></p>
<p>: 임계치 f_h​: 하드리미터 함수 가중치 갱신 <span class="math display">\[W_i(t+1) = W_i(t) + \alpha \,[\,d(t) - y(t)\,] X_i(t), \quad 0 \le i \le n-1\]</span></p>
<p>: 학습률, 0 &lt; &lt; 1 d(t): 목표 출력값 실제 출력과 목표 출력이 일치하면 가중치는 변하지 않음 반복 수행 출력이 목표에 도달할 때까지 2~4단계 반복</p>
<p>3 . 퍼셉트론을 통한 논리 연산 퍼셉트론은 기본적인 논리 게이트 연산을 구현할 수 있다.</p>
<p>AND, OR 연산: 입력값의 가중합이 임계치(θ)를 초과하면 출력 1, 아니면 0 XOR 연산: 단층 퍼셉트론으로는 직선 결정경계로 구분 불가능 — 다층 퍼셉트론 필요 입력 X_0, X_1 ​AND OR XOR 0, 0 0 0 0 0, 1 0 1 1 1, 0 0 1 1 1, 1 1 1 0 AND: 위쪽 위치, 직선 결정 가능 OR: 아래쪽 위치, 직선 결정 가능 XOR: 직선 결정 불가, 곡선 또는 다층 구조 필요</p>
<p>03 다층 퍼셉트론과 역전파 Backpropagation</p>
<ol type="1">
<li>초기 비관과 연구의 침체기 1969년, Marvin Minsky 교수와 Seymour Papert는 저서 Perceptrons에서 다음과 같이 지적했다.</li>
</ol>
<p>“멀티 레이어 퍼셉트론(Multi-Layer Perceptron)으로 구성하면 문제를 해결할 수는 있지만, 실제로 구현하는 사람은 아무도 없을 것이다.”</p>
<p>이로 인해 퍼셉트론 연구는 <strong>첫 번째 머신러닝 침체기(Artificial Intelligence Winter)</strong>를 맞이하게 되었다.</p>
<p>단층 퍼셉트론으로 XOR와 같은 비선형 문제를 해결할 수 없다는 한계 다층 구조의 학습 방법 부재 2. 역전파(Backpropagation)의 등장 1974년과 1982년, Paul Werbos는 다층 신경망의 학습 문제를 해결할 방법을 제안했으며, 1986년, Geoffrey Hinton 등이 이를 체계화하였다.</p>
<p>핵심 아이디어: 순방향(forward)으로 출력과 실제값의 차이(오차)를 계산 출력층에서 입력층 방향으로 오차를 역전파(backpropagation) 하여 각 가중치를 조정 이로써 단층 퍼셉트론으로 해결할 수 없었던 XOR 등 비선형 문제도 학습 가능하게 되었다.</p>
<ol start="3" type="1">
<li>수학적 원리 다층 퍼셉트론에서 각 뉴런의 출력은 다음과 같이 정의된다.</li>
</ol>
<p>f=wx+bf = w x + bf=wx+b</p>
<p>또는 단계적으로,</p>
<p>g=wx,f=g+bg = w x, f = g + bg=wx,f=g+b</p>
<p><strong>체인룰(Chain Rule)</strong>과 편미분을 이용하여, 출력 오차를 각 층의 가중치에 대해 분배한다. 미분의 기본 정의: ddxf(x)=lim⁡Δx→0f(x+Δx)−f(x)Δx f(x) = _{x } dxd​f(x)=Δx→0lim​Δxf(x+Δx)−f(x)​</p>
<p>예제: 2차원 입력 x1,x2x_1, x_2x1​,x2​와 가중치 w=[5,−7,−11]w = [5, -7, -11]w=[5,−7,−11]일 경우 출력 [y1,y2]=[1,0,0][y_1, y_2] = [1,0,0][y1​,y2​]=[1,0,0]을 얻을 수 있으며, 각 가중치에 대한 기울기를 계산해 오차를 감소시키는 방향으로 업데이트한다. 4. 의미와 의의 역전파 알고리즘은 신경망 학습의 근간이 되었으며, 다층 퍼셉트론 구조는 XOR와 같은 비선형 문제 해결 가능 현재의 딥러닝 모델(Convolutional Neural Network, Transformer 등)도 이 원리를 확장한 것 즉, 단층 퍼셉트론에서 시작한 연구가 다층 구조와 역전파를 통해 현대 신경망의 기초로 발전하게 된 역사적 과정이다.</p>
<p>①②③④⑤⑥⑦⑧⑨ ⋅ ⌎</p>
<p>₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ⁱ ⁿ / ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ₋ / α β δ θ ε π μ σ Ω φ ω</p>
<p>− ± × ∑ ∴ ≥ ≤ ≒ ≓ ⋯ ⋮ / ⇨ ←→↑↓↔︎↕ / ℉ ℃</p>
<p>[출처]</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>