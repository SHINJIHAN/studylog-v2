<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-03">

<title>인공신경망 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#벡터-변환" id="toc-벡터-변환" class="nav-link active" data-scroll-target="#벡터-변환">03 벡터 변환</a></li>
  <li><a href="#속성별-영향력중요도을-조절" id="toc-속성별-영향력중요도을-조절" class="nav-link" data-scroll-target="#속성별-영향력중요도을-조절">3. 속성별 영향력(중요도)을 조절</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">인공신경망</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 3, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>딥러닝 모델의 학습 과정은 고차원 매개변수 공간에서의 비선형 최적화 문제로 구성되며, 네트워크는 일반적으로 ’Affine → Batch Normalization → ReLU’의 층 구조를 반복적으로 적용하고 마지막 단계에서 Affine 변환 후 Softmax를 통해 확률적 출력 분포를 생성한다. 이 구조는 표현 학습 과정에서 분산 안정화, 비선형성 확보, 기울기 흐름 유지라는 세 가지 관점에서 수학적으로 정당화된다.</p>
<p>학습 과정의 이론적 핵심 중 하나는 <strong>바이어스-분산 트레이드오프</strong>이다. 바이어스는 모델의 구조적 단순화로 인해 발생하는 체계적 오차이며, 분산은 데이터의 작은 변화에 모델이 과도하게 반응하며 발생하는 민감도이다. 이 두 요소는 역비례적 관계에 있어, 바이어스를 지나치게 줄이기 위해 모델 복잡성을 높이면 분산이 급격히 증가하여 일반화 성능이 악화된다(오버피팅). 반대로 분산을 줄이기 위해 모델을 지나치게 단순화하면 고정적 편향이 커져 언더피팅이 발생한다. 적절한 최적점은 검증 데이터의 경험적 리스크 최소 지점을 찾는 방식으로 설정된다.</p>
<p>오버피팅이 발생하는 상황에서는 모델이 훈련 데이터의 세부적 노이즈 패턴까지 과도하게 학습하는데, 이는 파라미터 수가 데이터에 비해 과도하게 많거나, 데이터 분포의 다양성이 충분치 않을 때 더욱 심화된다. 이를 완화하기 위한 실질적 접근으로는 <strong>상위 다중 정답(top-k) 평가 지표 사용</strong>, <strong>훈련 데이터의 증강</strong>, <strong>범주별 데이터 균형화</strong>, <strong>정규화(regularization)</strong> 등이 있다.</p>
<p>정규화 중에서도 L2 정규화(가중치 감소)는 기하학적 관점에서 파라미터 공간을 L2 볼 안에 구속하는 효과를 갖는다. 손실 함수에 라그랑주 항 형태로 λ‖W‖²가 추가되며, 이는 고차원 공간에서 가중치 벡터의 크기를 제어해 최적점이 과도하게 한 방향으로 치우치지 않도록 한다. 수식적으로는 단순히 항을 더하는 것으로 보일 수 있으나, 실제로는 매개변수 공간의 형태를 바꾸어(implicit geometry alteration) 최적화 경로와 수렴 특성을 근본적으로 변화시키는 역할을 한다.</p>
<p>언더피팅을 해결하기 위해서는 <strong>특징(feature) 확장</strong>, <strong>비선형성이 높은 모델(KNN, SVM, Decision Tree 등)</strong>의 활용, 그리고 <strong>모델 용량 증가</strong>가 효과적이다. 본질적으로 언더피팅은 함수 공간 자체의 표현력이 낮을 때 발생한다.</p>
<p>데이터셋의 규모 또한 모델 성능에 강한 영향을 준다. 데이터가 적으면 분산이 높아지고 신뢰도 낮은 추정이 발생한다. 이를 보완하기 위해 전통적 데이터 증강뿐 아니라, 최근에는 생성형 모델을 통한 고차원적 데이터 증강이 활용된다. 이는 단순 변환 기반 증강보다 데이터 다양성을 보다 풍부하게 확보할 수 있다는 점에서 중요한 의미를 가진다.</p>
<p>드롭아웃(dropout)은 완전 연결 계층(fully connected layer)에서 특정 뉴런을 확률적으로 비활성화하여 특정 패턴에 대한 파라미터 공동 의존성을 줄이는 방식이다. 이는 모델이 특정 경로에 과도하게 적응하는 것을 방지해 일반화 오차를 개선하며, 수학적으로는 앙상블 평균 효과를 근사하는 것으로 해석된다. 단, 드롭아웃은 학습 시에만 적용되고, 추론 단계에서는 비활성화된 뉴런을 포함한 전체 네트워크를 사용한다.</p>
<p>또한, <strong>교차 검증(cross validation)</strong>은 모델의 일반화 오류를 안정적으로 추정하기 위해 데이터셋을 K개의 폴드(fold)로 분할하여 반복적으로 평가하는 방법이다. 이는 단일 분할로 인한 편향을 제거하고 모델의 평균적 성능을 측정하는 데 필수적이다.</p>
<p>종합적으로, 이러한 최적화 기법·정규화 전략·데이터 관리 기법들은 딥러닝에서 안정적인 학습과 일반화 성능 향상의 핵심 요소이며, 실험 환경에서 모델의 성능을 체계적으로 평가하기 위한 기본적 도구들이다.</p>
<hr>
<p>모델링의 목적과 목표 변수의 특성은 평가 지표 선택의 이론적·실무적 정당성을 결정하는 핵심 요소이다. 각 지표는 통계적 특성, 손실 함수의 기하학적 구조, 모델의 오차 감도 등을 반영하고 있으므로, 단순 비교가 아니라 ’데이터 생성 과정(DSG: Data-Generating Process)’과 ’목표 함수의 성질’을 고려해 해석해야 한다.</p>
<ol type="1">
<li><p><strong>예측·회귀 모델의 성능 평가</strong> 회귀 문제에서 사용되는 지표들은 대부분 오차의 분포적 성질과 민감도를 달리한다.</p>
<ul>
<li><strong>MSE(Mean Squared Error)</strong>: 잔차의 제곱을 평균한 값으로, 큰 오차에 대해 제곱 패널티를 부여함으로써 이상치(outlier)에 매우 민감하다. 이는 L2-리스크 최소화와 연결되며, 확률적 관점에서 정규분포 오차 가정에 대한 최대우도추정(MLE)과 동등하다.</li>
<li><strong>RMSE(Root MSE)</strong>: MSE의 제곱근으로 단위를 원래 스케일로 복구한다. 기하학적으로는 L2-거리 기반 손실이며, 곡률이 크기 때문에 경사 기반 최적화에서 강한 페널티를 제공한다.</li>
<li><strong>MAPE(Mean Absolute Percentage Error)</strong>: 상대적 오차 비율을 측정하므로 스케일이 다른 시계열·수요 예측 등에서 많이 사용된다. 다만 목표값이 0에 근접하면 불안정해진다는 결함이 있다.</li>
<li><strong>Weighted Quantile Loss(평균 가중 분위수 손실)</strong>: 분위수 회귀(quantile regression)의 손실로, 비대칭 오차 구조(과소·과대 예측 비용이 다름)를 모델링할 때 적합하다. 수치 예측에서 리스크 기반 의사결정(예: 보험·수요 예측)에 널리 사용된다.</li>
<li><strong>WASE(Weighted Absolute Scaled Error)</strong>: 시계열 예측 평가에서 사용되며, 단순 차분 기반 성능 대비 상대적 향상을 평가할 수 있다.</li>
</ul></li>
<li><p><strong>분류 모델의 성능 평가</strong> 분류 지표는 클래스 불균형, 임계값(threshold), 비용 민감도에 따라 해석이 크게 달라진다.</p>
<ul>
<li><strong>Accuracy(정확도)</strong>: 전체 예측 중 맞춘 비율이지만, 클래스 불균형이 존재할 경우 의미가 급격히 저하된다.</li>
<li><strong>Precision(정밀도 = TP/(TP+FP))</strong>: 양성 예측 중 실제로 양성인 비율로, FP에 대한 비용이 큰 문제에서 핵심 지표가 된다.</li>
<li><strong>Recall(재현율 = TP/(TP+FN))</strong>: 실제 양성 중 모델이 탐지한 비율로, FN 비용이 큰 의료·보안 도메인에서 매우 중요하다.</li>
<li><strong>Confusion Matrix(오차 행렬)</strong>: 클래스 간 오차 구조를 직접 파악할 수 있으며, 이후 ROC·PR 커브 분석의 기초가 된다.</li>
<li><strong>F1 Score</strong>: 정밀도와 재현율의 조화평균으로, 두 지표 간 균형이 중요할 때 사용된다. 특히 불균형 데이터에서 모델 선택에 핵심 지표가 될 수 있다. 분류 문제에서는 단순 지표 나열보다, “어떤 오류가 비용 측면에서 가장 치명적인가?”를 우선적으로 판단해야 한다.</li>
</ul></li>
<li><p><strong>객체 탐지 모델의 성능 평가</strong> 객체 탐지 문제는 공간적 위치(Localization)와 클래스 분류(Classification)가 동시에 존재하는 복합 구조다.</p>
<ul>
<li><strong>IoU(Intersection over Union)</strong>: 예측 박스와 실제 박스의 겹침 비율을 나타내는 핵심 지표로, 공간적 정합도(spatial alignment)를 정량화한다. 특정 IoU 임계값(예: 0.5, 0.75 등)에 따라 AP(Average Precision)을 계산하며, 이는 COCO·Pascal VOC 등 주요 벤치마크의 기본 평가 기준이다.</li>
</ul></li>
</ol>
<p>종합하면, 성능 평가는 단순히 지표를 선택하는 과정이 아니라 <strong>문제의 목적 함수, 오차 비용 구조, 데이터 통계적 특성</strong>을 기반으로 이루어져야 하며, 동일 모델이라도 지표 선택에 따라 결론이 달라질 수 있음을 항상 고려해야 한다.</p>
<hr>
<p>클러스터링은 분류의 한 종류이다. 이것은 비지도 학습이다.</p>
<p>이것의 예시는 회원관리서비스에서 주로 쓰인다. 고객을 관리하고 분류해서 등급을 나누고 그에 걸맞는 서비스를 주는 것이다.</p>
<p>이를 전문용어로 CRM이라 한다.</p>
<p>분류 &gt; 세그멘테이션 &gt; 클러스터링으로 좁아지는 형태</p>
<p>그런 그룹을 많이 만들어서 디테일한 서비스를 제공한다면&nbsp; 이는 좋을 수도 있지만 비용적인 측면이 높을 수 있으니 경영적인 측면에선 덜 디테일한 것이 오히려 실무진 입장에선 좋을 수 있음.</p>
<p>이때 그룹잉의 기준 중 하나인 거리기반 그룹잉이 있다.</p>
<p>하이-인트라-클레스 유사도</p>
<p>로우-인트라-클레스 유사도</p>
<p>둘 중 하나로 데이터 세트를 클래스 구성한다. 이를 통해 클래스 레이블과 클래스 개수를 찾아낸다.</p>
<p>클러스터링 알고리즘 수행 시 선호되는 속성들</p>
<ol type="1">
<li>시간과 공간적 관점에서의 규모</li>
<li>서로 다른 타입(유형)의 데이터를 다룰 수 있는 능력</li>
<li>입력 파라미터들을 결정하기 위한 최소한의 도메인 지식</li>
<li>잡음과 이상치를 다룰 수 있는지 여부, 또한 판별도 해야 함.</li>
<li>입력 레코드의 순서에 민감하지 않아야 함, 최근 과거 상관없이 섞어서 골고루.</li>
<li>사용자 관점의 제약 조건 반영 여부, 코로나 시기 등.</li>
<li>결과에 대한 해석능력과 사용성,&nbsp;</li>
</ol>
<p>거리를 계산할 때, 가장 근접 계산 방법과 가장 멀리 떨어진 계산 방법의 차이는 전향적 계산과 보수적 계산으로 나뉘는 것이다. 이것의 중간인 평균 거리 계산도 있다. 워드 링크잉은 합병괸 클러스터들의 분산을 최소화하려고 한다는 것.</p>
<p>거리 측정 방법의 종류</p>
<ol type="1">
<li><p>유클리드 거리(가장 많이 쓰는 방법, 대각선 즉, 직선 거리) 이것은 항공 네비에서 쓰일 수 있다. 사이킷런에서 파라미터로 p=1로 줄 수 있다.</p></li>
<li><p>맨하튼 거리, 바로 대각선으로 가로지르지 않고 가로 세로 몇 블록인지 가는 방법. 이는 보통 자동차 네비게이션에서 쓰인다. 사잇클런에서 파라미터로 p=2로 줄 수 있다.</p></li>
<li><p>최대 놈, 점들의 분포를 고려한 거리 공분산을 고려한 것. 중심이 아니라 데이터의 분포가 곧 가중치가 된다.</p></li>
<li><p>마할라노비스 거리</p></li>
<li><p>코사인 거리, 문서간 유사도 자카드 계수(희박한 데이터에 유용), 편집거리(검색창 등)도 있다. 피어슨 상관계수. “문서”든 “영화”든 결국 벡터로 표현할 수 있으며, 유사도는 벡터 간 거리로 계산되므로 문서 유사도 방식 그대로 영화 등 다양한 비정형 데이터 추천·검색·분류에 활용된다.</p></li>
<li><p>편집거리의 연산들: 헤밍, 레벤슈타인 거리 등</p></li>
</ol>
<p>알고리즘릭하게 하거나 학습을 시켜서 하거나 둘 중 하나일 것이다.</p>
<p>클러스터링 유형</p>
<ol type="1">
<li>중심 기반(가장 자주 사용하는 방법, 쉬운 개산, 개수 정하기 힘듦)</li>
<li>중간점 기반</li>
<li>밀도 기반</li>
<li>계층적 기반</li>
</ol>
<hr>
<section id="벡터-변환" class="level1">
<h1>03 벡터 변환</h1>
<p>영화의 <strong>장르·감독·가격</strong>처럼 서로 다른 속성(이질적 특징)이 <strong>문서 간 유사도</strong>에 사용될 때는, 모든 속성을 <em>같은 공간에서 비교 가능하도록 변환</em>한 뒤 벡터 형태로 통합한다.</p>
<p>핵심은 <strong>표현 통일 → 벡터화 → 가중 결합 → 유사도 계산</strong>이다.</p>
<ol type="1">
<li>서로 다른 개념을 “벡터 공간”으로 통일</li>
</ol>
<p>문서는 텍스트가 아니어도 <strong>모든 특징을 숫자 벡터(feature vector)</strong>로 바꿀 수 있다.</p>
<p><strong>범주형(장르, 감독)</strong></p>
<ul>
<li><p><strong>One-hot encoding</strong>, <strong>Multi-hot encoding</strong>, <strong>Embedding</strong>을 사용</p></li>
<li><p>예: 장르 = {액션, 드라마, SF}</p>
<ul>
<li>한 영화가 액션·SF라면 → <code>[1, 0, 1]</code></li>
</ul></li>
<li><p>감독도 동일한 방식 → 감독 수가 많으면 embedding 사용</p></li>
</ul>
<p><strong>연속형(가격, 평점, 상영시간)</strong></p>
<ul>
<li>그대로 사용하되 <strong>정규화(normalization)</strong> 적용 예: 가격을 0~1 사이로 스케일링</li>
</ul>
<ol start="2" type="1">
<li>모든 특징을 하나의 대형 벡터로 결합</li>
</ol>
<p>예시:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>특징</th>
<th>표현</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>장르</td>
<td><code>[1, 0, 1, 0, 0]</code></td>
</tr>
<tr class="even">
<td>감독</td>
<td><code>[0, 0, 1, 0, 0, …]</code></td>
</tr>
<tr class="odd">
<td>가격</td>
<td><code>0.42</code></td>
</tr>
<tr class="even">
<td>평점</td>
<td><code>0.88</code></td>
</tr>
</tbody>
</table>
<p>→ 최종 문서 벡터: <code>[1, 0, 1, 0, 0, | 0, 0, 1, 0, 0, … | 0.42 | 0.88]</code></p>
<p>이렇게 하면 “완전히 다른 개념”도 하나의 벡터 안에서 함께 존재할 수 있음.</p>
</section>
<section id="속성별-영향력중요도을-조절" class="level1">
<h1>3. 속성별 영향력(중요도)을 조절</h1>
<p>속성이 본질적으로 다르기 때문에 <strong>가중치(weight)</strong>를 준다.</p>
<p>예:</p>
<ul>
<li>줄거리 텍스트: 50%</li>
<li>장르: 30%</li>
<li>감독: 10%</li>
<li>가격: 10%</li>
</ul>
<p>이를 반영하면,</p>
<ul>
<li>감독이 다르다고 해서 문서 유사도가 0이 되는 것을 방지</li>
<li>가격 같은 숫자형 특징이 과도하게 영향 주는 것도 방지</li>
</ul>
<ol start="4" type="1">
<li>결합된 벡터에 <strong>코사인 유사도</strong>를 적용</li>
</ol>
<p>최종적으로는 두 영화 벡터의 코사인 유사도를 계산:</p>
<p>[ (A, B) = ]</p>
<p>이렇게 하면</p>
<ul>
<li>장르가 비슷하면 해당 부분 벡터가 기여</li>
<li>가격·감독이 비슷하면 그 부분이 기여</li>
<li>전체적으로 종합된 유사도가 나옴</li>
</ul>
<ol start="5" type="1">
<li>핵심 정리</li>
</ol>
<ul>
<li><strong>서로 다른 개념</strong>이어도 → 모두 <strong>동일한 벡터 공간의 차원</strong>으로 변환</li>
<li><strong>각 속성을 수치화</strong>한 뒤 하나의 벡터로 결합</li>
<li>필요하면 <strong>가중치</strong>를 부여</li>
<li>마지막에는 <strong>코사인 유사도</strong>로 비교</li>
</ul>
<hr>
<p>핵심은 <strong>“서로 다른 정보들을 모두 숫자 벡터로 만들어 하나의 ’영화 프로필’로 통합하고, 그 프로필끼리 유사도를 비교한다”</strong>는 점입니다. 이게 가능한 이유는 <strong>모든 종류의 데이터(장르·감독·가격·텍스트 등)는 결국 수치화할 수 있기 때문</strong>입니다.</p>
<ol type="1">
<li>핵심 1: 모든 속성을 한 줄짜리 숫자 벡터로 만든다</li>
</ol>
<p>영화마다 <strong>정리된 요약 정보(프로필)</strong>를 하나의 벡터로 만든다고 생각하면 됩니다.</p>
<p>예:</p>
<ul>
<li>“액션·SF” → [1, 0, 1]</li>
<li>“감독 A” → [0, 1, 0, 0]</li>
<li>“가격 9,000원” → 0.45</li>
<li>“평점 8.3” → 0.83</li>
</ul>
<p>→ 결국 하나의 벡터: <code>[1, 0, 1, 0, 1, 0, 0, 0.45, 0.83]</code></p>
<ol start="2" type="1">
<li>핵심 2: 두 영화 벡터의 거리를 비교하면 ’비슷한 영화’가 된다</li>
</ol>
<p>벡터 A와 벡터 B가 비슷하면 → 영화도 비슷하다고 판단. 다르면 → 유사도가 낮다. 즉, <strong>문서(영화) 간 유사도 = 벡터 간 유사도</strong> 이 원리 하나로 모든 속성이 비교 가능해진다.</p>
<ol start="3" type="1">
<li>핵심 3: 활용되는 곳 (실제 사례)</li>
</ol>
<p><strong>추천 시스템</strong></p>
<ul>
<li>사용자가 본 영화와 비슷한 벡터를 가진 영화를 찾아 추천</li>
<li>장르·감독·가격·평점 모두 반영된 추천 가능</li>
</ul>
<p><strong>콘텐츠 검색</strong></p>
<ul>
<li>“액션이면서 SF 느낌 나는 영화” → 장르 벡터와 유사한 영화 자동 추출</li>
</ul>
<p><strong>마케팅 타겟팅</strong></p>
<ul>
<li>특정 가격대 + 특정 감독 선호 + 특정 장르 조합을 가진 영화군 자동 분류</li>
</ul>
<p><strong>클러스터링(군집)</strong></p>
<ul>
<li>영화 전체를 벡터화 → 비슷한 영화끼리 자동 그룹화</li>
<li>가격/감독/장르 차이까지 포함해 군집 생성 가능</li>
</ul>
<hr>
<p>문서 유사도와 “영화 유사도(메타데이터 기반)”가 <strong>완전히 같은 원리</strong>로 작동한다는 점이 핵심입니다. 즉, <strong>문서를 비교하든 영화를 비교하든 결국 ’특징 벡터 간 거리 비교’라는 한 원리를 공유</strong>합니다.</p>
<ol type="1">
<li>문서 유사도 계산의 본질</li>
</ol>
<p>문서 유사도는 일반적으로 다음 절차를 따릅니다.</p>
<ol type="1">
<li><p>문서를 <strong>특징 벡터(feature vector)</strong>로 변환</p>
<ul>
<li>단어를 TF-IDF, BOW, Embedding 등으로 숫자 벡터화</li>
</ul></li>
<li><p>문서 간 <strong>코사인 유사도</strong>를 계산</p></li>
<li><p>유사한 문서를 찾음</p></li>
</ol>
<p>즉, <strong>문서 → 벡터, 문서 간 유사도 = 벡터 간 유사도</strong> 이 구조입니다.</p>
<ol start="2" type="1">
<li>영화도 “문서 취급”해서 동일한 구조로 비교</li>
</ol>
<p>영화는 텍스트가 아니지만, 다음 속성들을 모두 <strong>숫자 벡터</strong>로 변환할 수 있습니다.</p>
<ul>
<li>장르</li>
<li>감독</li>
<li>배우</li>
<li>상영시간</li>
<li>가격</li>
<li>평점</li>
<li>줄거리 텍스트(TF-IDF, embedding)</li>
</ul>
<p>이걸 하나의 벡터로 합치면, <strong>영화 = 문서와 동일한 ’특징 벡터’가 됨</strong> 따라서 문서 유사도와 완전히 같은 방식으로 비교할 수 있다.</p>
<ol start="3" type="1">
<li>문서 유사도 = 특징 벡터 유사도</li>
</ol>
<p>영화도 문서도 결국, <strong>“특징 벡터끼리의 거리/유사도 계산”</strong>으로 정의됩니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 54%">
<col style="width: 18%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>비교 대상</th>
<th>벡터 만드는 방식</th>
<th>유사도 계산</th>
<th>결과</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>문서</td>
<td>단어 벡터(TF-IDF 등)</td>
<td>코사인 유사도</td>
<td>유사 문서</td>
</tr>
<tr class="even">
<td>영화</td>
<td>장르/감독/가격/텍스트 등 통합 벡터</td>
<td>코사인 유사도</td>
<td>유사 영화</td>
</tr>
</tbody>
</table>
<p>둘이 100% 동일한 구조입니다.</p>
<ol start="4" type="1">
<li>활용 방식: 문서 유사도와 완전히 동일</li>
</ol>
<p>문서 유사도가 다음을 가능하게 하듯:</p>
<ul>
<li>비슷한 문서 검색</li>
<li>토픽 클러스터링</li>
<li>문서 분류</li>
<li>유사 문서 추천</li>
</ul>
<p>영화도 같은 방식으로 활용 가능합니다.</p>
<p>예)</p>
<ol type="1">
<li>사용자가 본 영화 A → 벡터(A)</li>
<li>전체 영화 벡터 중 벡터(A)와 가장 가까운 영화들 검색 → <strong>영화 추천 시스템 구현</strong></li>
</ol>
<p>즉,</p>
<blockquote class="blockquote">
<p>문서 추천에서 문서를 “영화”로 바꾸기만 하면 그대로 적용된다.</p>
</blockquote>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>