<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-22">

<title>현대 AI 연구 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">현대 AI 연구</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 22, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>인공지능 발전과 대규모 언어 모델의 CoT 통합 구조에 대해 다루고자 한다.</p>
<p>01 AI의 학문적 발전 인공지능(AI)의 발전은 소프트웨어적 진화와 하드웨어적 진화라는 두 축을 중심으로 병행되어 왔다.</p>
<p>이 두 축은 독립적으로 발전한 것이 아니라, 서로 상호 보완적 관계 속에서 영향을 주고받으며 오늘날의 AI 연구 쳬계를 형성하였다.</p>
<p>1 . 소프트웨어적 발전 ① 인과관계 중심 접근</p>
<p>심볼릭 어프로치, Symbolic AI</p>
<p>AI 연구의 초창기에는 인간의 사고 과정을 모사하기 위해 명시적 인과관계(explicit causality)를 기반으로 한 접근이 시도되었다.</p>
<p>이 시기의 대표적 연구 흐름은 Symbolic AI로, 지식공학(knowledge engineering)을 중심으로 발전하였다.</p>
<p>대표적 사례로는 전문가 시스템(expert system)이 있으며, MYCIN과 DENDRAL이 대표적 예이다.</p>
<p>이러한 시스템은 인간 전문가의 지식을 ’규칙(rule)’과 ’추론(inference)’의 형태로 체계화하여, 명시적으로 저장하고, 이를 이용해 논리적 결론을 도출하는 구조를 가진다.</p>
<p>장점 원인과 결과의 관계가 명확하므로, 시스템의 판단 근거를 추적할 수 있어 설명 가능성(explainability)이 높다.</p>
<p>한계 모든 지식을 사람이 사전에 정의해야 하므로, 현실 세계의 복잡성과 불확실성을 충분히 반영하지 못한다.</p>
<p>② 상관관계 중심 접근</p>
<p>애니매틱 어프로치, Connectionist / Statistical AI</p>
<p>이후 연구자들은 인과관계를 직접 모델링하기 보다는, 데이터로부터 패턴을 학습하는 방향으로 나아갔다.</p>
<p>이것이 바로 연결주의적 또는 통계적 접근으로, 오늘날의 머신러닝 및 딥러닝의 기반이 된다.</p>
<p>이 접근법에서는 대량의 데이터를 수집·정제한 뒤, 심층신경망(deep neural networks) 등의 모델을 학습시켜 결과를 도출한다.</p>
<p>장점 명시적 인과모형 없이도 높은 예측 정확도를 달성하며, 이미지 인식·자연어 처리·음성 인식 등 다양한 분야에서 혁신적 성과를 보였다.</p>
<p>한계 모델 내부 구조가 복잡하고 가중치에 의존하므로, 판단 과정이 불투명한 블랙박스(black box) 문제가 발생한다.</p>
<p>즉, 상관관계를 통해 결과를 도출할 수는 있지만, 그 관계가 ‘왜’ 성립하는가에 대한 설명이 어렵다. 이로 인해 실세계 응용에서 신뢰성과 윤리성의 한계가 제기되었다.</p>
<p>③ 하이브리드 접근 및 설명 가능한 AI</p>
<p>Explainable AI, XAI OR Neuro-Symbolic AI</p>
<p>이러한 한계를 극복하기 위한 새로운 방향으로 설명 가능한 인공지능 연구가 등장하였다.</p>
<p>이는 심볼릭 AI의 논리적 해석력과 연결주의 AI의 학습 능력을 통합하는 하이브리드 AI, 혹은 뉴로-심볼릭 AI의 형태로 발전하고 있다.</p>
<p>이 접근의 핵심은 예측성과 해석성의 통합에 있다.</p>
<p>하이브리드 AI의 운영 구조는 다음과 같다.</p>
<p>예측 단계: 대규모 데이터를 활용하여 통계적 분석과 패턴 인식을 수행함으로써 예측 결과를 생성한다.</p>
<p>설명 단계: 규칙 및 온톨로지 기반의 인과 추론 체계를 활용하여, 예측의 근거를 논리적으로 해석하고 검증한다. 적용 분야: 의료, 금융, 법률 등 설명 가능성이 필수적인 영역. 현재 한계: 완전한 인과적 추론 수준에는 아직 도달하지 못하였으며, 인과적 설명의 내재화(causal reasoning integration)는 여전히 AI 연구의 핵심 과제로 남아 있다.</p>
<p>2 . 하드웨어적 발전 Physical AI</p>
<p>AI의 발전은 알고리즘적 진보를 넘어, 물리적 지능(physical intelligence)의 단계로 확장되었다.</p>
<p>이를 피지컬 AI(Physical AI)라고 불리며, 단순한 연산 능력 향상이 아니라 실제 환경과의 실시간 상호작용을 가능하게 하는 새로운 패러다임을 의미한다.</p>
<p>① 철학적 배경</p>
<p>피지컬 AI의 이론적 기반은 ” 지능은 환경과의 상호작용을 통해 완성된다 ” 는 체화된 인지(embodied cognition) 개념에 있다.</p>
<p>이는 지능을 단순한 계산 능력이 아니라, 신체적 경험과 감각적 피드백을 포함한 총체적 능력으로 본다.</p>
<p>② 실제 구현</p>
<p>이 개념은 자율주행차, 로봇 조작, 드론 제어, 스마트 IoT 기기 등에서 실현되고 있다.</p>
<p>AI 알고리즘이 센서 및 엑추에이터와 결합함으로써, 기계는 외부 자극을 인식하고 판단하며 행동하는 실시간 자율 시스템으로 발전한다.</p>
<p>③ 학문적 의미</p>
<p>단순 기술 확장이 아니라, AI가 스스로 감지, 학습, 행동하는 실체적 지능을 실현하려는 연구 축으로 이해할 수 있다.</p>
<p>하드웨어적 발전은 단순한 기술적 진보가 아닌, AI의 실체적 존재화(realization)로 이해된다.</p>
<p>즉, AI가 데이터로만 존재하던 비물질적 지능에서 벗어나, 감지(sensing)–학습(learning)–행동(acting)의 순환 구조를 스스로 수행하는 단계로 진입한 것이다.</p>
<p>따라서 하드웨어적 진화는 소프트웨어 중심 AI의 한계를 보완하며, 현실 세계 속에서 자율적 판단과 행동 능력을 구현하는 핵심 축으로 평가된다. 이는 향후 지능의 통합적 구현(integrated intelligence)을 실현하기 위한 필수적 토대로 자리 잡고 있다.</p>
<p>02 CoT 통합 구조 Chain-of-Thought Integrated Architecture</p>
<p>대규모 언어 모델(LLM, Large Language Model)은 최근 몇 년간 두 가지 방향으로 발전해왔다.</p>
<p>① 하나는 언어 생성 능력(Language Generation)에 초점을 둔 학습 중심형 모델(Learning-Oriented Model)</p>
<p>② 다른 하나는 논리적 사고(Logical Reasoning)를 내재화한 추론 중심형 모델(Reasoning-Oriented Model)이다.</p>
<p>이 구분은 모델의 구조적 형태보다는, 모델이 최적화하는 목적 함수(Objective Function)와 훈련 패러다임(Training Paradigm)의 차이에 의해 정의된다.</p>
<p>1 . 학습 중심형 모델 Learning-Oriented Model</p>
<p>GPT-3에서 GPT-4.5로 이어지는 계열은 지도 학습(SL)과 자기회귀 언어 모델링(Autoregressive Language Modeling)을 기반으로 한 대표적 학습형 구조이다.</p>
<p>이 모델들은 입력된 문맥(Context)에 대해 다음 단어의 조건부 확률을 최대화하도록 학습된다.</p>
<p><span class="math display">\[P(w_t | w_1, w_2, \ldots, w_{t-1}; \theta)\]</span></p>
<p>(:) 모델의 파라미터 손실 함수: 일반적으로 음의 로그 가능도(Negative Log-Likelihood)로 정의된다. <span class="math display">\[\mathcal{L}(\theta) = -\sum_{t=1}^{T} \log P(w_t | w_{&lt;t}; \theta)\]</span></p>
<p>이 접근은 모델이 방대한 언어 데이터를 통계적으로 모사하며, 언어의 문맥적 패턴을 효율적으로 학습하게 만든다.</p>
<p>GPT-4.5 이하의 모델들은 주로 텍스트 생성(Text Completion), 요약(Summarization), 번역(Translation) 등 언어적 유창성이 필요한 과제에 최적화되어 있다.</p>
<p>그러나 이러한 모델들은 논리적 추론(logical reasoning)과 같은 고차적 사고를 명시적으로 수행하지 못한다는 한계를 지닌다.</p>
<p>2 . 추론 중심형 모델 Reasoning-Oriented Model</p>
<p>이 한계를 보완하기 위해 OpenAI는 2024년 이후 O 시리즈(O1, O1-mini, O3 등)를 개발하였다.</p>
<p>이들 모델은 단순한 언어 예측이 아닌, 사고 과정(CoT)을 내재화하여 논리적·수학적 추론을 수행하도록 설계된 구조이다.</p>
<p>즉, 결과를 곧바로 산출하는 대신, 모델 내부에서 일련의 사고 단계를 거쳐 중간 논리 과정(intermediate reasoning steps)을 생성한 후 최종 응답을 도출한다.</p>
<p>이를 수식적으로 표현하면 다음과 같다.</p>
<p><span class="math display">\[\text{Answer} = f_\theta(\text{Prompt}) = g_\theta(\text{Chain of Thought Steps})\]</span></p>
<p>(g_:)​ 모델 내부의 사고 전개 과정.</p>
<p>즉, 모델은 단순히 단어를 예측하는 확률기계가 아니라, 내재적 추론 구조를 가진 사고 시스템으로 진화한 것이다.</p>
<p>이러한 추론 능력은 별도의 규칙 기반이 아닌, 사전학습(Pretraining)과 인간 피드백 강화학습(RLHF)을 통해 점진적으로 강화된다.</p>
<p>결과적으로 O 시리즈는 언어의 표현 능력보다 사고의 정확성과 합리성을 우선시하는 추론 중심형(reasoning-oriented) 모델로 분류된다.</p>
<p>3 . GPT-5: CoT 기반 통합형 모델 Integrative Model</p>
<p>2025년 발표된 GPT-5는 기존 GPT 계열의 학습 중심형 구조와 O 시리즈의 추론 중심형 구조를 통합한 CoT 기반 하이브리드 LLM 아키텍처로 정의된다.</p>
<p>GPT-5는 입력의 복잡도에 따라 자동으로 두 가지 처리 모드 중 하나를 선택한다.</p>
<p>Fast Mode: 단순 질의에 대한 신속 응답 Deliberative Mode: 복합 문제에 대한 단계적 사고(CoT 기반)로 자동 전환하는 이중 처리 구조를 갖는다. 이 과정을 수식으로 나타내면 다음과 같다.</p>
<p><span class="math display">\[\text{Output} = \begin{cases} f_\theta(x) &amp; \text{if } x \in \text{simple query} \\ f_\theta(g_\theta(x)) &amp; \text{if } x \in \text{complex reasoning task} \end{cases}\]</span></p>
<p>(g_(x):) CoT 기반 내부 사고 전개 과정. 이를 통해 GPT-5는 단순 질의응답(Q&amp;A)에서는 빠른 응답을 제공하고, 복합적인 문제(계획 수립, 코드 분석, 수학적 추론 등)에서는 단계적 사고 절차를 자동으로 활성화한다.</p>
<p>4 . 이론적 통합 관점 학술적 관점에서 보면 GPT-5의 구조적 진화를 요약하면 다음과 같다.</p>
<p><span class="math display">\[\text{L-O GPT (≤4.5)} + \text{R-O O-Series} \Rightarrow \text{GPT-5 (Integrated CoT Model)}\]</span></p>
<p>즉, GPT-5는 단순히 매개변수 규모가 확장된 모델이 아니라, 학습 중심적 언어 처리와 추론 중심적 사고 구조를 결합하여 인공지능의 인식 능력(perception)과 사고 능력(reasoning)을 동시에 고도화한 모델로 정의된다.</p>
<p>LLM 발전 모델 비교 구분 모델 계열 중심 개념 주요 기능 학습 중심형 GPT-3 ~ GPT-4.5 언어 패턴 학습 및 문맥 예측 언어 생성, 번역, 요약 등 추론 중심형 O1 ~ O3 논리적 사고 및 CoT 전개 논리·수학적 문제 해결 통합형 GPT-5 언어 생성 + 사고 통합 자동 모드 전환, 고차원 추론 수행</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>