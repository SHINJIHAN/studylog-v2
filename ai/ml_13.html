<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-22">

<title>현대 AI 연구 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">현대 AI 연구</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 22, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>Reporting Date: November. 5, 2025</p>
</blockquote>
<p>엔비디아(NVIDIA)는 인공지능 연산을 위한 GPU 시장의 절대적 선도 기업으로, 최근에는 하드웨어 중심의 성능 향상을 넘어 AI 생태계 전체를 아우르는 플랫폼 전략으로 진화하고 있다. 대표적으로 ‘코스모스(Cosmos) Simulation Model’과 ‘옴니버스(Omniverse)’ 플랫폼은 3D 모델링, 물리 기반 시뮬레이션, 렌더링을 통합하여 현실과 유사한 디지털 트윈(Digital Twin) 환경을 구현하는 기술적 기반을 제공한다. 이러한 시뮬레이션 시스템은 실제 물리 세계의 상호작용을 정밀하게 재현함으로써, AI 에이전트(agent)의 학습, 검증, 최적화 실험을 위한 실증적 환경을 제공한다.</p>
<p>2025년 기준으로 인공지능 연구의 핵심 개념은 에이전트(Agent)이다. 이는 인간의 인지적 판단과 행동을 모사하거나 대리 수행할 수 있는 자율적 지능 시스템을 의미한다.</p>
<p>과거의 대화형 AI는 명시적으로 프로그래밍된 규칙에 의존했으나, 현재는 자연어 프롬프트(prompt)를 통해 고차원적 명령을 직접 해석하고 실행할 수 있다. 이러한 고도화된 시스템의 중심에는 대규모 언어모델(LLM, Large Language Model)이 있으며, 이는 언어적 지식뿐 아니라 시각·음성·문서 등 다양한 데이터 모달리티(modality)를 통합한 멀티모달 구조로 발전하고 있다.</p>
<p>LLM의 기술적 진화는 ‘멀티모달 학습(Multimodal Learning)’ 역량을 중심으로 전개된다. 텍스트, 이미지, 오디오, 비디오 등의 이질적 데이터를 통합적으로 해석하고 상호 연관성을 학습하는 것이 핵심이며, 이는 각 데이터 형식별로 고유한 입출력 구조와 통신 프로토콜을 요구한다.</p>
<p>현재의 LLM은 외부 데이터를 분석하고 가공할 수 있으나, 인간 수준의 자율적 시각 생성 능력에는 아직 도달하지 못한 상태다.</p>
<p>AI의 실질적 응용의 종착점은 ’피지컬 AI(Physical AI)’이다. 이는 로봇, 제조, 물류, 스마트 팩토리 등 물리적 환경에서 실시간으로 인지·판단·행동을 수행할 수 있는 지능형 시스템을 의미한다. 미국은 첨단 반도체 설계 능력을 보유하고 있으나, 제조 기반의 약화로 인해 피지컬 AI의 산업적 적용에는 한계가 존재한다. 반면, 중국은 제조 기술과 산업 자동화 인프라 측면에서 강점을 보유하고 있으나, 미·중 기술 패권 경쟁이 양국 간 협력의 제약 요인으로 작용한다.</p>
<p>이러한 상황 속에서 블랙록(BlackRock), 오픈AI(OpenAI)의 샘 알트먼(Sam Altman), 앤스로픽(Anthropic)의 다리오 아모데이(Dario Amodei), 엔비디아의 젠슨 황(Jensen Huang) 등 AI 생태계를 주도하는 주요 인물들은 한국을 차세대 전략적 거점으로 평가하고 있다. 이는 반도체 제조 분야에서 삼성전자와 SK하이닉스가 가진 기술적 우위와 글로벌 공급망 내 핵심적 위치 때문이다.</p>
<p>한국의 반도체 산업은 엔비디아와 같은 AI 중심 기업의 연산 가속화를 위한 필수적 기반으로 작용하며, 양측의 기술적 상호의존 관계는 AI 반도체 생산 효율을 높이고, 피지컬 AI 산업화의 촉진을 가능하게 하는 협력 생태계를 형성하고 있다.</p>
<hr>
<p>인공지능의 이론적 기반은 크게 두 가지로 구분된다.</p>
<p>첫째, 인과관계 기반의 <strong>지식 모델</strong>은 인간의 논리적 추론과 유사한 방식으로 동작하며, 둘째, 상관관계 기반의 <strong>데이터 모델</strong>은 통계적 학습을 통해 패턴을 식별한다.</p>
<p>즉, 학습 기반 AI의 이해 연결주의(Connectionism) – 데이터에 대한 학습 능력을 이용하여 지능 구현</p>
<p>후자의 대표적 구현이 머신러닝(ML)과 딥러닝(DL)이며, 인공신경망(ANN) 및 생성형 AI 모델이 이에 포함된다.</p>
<hr>
<p>ANN <code>Artificial Neural Network</code> 인간의 신경세포(뉴런) 구조를 모사한 계산 모델이다.</p>
<p>뉴런은 수상돌기(다중 입력), 세포핵(통합 중심), 축삭돌기(단일 출력)로 구성되며, 시냅스(synapse)를 통해 연결된다. 인간의 뇌는 약 1000억 개의 뉴런과 100조 개 이상의 시냅스로 이루어져 있으며, 각 뉴런은 평균 1000개 이상의 시냅스를 형성한다.</p>
<p>입력 신호는 수상돌기를 통해 수집되어 세포핵에서 통합·처리되며, 각 입력의 영향력은 가중치(weight)로 조정된다.</p>
<p>신호가 일정 임계치를 초과하면 <strong>활성화 함수(activation function)</strong>에 의해 출력으로 변환된다.</p>
<p>이때 주로 사용되는 함수는 <strong>역치 함수(threshold function)</strong>와 <strong>시그모이드(sigmoid) 함수</strong>이며, 이는 입력 자극의 강도와 출력 반응의 비선형 관계를 수학적으로 모델링한다.</p>
<p>출력 신호는 축삭돌기를 따라 전도되며, 말단부에서는 아세틸콜린 등의 <strong>신경전달물질</strong>을 통해 다른 뉴런으로 전파된다. 학습 과정에서 형성되는 시냅스의 가중치 변화가 곧 <strong>기억과 학습의 수학적 표현</strong>이다.</p>
<p>시각 정보를 예로 들면, 인간의 눈은 약 700만 개의 원추세포와 1억 2000만 개의 막대세포로 구성되어 색상과 명암을 인식한다. 인공신경망에서는 이러한 시각 입력을 디지털 이미지의 픽셀로 표현하며, 예를 들어 28×28 흑백 필기체 데이터는 784차원 벡터로 변환되어 입력층에 주어진다.</p>
<p>다층 퍼셉트론(MLP, Multi-Layer Perceptron)은 이 벡터 데이터를 여러 은닉층(hidden layer)을 통해 비선형적으로 변환하며, 각 층의 노드 수와 활성화 방식에 따라 인식 정확도가 달라진다.</p>
<p>출력층(output layer)에는 가중치 대신 확률 분포를 계산하는 소프트맥스(Softmax) 함수가 사용된다. 이를 통해 예측 결과를 확률적으로 해석할 수 있으며, TOP-1 또는 TOP-3 정확도를 기준으로 분류 성능을 평가한다.</p>
<p>하지만 모델의 복잡도가 과도하면 과적합(overfitting)이 발생할 수 있으며, 이는 학습 데이터의 특성에 과도하게 종속된 결과를 초래한다. 따라서 모델 구조의 단순화나 규제화(regularization) 기법을 통해 이를 완화한다.</p>
<p>음성 데이터는 또 다른 모달리티를 구성한다. 파형, 주파수, 진동의 패턴을 학습하여 화자 인식, 음성 인식, 다자 음성 분리 등으로 응용된다. 철도나 엘리베이터의 작동음 분석을 통해 고장 여부를 조기 진단하는 산업적 활용도 이에 해당한다.</p>
<p><strong>결국 인식(recognition)은 곧 분류(classification)이다.</strong></p>
<p>신경망이 입력을 해석하고, 그 결과를 특정 클래스에 매핑하는 과정은 본질적으로 확률적 분류 문제이다. 이러한 학습의 핵심은 오차(error)를 줄이는 것이며, 과거에는 복잡한 가중치 구조로 인해 학습이 어려웠으나, 역전파(backpropagation) 알고리즘의 도입으로 이를 해결하였다.</p>
<p>이 혁신으로 인해 인공신경망은 1980년대 후반의 혹한기를 극복하고, 현대 딥러닝의 토대를 구축하게 되었다.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>