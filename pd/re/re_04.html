<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Learning React: Modern Patterns for Developing React Apps">
<meta name="dcterms.date" content="2024-11-05">

<title>함수형 프로그래밍 – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">함수형 프로그래밍</h1>
  <div class="quarto-categories">
    <div class="quarto-category">code</div>
    <div class="quarto-category">analysis</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Learning React: Modern Patterns for Developing React Apps </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>(P.68)</p>
<p>기본적으로 함수들을 통해 프로그램을 구성하는 스타일에 대해 다루고자 한다.</p>
<p>Chapter 3 Functional programming with JavaScript</p>
<p>패러다임 (Paradigm) 한 시대의 사고 방식이나 가치관, 믿음 체계를 의미한다. 이는 특정 시대나 분야에서 표준으로 여겨지는 틀을 말하며,</p>
<p>학문, 기술, 예술 등 다양한 분야에서 어떤 접근이나 방법론이 주류로 자리잡고 그것을 중심으로 사고하게 되는 것을 가리킨다.</p>
<p>프로그래밍 패러다임 (Programming Paradigm) 프로그래머가 코드를 바라보는 관점을 제공하고, 어떻게 문제를 해결하고 코드를 작성할지에 대한 방향을 제시하는 역할을 한다.</p>
<p>패러다임마다 특정 방식과 철학을 가지고 있어, 각 패러다임이 지향하는 목표에 따라 문제를 다루고 해결하는 방식이 달라진다.</p>
<p>주요 프로그래밍 패러다임에는 다음과 같은 것들이 있다.</p>
<p>명령형 프로그래밍 (Imperative programming) 무엇(What)을 할 것인지 나타내기보다 어떻게(How) 할 건지를 설명하는 방식</p>
<ol type="1">
<li>절차지향 프로그래밍 (Procedural Programming) C 언어, C++ 같은 명령형 프로그래밍 언어는 수행되어야 할 순차적인 처리 과정을 포함하는 방식으로 프로그램을 작성한다.</li>
</ol>
<p>특히, C 언어는 1970년대에 등장하면서 시스템 프로그래밍의 기반이 되었다.</p>
<p>그러나 1만 줄 이상의 코드를 작성할 경우 오류를 수정하기 어렵고,</p>
<p>한 부분을 수정하기 위해 그것과 연관된 다른 줄을 모두 찾아서 수정해야 하는 상황이 발생할 수 있다.</p>
<p>소프트웨어 공학에서는 소프트웨어 개발 주기가 존재하며, 이 주기에서 가장 비용이 큰 부분은 유지 보수이다.</p>
<p>유지 보수 비용은 전체 개발 비용의 약 70%를 차지할 정도로 매우 높아서, 효율적인 유지 보수 방안이 중요한 요소로 여겨진다.</p>
<p>따라서 명령형 프로그래밍 언어는 유지보수를 하기에 적합한 언어가 아니라고 할 수 있다.</p>
<ol start="2" type="1">
<li>객체지향 프로그래밍 (Object-Oriented Programming, OOP) 객체들의 집합으로 프로그램의 상호작용을 표현하는 방식.</li>
</ol>
<p>C++, Java, C#과 같은 언어들이 대표적이며, 이들 언어는 1980년대에 개발된 이후 현실 세계의 모든 것을</p>
<p>객체로 바라보는 접근 방식을 채택하고 있다.</p>
<p>데이터와 그 데이터를 처리하는 메소드를 하나의 단위인 객체로 묶어서 관리함으로써, 코드의 재사용성과 유지보수성을 높이는 데 기여한다.</p>
<p>특히, 2000년대 이후에는 Java 개발자에 대한 수요가 급증하였다.</p>
<p>이는 Java가 플랫폼 독립성과 강력한 생태계, 다양한 프레임워크를 제공하므로, 많은 기업들이 Java를 기반으로 한 시스템 개발에 집중하고 있음을 나타낸다.</p>
<p>이는 소프트웨어 개발의 효율성을 높이고, 복잡한 시스템을 보다 쉽게 관리할 수 있도록 도와준다.</p>
<p>선언형 프로그래밍 (Declarative Programming) 어떻게 할 것인지를 나타내기보다 무엇을 할 것인지를 설명하는 방식</p>
<p>함수형 프로그래밍 (Functional Programming) 순수 함수를 조합하여 소프트웨어를 만드는 방식.</p>
<p>대표적인 언어로는 클로저(Closure), 하스켈(Haskell), 리스프(Lisp)가 있으며, 이 패러다임은 1930년대에 제안된 람다 함수법에 기반한다.</p>
<p>그러나 그 당시에는 이를 실제로 구현할 수 있는 환경이 마련되지 않았다. 2015년에는 함수형 프로그래밍의 개념이 실제로 구현될 수 있는 기술적 발전이 이루어졌다.</p>
<p>주요 특징은 거의 모든 것을 순수 함수(Pure function)로 나누어 문제를 해결하는 기법이며, 이는 다음과 같은 장점을 가진다.</p>
<ol type="1">
<li><p>복잡한 문제를 작은 문제로 나누어 각각을 해결하기 위한 함수를 작성함으로써, 코드의 구조가 명확해진다.</p></li>
<li><p>각 함수가 명확한 기능을 가지므로, 코드의 가독성이 높아져 유지보수가 용이해진다.</p></li>
<li><p>상태 변화가 없거나 최소화되어 부작용이 줄어드므로, 코드의 신뢰성과 예측 가능성이 향상된다.</p></li>
</ol>
<p>이러한 특성은 복잡한 소프트웨어 시스템을 더 쉽게 이해하고 관리할 수 있는 방법으로 자리 잡혀 있다.</p>
<p>클린 코드 저자 Rober C.Martin의 함수형 프로그래밍에 대한 의견</p>
<p>깨끗하게 작성하는 방법이란, 할당하는(대입연산자) 문장이 없는 프로그램이다.</p>
<p>코드만 보더라도 이것이 어떤 기능을 하는지 알 수 있도록 만든다.</p>
<p>함수형 프로그래밍은 대입문을 사용하지 않는 프로그래밍 방식이며, 작은 문제를 해결하기 위한 함수를 작성하는 데 중점을 둔다.</p>
<p>예를 들어, 함수는 다음과 같은 두 개의 인자를 가질 수 있다.</p>
<p>첫 번째 인자: 몇까지 반복(iteration)을 돌 것인지 받는 매개변수 두 번째 인자: 전달받은 값을 출력하는 함수</p>
<p>이러한 방식은 함수형 프로그래밍이 무엇을(What) 중시하는지를 보여준다. 즉, 함수형 프로그래밍에서는 ’출력을 하는 함수’를 파라미터로 넘길 수 있는 유연함을 가지고 있다.</p>
<p>이것은 함수형 프로그래밍의 기본 원리 중 하나인 함수를</p>
<p>1급 시민(First-Class Citizen) 또는 1급 객체(First-Class Object)로 관리하는 특징 때문이다.</p>
<p>1급 시민이라는 개념은 다음과 같은 특성을 의미한다.</p>
<ol type="1">
<li><p>함수를 변수에 할당할 수 있다.</p></li>
<li><p>함수를 다른 함수의 인자로 전달할 수 있다.</p></li>
<li><p>함수를 다른 함수의 결과로 반환할 수 있다.</p></li>
</ol>
<p>이러한 특성 덕분에 함수형 프로그래밍에서는 코드의 재사용성과 모듈화가 용이하며, 프로그램의 가독성을 높이는 데 기여한다.</p>
<p>Java에서는 멀티스레딩이 기본적으로 지원되며, 여러 스레드를 활용해 동시에 여러 작업을 처리할 수 있다.</p>
<p>스레드는 하나의 작업 단위로, 자바의 Thread 클래스나 Runnable 인터페이스를 통해 쉽게 만들 수 있다.</p>
<p>스레드 안전성이 보장되는 함수는 여러 스레드가 동시에 접근하더라도 데이터 충돌 없이 동작할 수 있어 동기화(synchronization) 없이도 병렬 처리가 가능합니다.</p>
<p>이로 인해 오버헤드가 줄어들고, 성능이 향상되는 장점이 있다. 이렇게 스레드 안전성이 보장된 코드는 동기화 없이도 각 스레드가 독립적으로 작업을 수행할 수 있어 효율적입니다.</p>
<p>Java에서 synchronized 키워드를 사용해 공통 데이터를 다룰 때 동기화를 적용하여, 여러 스레드가 동시에 접근하지 못하도록 제한할 수 있다.</p>
<p>특히, 동영상 재생처럼 화면, 소리, 자막 등 여러 요소가 동시에 다루어지는 환경에서는 스레드가 공통 데이터를 정확히 처리하지 않으면 원치 않는 값이 기록될 수 있고, 시각적이나 청각적인 어긋남이 발생할 수 있습니다.</p>
<p>synchronized 한 스레드가 잠금(lock)을 걸어 해당 코드 블록을 독점적으로 실행하고, 작업이 완료되면 다른 스레드가 접근할 수 있는 권한을 부여하게 된다.</p>
<ol type="1">
<li><p>데이터 일관성이 유지된다.</p></li>
<li><p>동기화된 처리가 보장되어 여러 스레드가 공통 데이터에 접근할 때 문제가 발생하지 않는다.</p></li>
<li><p>경쟁 상태(race condition)와 같은 문제를 예방할 수 있다.</p></li>
</ol>
<p>하지만, 오버헤드가 발생할 수 있어 성능 저하가 있을 수 있으므로, 필요한 곳에만 신중하게 사용하는 것이 좋습니다.</p>
<p>1급 객체 (First-Class Object) 프로그래밍 언어에서 특정 요소를 변수나 데이터 구조에 담을 수 있고, 함수의 파라미터로 전달하거나 반환값으로 사용할 수 있는 객체</p>
<p>JavaScript와 같은 언어에서 함수는 1급 객체로 취급되며, 이로 인해 함수 자체를 객체처럼 다룰 수 있다.</p>
<p>특징 1. 함수를 변수에 저장하거나 배열에 넣어 사용할 수 있다.</p>
<ol start="2" type="1">
<li><p>함수는 다른 함수의 파라미터로 전달될 수 있다.</p></li>
<li><p>함수는 다른 함수의 반환값으로 사용할 수 있다.</p></li>
<li><p>함수는 할당된 이름에 관계없이 고유하게 식별될 수 있다.</p></li>
</ol>
<p>이러한 특성 덕분에 고차 함수를 쉽게 만들 수 있다.</p>
<p>What It Means to Be Functional</p>
<p>함수는 변수로 사용될 수 있다.</p>
<p>var log = function(message) { console.log(message); }; log(“In JavaScript, functions are variables”);</p>
<p>화살표 함수(arrow function)</p>
<p>const log = message =&gt; { console.log(message); };</p>
<p>함수가 객체의 속성으로 추가될 수 있다.</p>
<p>const obj = { message: “They can be added to objects like variables”, log(message) { console.log(message); } }; obj.log(obj.message);</p>
<p>함수는 배열의 요소로도 추가될 수 있다.</p>
<p>const messages = [ “They can be inserted into arrays”, message =&gt; console.log(message), “like variables”, message =&gt; console.log(message)]; messages<a href="messages[0]">1</a>; messages<a href="messages[2]">3</a>;</p>
<p>함수가 다른 함수에 인수로 전달될 수 있다.</p>
<p>const insideFn = logger =&gt; { logger(“They can be sent to other functions as arguments”); }; insideFn(message =&gt; console.log(message));</p>
<p>함수를 반환하는 함수를 작성하고, 반환된 함수를 호출하는 방식.</p>
<p>const createScream = function(logger) { return function(message) { logger(message.toUpperCase() + “!!!”); }; }; const scream = createScream(message =&gt; console.log(message)); scream(“functions can be returned from other functions”); scream(“createScream returns a function”); scream(“scream invokes that returned function”);</p>
<p>화살표 함수를 사용하여 함수를 반환하는 함수를 간결하게 정의하였다.</p>
<p>const createScream = logger =&gt; message =&gt; { logger(message.toUpperCase() + “!!!”); };</p>
<p>Imperative Versus Declarative</p>
<p>명령형(Imperative) 프로그래밍과 선언형(Declarative) 프로그래밍의 차이를 이해하기 위해, 두 가지 접근 방식을 비교해보겠습니다. 선언형 프로그래밍은 “무엇을 해야 할지”를 설명하는 방식이고, 명령형 프로그래밍은 “어떻게 해야 할지”를 명시적으로 정의하는 방식입니다.</p>
<p>먼저, 명령형 프로그래밍 접근을 살펴봅시다. 여기서는 주어진 문제를 해결하기 위해 순차적인 단계를 명시적으로 정의합니다. 예를 들어, 문자열에서 공백을 하이픈(-)으로 바꾸는 작업을 수행할 때, 명령형 접근은 문자열을 한 문자씩 확인하고, 공백이 있을 경우 하이픈으로 바꾸는 방식입니다. 이 과정은 매우 구체적이고, 각 단계를 명확하게 기술해야 합니다.</p>
<p>공백을 하이픈으로 변환하여 URL 친화적인 문자열을 만드는 코드.</p>
<p>const string = “Restaurants in Hanalei”; let urlFriendly = ““;</p>
<p>for (var i = 0; i &lt; string.length; i++) { if (string[i] === ” “) { urlFriendly +=”-“; } else { urlFriendly += string[i]; } }</p>
<p>console.log(urlFriendly);</p>
<p>자바스크립트의 String 객체에 내장된 replace 메서드를 사용하여 문자열 내의 공백을 하이픈(-)으로 변환하는 방법.</p>
<p>const string = “Restaurants in Hanalei”; const urlFriendly = string.replace(/ /g, “-”); console.log(urlFriendly);</p>
<p>함수형 프로그래밍 패턴을 사용하여 여러 함수를 조합하고, 비동기적으로 데이터를 로드하여 가공하는 과정.</p>
<p>const loadAndMapMembers = compose( combineWith(sessionStorage, “members”), save(sessionStorage, “members”), scopeMembers(window), logMemberInfoToConsole, logFieldsToConsole(“name.first”), countMembersBy(“location.state”), prepStatesForMapping, save(sessionStorage, “map”), renderUSMap ); getFakeMembers(100).then(loadAndMapMembers);</p>
<p>HTML 문서에 새로운 요소를 동적으로 추가하는 예시.</p>
<p>const target = document.getElementById(“target”); const wrapper = document.createElement(“div”); const headline = document.createElement(“h1”);</p>
<p>wrapper.id = “welcome”; headline.innerText = “Hello World”;</p>
<p>wrapper.appendChild(headline); target.appendChild(wrapper);</p>
<p>React를 사용하여 Hello World 메시지를 화면에 렌더링하는 예제</p>
const { render } = ReactDOM; const Welcome = () =&gt; (
<div id="welcome">
<pre><code>    &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/div&gt;</code></pre>
<p>); render(<welcome>, document.getElementById(“target”));</welcome></p>
<p>Functional Concepts</p>
<p>함수형 프로그래밍의 핵심 개념에는 불변성(immutability), 순수성(purity), 데이터 변환(data transformation), 고차 함수(higher-order functions), 재귀(recursion)</p>
<p>불변성(Immutability) 불변성은 데이터를 변경할 수 없는 특성을 의미합니다.</p>
<p>변경하지 않음: 함수형 프로그래밍에서는 데이터가 절대 변경되지 않습니다. 한 번 생성된 데이터는 절대 바뀌지 않으며, 변화를 주고 싶을 때는 새로운 데이터 복사본을 생성하는 방식으로 작업을 수행합니다. 이점: 불변성을 유지하면 프로그램이 예측 가능하고 오류가 발생할 가능성이 줄어듭니다. 왜냐하면, 데이터가 어디서든 변하지 않기 때문에 한 부분에서 다른 부분으로 데이터가 변경되면서 발생하는 사이드 이펙트를 방지할 수 있기 때문입니다.</p>
<p>JavaScript에서 객체를 생성한 예시. color_lawn라는 객체는 잔디의 색상을 나타낸다.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>function rateColor(color, rating) { color.rating = rating; return color; } console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>이 코드에는 불변성이 지켜지지 않고 있습니다. rateColor 함수가 color_lawn 객체를 직접 수정하면서 원래 객체가 변경되는 <strong>부작용(side effect)</strong>이 발생합니다.</p>
<p>불변성을 지키기 위해 원본 데이터를 수정하지 않고 복사본을 생성하여 수정하는 방법.</p>
<p>기존 rateColor 함수는 원본 객체를 직접 수정했지만, 이를 수정하여 원본 객체를 건드리지 않고 새로운 객체를 반환하도록 개선한 방법을 보여준다.</p>
<p>rateColor라는 함수를 사용하여 객체의 속성 값을 변경하는 예제.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>function rateColor(color, rating) { return { …color, rating: rating }; }</p>
<p>console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>이 함수는 기존의 color 객체를 직접 수정하지 않고, …color를 사용하여 원본 객체의 복사본을 생성한 다음 rating 속성만 새로운 값으로 설정합니다.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>const rateColor = (color, rating) =&gt; ({ …color, rating });</p>
<p>console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>다음과 같은 배열이 있다고 가정하자. addColor 함수는 배열에 항목을 추가하는 예시로, Array.push 메서드를 사용한다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }];</p>
<p>const addColor = function(title, colors) { colors.push({ title: title }); return colors; }; console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>이 함수는 colors.push()를 통해 원본 배열인 colors를 직접 수정한다. list 배열이 원본 데이터라면 addColor 함수 호출 후 list의 길이가 변경된다.</p>
<p>위 코드는 불변성을 지키지 않으므로, 원본 배열이 변경됩니다.</p>
<p>Array.concat 메서드는 배열을 합치는 역할을 하지만, 원본 배열을 수정하지 않고 새로운 배열을 반환하므로 불변성을 유지할 수 있다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }]; const addColor = (title, array) =&gt; array.concat({ title });</p>
<p>console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>array.concat({ title })는 array 배열의 복사본을 만들고 { title } 객체를 그 뒤에 추가합니다. 결과적으로 원본 배열은 그대로 유지되고, 새로운 배열이 반환됩니다.</p>
<p>이제 list 배열은 수정되지 않고, 새로운 배열만이 길이가 4인 상태로 반환됩니다.</p>
<p>Array.concat 대신 스프레드 연산자(…)를 사용해서도 동일한 결과를 얻을 수 있습니다. 스프레드 연산자를 사용하면 코드가 더욱 간결해집니다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }]; const addColor = (title, list) =&gt; […list, { title }];</p>
<p>console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>Pure Functions</p>
<p>순수 함수 부수 효과들을 제거한 함수.</p>
<p>Memory OR I/O의 관점에서 Side Effect가 없는 함수로, 함수의 실행이 외부에 영향을 끼치지 않는다.</p>
<p>장점 함수 자체가 독립적이며, Side-Effect가 없으므로, 스레드(Thread)에 안정성을 보장받을 수 있다.</p>
<p>스레드 안정성을 확보하면 멀티스레드 환경에서 동시 실행 시 발생할 수 있는 데이터 경쟁(race condition), 교착 상태(deadlock) 등의 문제가 방지된다.</p>
<ol type="1">
<li>여러 스레드가 동일한 데이터를 동시에 수정하려 할 때 발생할 수 있는 예기치 않은 오류가 방지된다.</li>
</ol>
<p>스레드 안전성이 있으면 각 스레드가 독립적으로 동작해 코드의 신뢰성이 높아진다.</p>
<ol start="2" type="1">
<li><p>스레드 안전한 코드에서는 병렬 처리가 가능해 프로그램 성능이 개선된다. 각 스레드가 서로 간섭 없이 데이터를 처리할 수 있어 작업을 더 빠르게 완료할 수 있다.</p></li>
<li><p>스레드 관련 오류는 발생 시 찾기 어려운 경우가 많지만, 스레드 안전성을 확보하면 이런 오류 가능성이 줄어들어 디버깅과 유지 보수가 더 쉬워진다.</p></li>
<li><p>스레드 안전한 코드는 여러 프로세서나 코어에서 동시 실행이 가능해 고성능 환경에서도 효과적으로 확장할 수 있다.</p></li>
</ol>
<p>이 함수는 인자를 받지 않으며, 내부적으로 외부 변수 frederick의 속성을 변경한다. selfEducate 함수 호출 후에는 frederick 객체의 canRead와 canWrite 속성이 true로 변경된다.</p>
<p>이 함수는 외부 상태를 변경했으므로, 부작용이 발생하며 순수 함수가 아니다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>function selfEducate() { frederick.canRead = true; frederick.canWrite = true; return frederick; }</p>
<p>selfEducate(); console.log(frederick);</p>
<p>selfEducate 함수가 person이라는 인자를 받아 그 인자 객체의 속성을 변경했다.</p>
<p>selfEducate가 받은 인자를 변경하므로, 그 인자로 무엇이 전달되느냐에 따라 함수의 동작이 달라질 수 있다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>const selfEducate = person =&gt; { person.canRead = true; person.canWrite = true; return person; };</p>
<p>console.log(selfEducate(frederick)); console.log(frederick);</p>
<p>selfEducate 함수는 이제 person이라는 객체를 인자로 받아, 그 객체의 복사본에 canRead와 canWrite 속성만 변경하여 새로운 객체를 반환한다.</p>
<p>이 함수는 외부의 frederick 객체를 수정하지 않고, 새로운 객체를 생성하여 반환하므로, 부작용이 없다. 같은 person 객체가 주어지면 항상 동일한 결과를 반환하므로, 이 함수는 순수 함수가 됩니다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>const selfEducate = person =&gt; ({ …person, canRead: true, canWrite: true });</p>
<p>console.log(selfEducate(frederick)); console.log(frederick);</p>
<p>selfEducate 함수는 frederick 객체를 변경하지 않고 새로운 객체를 반환했으므로, frederick은 여전히 변경되지 않은 상태이다.</p>
<p>Header 함수는 document.createElement와 document.body.appendChild를 사용하여 DOM을 변경한다.</p>
<p>function Header(text) { let h1 = document.createElement(“h1”); h1.innerText = text; document.body.appendChild(h1); } Header(“Header() caused side effects”); 이렇게 DOM을 변경하는 행위는 부수효과(side effect)를 일으킨다. 부수효과가 발생하면 이 함수는 순수 함수가 아니다.</p>
<p>즉, 함수 실행 후 상태가 변경되거나 외부 시스템에 영향을 미친다.</p>
<p>함수형 프로그램의 특징 부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.</p>
<ol type="1">
<li>부수 효과 (Side Effect)</li>
</ol>
<p>다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.</p>
<ol type="1">
<li><p>변수의 값이 변경된다.</p></li>
<li><p>자료 구조를 제자리에서 수정한다.</p></li>
</ol>
<p>불변성 (배열, 리스트, 튜플 ⇨ 여러 개의 데이터를 저장)</p>
<p>데이터 처리에서 원본을 그대로 두고, 사본을 만들어서 수정해야 한다는 점은 매우 중요합니다.</p>
<p>특히 실시간 데이터와 같은 유일한 데이터를 다룰 때 원본을 손상하면 해당 시간대의 의미가 상실될 수 있다.</p>
<p>따라서 정보화를 위해 가공할 때는 반드시 원본을 건들지 않고 사본으로 작업하는 것이 바람직하다.</p>
<ol start="3" type="1">
<li><p>객체의 필드값을 설정한다. (즉, 할당문 금지)</p></li>
<li><p>예외나 오류가 발생하며 실행이 중단된다.</p></li>
<li><p>콘솔 또는 파일 I/O가 발생한다.</p></li>
</ol>
<p>React에서는 UI를 표현할 때 순수 함수를 사용한다. 순수 함수는 부수효과를 일으키지 않고 입력값에 따라 결과값을 반환한다.</p>
<p>React 컴포넌트는 내부에서 DOM을 직접 변경하지 않는다. 대신 JSX나 React의 상태(state) 등을 활용하여 UI를 설명한다.</p>
<p>이 예제에서는 Header 컴포넌트가 순수 함수로 작성되었다.</p>
const Header = props =&gt;
<h1>
{props.title}
</h1>
<p>;</p>
<p>Data Transformations</p>
<p>JavaScript는 데이터를 변형하는 데 필요한 도구를 이미 내장하고 있으며, 그 중 두 가지 중요한 함수는 Array.map과 Array.reduce입니다.</p>
<p>이 함수들을 잘 활용하면 데이터 변환 작업을 효율적으로 처리할 수 있다.</p>
<p>다음은 학교 목록을 가진 배열이다. 이 배열을 쉼표로 구분된 문자열로 변환하려면 Array.join 함수를 사용할 수 있다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; console.log(schools.join(“,”));</p>
<p>불변성을 유지하면서 데이터를 필터링할 수 있다. 학교 이름이 “W”로 시작하는 학교만 선택하는 예제를 보겠다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const wSchools = schools.filter(school =&gt; school[0] === “W”); console.log(wSchools);</p>
<p>불변성을 지키면서 원본 배열을 수정하지 않으며,</p>
<p>school !== cut 조건을 통해 지정한 학교 이름을 제외한 배열을 생성한다. 이어서 join 메서드를 사용하여 새로운 배열을 문자열로 결합하였다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const cutSchool = (cut, list) =&gt; list.filter(school =&gt; school !== cut); console.log(cutSchool(“Washington &amp; Liberty”, schools).join(“,”));</p>
<p>Array.map 메서드는 배열의 각 항목에 대해 변환을 적용하여 새로운 배열을 만든다.</p>
<p>이 메서드는 배열의 각 항목을 변경한 새로운 배열을 생성하며, 원본 배열을 변형하지 않는다. 위의 예제에서는 각 학교 이름에 “High School”을 덧붙여 새로운 배열을 생성한다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const highSchools = schools.map(school =&gt; <code>${school} High School</code>); console.log(highSchools.join(“”));</p>
<p>여기서, schools 배열은 문자열 배열로 되어 있다.</p>
<p>map을 사용하여 각 학교 이름을 name 속성으로 갖는 객체로 변환한 새로운 배열을 생성했다.</p>
<p>결과는 각 학교 이름을 객체로 감싼 배열이 된다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const highSchools = schools.map(school =&gt; ({ name: school })); console.log(highSchools);</p>
<p>배열 내의 특정 객체를 변경할 때도 map을 사용할 수 있다.</p>
<p>예를 들어, “Stratford”라는 학교 이름을 “HB Woodlawn”으로 변경하고 싶을 때, map을 사용하여 원본 배열을 변경하지 않고 새로운 배열을 만들 수 있다.</p>
<p>const editName = (oldName, newName, list) =&gt; { return list.map(school =&gt; school.name === oldName ? { name: newName } : school ); };</p>
<p>let schools = [ { name: “Yorktown” }, { name: “Stratford” }, { name: “Washington &amp; Liberty” }, { name: “Wakefield” } ];</p>
<p>let updatedSchools = editName(“Stratford”, “HB Woodlawn”, schools); console.log(updatedSchools[1]); console.log(schools[1]);</p>
<p>{ …item, name } 구문은 의도한 대로 name 속성만 업데이트하려고 하는데, 이 코드에서는 새로 정의된 name 속성이 이전 name 값을 덮어쓰게 된다.</p>
<p>실제로 name을 수정하려면 name을 덮어쓰는 게 아니라, name: newValue 형태로 작성해야 한다.</p>
<p>const editName = (oldName, name, arr) =&gt; arr.map(item =&gt; { if (item.name === oldName) { return { …item, name }; } else { return item; } });</p>
<p>이 코드는 editName이라는 함수를 한 줄로 작성한 버전이다.</p>
<p>이 함수의 역할은 특정 배열에서 name 속성이 oldName과 일치하는 객체의 name을 변경한 새로운 배열을 반환하는 것이다.</p>
<p>이 코드에서는 삼항 연산자를 사용하여 조건에 따라 배열을 변환하고 있다.</p>
<p>const editName = (oldName, name, arr) =&gt; arr.map(item =&gt; (item.name === oldName ? { …item, name } : item));</p>
<p>이 코드는 schools라는 객체를 schoolArray라는 배열로 변환하는 예제. 객체의 키와 값을 활용하여 새로운 배열을 만들고, 각 배열 항목은 객체 형태로 만들어진다.</p>
<p>const schools = { Yorktown: 10, “Washington &amp; Liberty”: 2, Wakefield: 5 };</p>
<p>const schoolArray = Object.keys(schools).map(key =&gt; ({ name: key, wins: schools[key] }));</p>
<p>console.log(schoolArray);</p>
<p>이 예제에서는 reduce 함수를 사용하여 배열을 단일 값으로 변환하는 방법을 설명한다. reduce 함수는 배열을 순회하면서 각 요소를 누적하여 최종적인 값을 도출할 수 있는 매우 유용한 도구이다.</p>
<p>const ages = [21, 18, 42, 40, 64, 63, 34];</p>
<p>const maxAge = ages.reduce((max, age) =&gt; { console.log(<code>${age} &gt; ${max} = ${age &gt; max}</code>); if (age &gt; max) { return age; } else { return max; } }, 0);</p>
<p>console.log(“maxAge”, maxAge);</p>
<p>이 코드는 reduce 함수를 사용하여 배열에서 가장 큰 값을 계산하는 간결한 방법.</p>
<p>shorthand if/else 문법을 사용하여 조건문을 간결하게 작성하고, console.log 없이 바로 최대값을 계산한다.</p>
<p>const ages = [-5, -18, -42, -40, -64, -63, -34]; const max = ages.reduce((max, value) =&gt; (value &gt; max ? value : max)); console.log(max);</p>
<p>reduce 메서드를 사용하여 배열을 객체로 변환하는 예제.</p>
<p>이 예제에서는 colors 배열을 key-value 쌍을 가진 객체로 바꾸고 있다. 각 색상 객체의 id 값을 객체의 key로 사용하고, title과 rating을 포함하는 객체를 그에 대응하는 value로 사용한다.</p>
<p>const colors = [ { id: “xekare”, title: “rad red”, rating: 3 }, { id: “jbwsof”, title: “big blue”, rating: 2 }, { id: “prigbj”, title: “grizzly grey”, rating: 5 }, { id: “ryhbhsl”, title: “banana”, rating: 1 }];</p>
<p>const hashColors = colors.reduce((hash, { id, title, rating }) =&gt; { hash[id] = { title, rating }; return hash; }, {});</p>
<p>console.log(hashColors);</p>
<p>reduce 메서드를 사용하여 배열을 다른 형태로 변환하는 방법을 보여준다. 특히, 배열에서 중복되는 값을 제거하고 고유한 값만 남기는 방법에 대해 설명하고 있다.</p>
<p>const colors = [“red”, “red”, “green”, “blue”, “green”];</p>
<p>const uniqueColors = colors.reduce( (unique, color) =&gt; unique.indexOf(color) !== -1 ? unique : […unique, color], [] );</p>
<p>console.log(uniqueColors);</p>
<p>Higher-Order Functions</p>
<p>고차 함수 다른 함수를 인자로 받거나 함수의 결과로 반환하는 함수.</p>
<p>JavaScript의 Array.prototype.map()이나 filter() 같은 메서드는 모두 고차 함수이다.</p>
<p>리액트에서의 활용 함수형 컴포넌트와 useEffect 또는 useCallback 등의</p>
<p>훅(hook)에서 함수를 인자로 전달하거나, 특정 이벤트 발생 시 전달된 함수를 실행하는 방식으로 자주 사용된다.</p>
<p>invokeIf는 조건에 따라 다른 함수를 호출하는 고차 함수입니다.</p>
<p>const invokeIf = (condition, fnTrue, fnFalse) =&gt; condition ? fnTrue() : fnFalse();</p>
<p>const showWelcome = () =&gt; console.log(“Welcome!!!”); const showUnauthorized = () =&gt; console.log(“Unauthorized!!!”);</p>
<p>invokeIf(true, showWelcome, showUnauthorized); invokeIf(false, showWelcome, showUnauthorized);</p>
<p>이 코드는 고차 함수와 클로저를 사용한 예제입니다.</p>
<p>const getFakeMembers = num =&gt; { return new Promise((resolve, reject) =&gt; { const members = Array(num).fill(“Member”); resolve(members); }); };</p>
<p>const userLogs = userName =&gt; message =&gt; console.log(<code>${userName} -&gt; ${message}</code>);</p>
<p>const log = userLogs(“grandpa23”);</p>
<p>log(“attempted to load 20 fake members”);</p>
<p>getFakeMembers(20).then( members =&gt; log(<code>successfully loaded ${members.length} members</code>), error =&gt; log(“encountered an error loading members”) );</p>
<p>Recursion</p>
<p>재귀(recursion) 를 사용하여 숫자를 10부터 0까지 카운트다운하는 함수.</p>
<p>const countdown = (value, fn) =&gt; { fn(value); return value &gt; 0 ? countdown(value - 1, fn) : value; }; countdown(10, value =&gt; console.log(value));</p>
<p>재귀 함수 countdown을 사용하여 숫자를 카운트다운하지만, 지연 시간(delay) 을 두고 실행된다. 이전에 설명한 카운트다운과 비슷하지만, setTimeout을 사용해 호출 간격을 조절한다.</p>
<p>즉, 지정한 시간이 지난 후에야 다음 숫자가 출력된다.</p>
<p>const countdown = (value, fn, delay = 1000) =&gt; { fn(value); return value &gt; 0 ? setTimeout(() =&gt; countdown(value - 1, fn, delay), delay) : value; };</p>
<p>const log = value =&gt; console.log(value); countdown(10, log);</p>
<p>deepPick이라는 함수를 사용하여, 객체 내의 중첩된 속성을 접근하고 가져오는 기능을 구현하고 있다. 이 함수는 객체에서 깊숙이 중첩된 경로(type, data.info.fullname.first 등)를 문자열 형태로 받아 그 값을 반환한다.</p>
<p>const deepPick = (path, obj) =&gt; { return path.split(‘.’).reduce((acc, key) =&gt; acc &amp;&amp; acc[key], obj); };</p>
<p>const dan = { type: “person”, data: { gender: “male”, info: { id: 22, fullname: { first: “Dan”, last: “Deacon” } } } };</p>
<p>console.log(deepPick(“type”, dan)); console.log(deepPick(“data.info.fullname.first”, dan)); console.log(deepPick(“data.info.id”, dan)); console.log(deepPick(“data.gender”, dan)); console.log(deepPick(“data.info.fullname.last”, dan));</p>
<p>deepPick 함수를 재귀적으로 구현하여 객체의 중첩된 속성에 접근하는 방법.</p>
<p>주어진 경로(fields)를 문자열 형태로 입력받아, ‘.’ 으로 구분된 경로를 따라가면서 해당하는 속성 값을 가져온다.</p>
<p>const dan = { type: “person”, data: { gender: “male”, info: { id: 22, fullname: { first: “Dan”, last: “Deacon” } } } };</p>
<p>const deepPick = (fields, object = {}) =&gt; { const [first, …remaining] = fields.split(“.”);</p>
<pre><code>if (!object || !(first in object)) {
    return undefined;
}

return remaining.length
    ? deepPick(remaining.join("."), object[first])
    : object[first];</code></pre>
<p>};</p>
<p>console.log(deepPick(“data.info.fullname.first”, dan));</p>
<p>“data”에 접근 → “info”에 접근 → “fullname”에 접근 → “first”에 접근 → 최종적으로 “Dan”이 반환된다. 따라서 deepPick 함수는 재귀를 사용하여 객체의 중첩된 속성에 안전하게 접근하도록 구현된 함수입니다.</p>
<p>Composition</p>
<p>함수형 프로그래밍에서 작은 순수 함수들을 조합하여 더 큰 기능을 수행하는 방식을 합성이라 한다.</p>
<p>함수형 프로그래밍은 각 함수가 특정 작업에 집중하도록 설계하는데, 이러한 작은 함수들을 서로 연결하여 더 복잡한 로직을 만들 수 있다.</p>
<p>JavaScript에서 체이닝(Chaining)은 함수 합성의 한 예로, 메서드를 연속으로 호출하여 이전 함수의 반환 값을 다음 함수의 입력 값으로 사용하는 방식이다.</p>
<p>문자열의 replace 메서드는 주어진 문자열을 특정 패턴으로 교체하고, 그 결과 문자열을 반환한다. 이 반환 값도 여전히 문자열이므로, replace 메서드를 다시 호출하여 연속적으로 변환할 수 있다.</p>
<p>const template = “hh:mm:ss tt”; const clockTime = template .replace(“hh”, “03”) .replace(“mm”, “33”) .replace(“ss”, “33”) .replace(“tt”, “PM”); console.log(clockTime);</p>
<p>이 코드는 함수 합성(Composition)의 예. 두 개의 함수 civilianHours와 appendAMPM을 합성하여 새로운 함수를 만들고 있다.</p>
<p>const civilianHours = date =&gt; date % 12;<br>
const appendAMPM = time =&gt; <code>${time} AM</code>;</p>
<p>const both = date =&gt; appendAMPM(civilianHours(date));</p>
<p>console.log(both(13));</p>
<p>함수가 많아지면 이런 방식은 확장성과 유지보수성에서 어려움이 있다. 예를 들어, 함수가 20개라면 코드가 매우 복잡해지므로, 가독성과 관리가 힘들어진다.</p>
<p>보다 깔끔하고 확장성 있는 방법은 고차 함수(Higher-order function)인 compose를 사용하는 것이다. compose 함수는 여러 개의 함수를 결합하여 하나의 함수로 만들어 주는 함수이다.</p>
<p>이 방법은 더 많은 함수가 필요할 때 쉽게 추가할 수 있고, 함수의 순서도 변경하기 쉽습니다.</p>
<p>compose를 사용하여 두 개의 함수를 결합하고, 그 결과를 새로운 함수로 만들어 사용하고 있다.</p>
<p>compose는 일반적으로 함수형 프로그래밍에서 여러 개의 함수를 합성하여 새로운 함수를 생성하는 방법이다.</p>
<p>const both = compose( civilianHours, appendAMPM ); both(new Date());</p>
<p>이 함수는 reduce를 사용하여 함수들을 하나씩 실행하면서 그 결과를 이어가게 만듭니다.</p>
<p>const compose = (…fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg);</p>
<p>Putting It All Together</p>
<p>이 코드는 JavaScript로 간단한 시계를 만들기 위한 명령형(Imperative) 해결 방법을 설명하고 있다.</p>
<p>이 시계는 시간, 분, 초를 표시하고, AM/PM 형식으로 표시된 시간을 군용 시간(civilian time) 형식으로 변환하여 출력한다.</p>
<p>각 시간 단위는 항상 두 자릿수로 표시되며, 1 또는 2와 같은 한 자릿수 값에는 선행 0을 추가해야 한다.</p>
<p>또한, 이 시계는 매초마다 업데이트되어 화면에 새로운 시간이 표시된다.</p>
<p>setInterval(logClockTime, 1000);</p>
<p>function logClockTime() { let time = getClockTime(); console.clear(); console.log(time); }</p>
<p>function getClockTime() { let date = new Date(); let time = { hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), ampm: “AM” };</p>
<p>if (time.hours == 12) { time.ampm = “PM”; } else if (time.hours &gt; 12) { time.ampm = “PM”; time.hours -= 12; }</p>
<p>if (time.hours &lt; 10) { time.hours = “0” + time.hours; }</p>
<p>if (time.minutes &lt; 10) { time.minutes = “0” + time.minutes; }</p>
<p>if (time.seconds &lt; 10) { time.seconds = “0” + time.seconds; }</p>
<p>return time.hours + “:” + time.minutes + “:” + time.seconds + ” ” + time.ampm; }</p>
<p>시계가 작동됨을 확인.</p>
<p>이 해결책은 잘 동작하고, 주석 덕분에 무엇이 일어나고 있는지 이해할 수 있습니다. 하지만 각 함수가 크고 복잡하며, 각 함수가 여러 일을 하므로 이해하기 어렵고, 주석을 많이 필요로 하며 유지보수가 힘들다.</p>
<p>이제 더 확장 가능하고 유지보수하기 쉬운 함수형 접근 방식을 사용하여 애플리케이션을 개선해보겠습니다.</p>
<p>목표 우리는 애플리케이션의 논리를 더 작은 부분인 함수로 나누고자 합니다. 각 함수는 하나의 작업에만 집중하며, 이를 조합해서 큰 함수로 만들어 시계를 구현할 수 있습니다.</p>
<p>함수형 접근 방식 각 기능을 작은 함수로 나누고, 각 함수는 하나의 일만 하도록 합니다. 이렇게 하면 각 함수가 명확하고, 테스트하기 쉬우며, 재사용 가능하게 됩니다.</p>
<p>함수형 프로그래밍에서는 값보다는 함수를 사용하는 것이 중요합니다. 값이 필요할 때마다 함수를 호출하여 값을 얻습니다.</p>
<p>const compose = (…fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg);</p>
<p>const oneSecond = () =&gt; 1000; const getCurrentTime = () =&gt; new Date(); const clear = () =&gt; console.clear(); const log = message =&gt; console.log(message);</p>
<p>이제 시계를 구현하기 위해 필요한 데이터 변환 함수를 작성해 보겠습니다. 이 세 가지 함수는 Date 객체를 시계를 위한 객체로 변환하는 데 사용됩니다.</p>
<p>변환 함수들 serializeClockTime: Date 객체를 받아 시계 시간을 담고 있는 객체를 반환합니다. 반환되는 객체는 시, 분, 초를 포함합니다. civilianHours: 시계 시간 객체를 받아 시간(hour)을 12시간제로 변환합니다. 예를 들어, 1300은 1:00으로 변환됩니다. appendAMPM: 시계 시간 객체를 받아 오전(AM) 또는 오후(PM)를 붙여주는 함수입니다. const serializeClockTime = date =&gt; ({ hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds() });</p>
<p>const civilianHours = clockTime =&gt; ({ …clockTime, hours: clockTime.hours &gt; 12 ? clockTime.hours - 12 : clockTime.hours });</p>
<p>const appendAMPM = clockTime =&gt; ({ …clockTime, ampm: clockTime.hours &gt;= 12 ? “PM” : “AM” });</p>
<p>이제 데이터를 변환하는 데 사용할 고차 함수들을 작성하겠습니다. 이 함수들은 데이터를 변경하지 않고 불변성을 유지하면서 시간을 표시하거나 포맷을 변환하는 데 사용됩니다.</p>
<p>고차 함수들 display: target 함수(예: console.log)를 받아서, 시간을 그 함수로 전달하는 함수를 반환합니다. formatClock: 주어진 템플릿 문자열을 사용하여, hours, minutes, seconds, ampm 등의 값으로 시간을 포맷합니다. prependZero: 시계 시간 객체의 특정 key 값을 받아서, 그 값이 10 미만이면 앞에 0을 추가하여 반환합니다. const display = target =&gt; time =&gt; target(time);</p>
<p>const formatClock = format =&gt; time =&gt; format .replace(“hh”, time.hours) .replace(“mm”, time.minutes) .replace(“ss”, time.seconds) .replace(“tt”, time.ampm);</p>
<p>const prependZero = key =&gt; clockTime =&gt; ({ …clockTime, [key]: clockTime[key] &lt; 10 ? “0” + clockTime[key] : clockTime[key] });</p>
<p>이번에는 우리가 만든 모든 함수를 조합하여 틱킹 시계를 만드는 방법을 설명합니다. 이 시계는 1초마다 시간을 업데이트하며, 컴포지션을 사용하여 여러 함수를 결합합니다. 여기서는 compose 함수를 이용해 각 기능을 조합하고, 각 함수들이 하나의 흐름으로 이어지게 만듭니다.</p>
<p>주요 함수들 convertToCivilianTime: clockTime을 인자로 받아서, 시계를 민간 시간(AM/PM 형식)으로 변환하는 함수입니다. civilianHours와 appendAMPM을 차례로 적용하여 시간 객체를 변환합니다. doubleDigits: 민간 시간을 받아서, hours, minutes, seconds 값에 대해 두 자리를 보장하도록 만듭니다. 10보다 작은 값에는 앞에 0을 추가하는 방식입니다. prependZero 함수를 사용하여 이 작업을 수행합니다. startTicking: setInterval을 사용하여 1초마다 반복 실행되는 콜백을 설정합니다. 콜백 함수는 시계가 계속해서 시간을 가져오고, 변환하고, 포맷을 변경한 후 출력하는 역할을 합니다. 이 콜백은 앞서 정의한 함수들을 컴포지션을 통해 결합하여 하나의 흐름으로 만듭니다. const convertToCivilianTime = clockTime =&gt; compose( appendAMPM, civilianHours )(clockTime);</p>
<p>const doubleDigits = civilianTime =&gt; compose( prependZero(“hours”), prependZero(“minutes”), prependZero(“seconds”) )(civilianTime);</p>
<p>const startTicking = () =&gt; setInterval( compose( clear, getCurrentTime, serializeClockTime, convertToCivilianTime, doubleDigits, formatClock(“hh:mm:ss tt”), display(log) ), oneSecond() );</p>
<p>startTicking();</p>


</div>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>