<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="">
<meta name="dcterms.date" content="2024-10-31">

<title>구리(Cu) – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">구리(Cu)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">code</div>
    <div class="quarto-category">analysis</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 31, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>구리의 특성 및 철의 제조 방법에 대해 다루고자 한다.</p>
<p>01 구리 (Cu, Copper) 청동기 시대 이전부터 인류가 사용해 온 금속 중 하나.</p>
<p>청동기 시대(Bronze Age)는 구리와 주석을 합금하여 청동을 만들면서 시작되었으며, 이는 약 기원전 3300년 ~ 1200년 사이의 시기로 여겨진다.</p>
<ol type="1">
<li>전기 전도도 구리는 전기 전도도가 매우 우수하여 전선으로 널리 사용된다.</li>
</ol>
<p>금과 은도 전기 전도성이 뛰어나지만, 구리에 비해 가격이 비싸므로, 실용적인 측면에서 구리가 더 선호된다.</p>
<ol start="2" type="1">
<li><p>열 전도도 구리는 열 전도도가 높아, 열을 효과적으로 전달할 수 있다. 따라서 열 배관이나 히트 싱크 같은 열 관리가 중요한 곳에서 많이 사용된다.</p></li>
<li><p>내부식성 구리는 철에 비해 부식에 강하여 천천히 녹이 슨다.</p></li>
</ol>
<p>이는 구리가 갖는 내부식성 덕분으로, 물리적 화학적 환경에서 더 오래 견디며 녹슬지 않는 특징이 있다.</p>
<ol start="4" type="1">
<li><p>가공성 구리는 녹는 점이 낮아 낮은 온도에서도 쉽게 녹일 수 있다. 이러한 특성 덕분에 다양한 형태로 가공하기 쉬워 산업적으로 많이 사용된다.</p></li>
<li><p>살균 효과 구리는 강력한 살균 효과를 가지고 있다. 구리 입자는 밀입자(나노 사이즈의 입자)로서 세균이나 바이러스를 빠르게 사멸시킨다.</p></li>
</ol>
<p>구리의 표면에 닿은 세균은 구리 입자가 파괴하면서 증식을 막아 빠르게 사멸하게 된다. 이 때문에 병원의 손잡이나, 공공장소의 특정 표면에 구리를 사용하는 경우가 많다.</p>
<ol start="6" type="1">
<li>나노 구리 입자 투명한 비닐에 나노 사이즈의 구리 입자를 뿌려 놓은 물체는 짧게는 2일, 길게는 일주일 동안 교차 감염을 막아준다.</li>
</ol>
<p>구리 입자에 닿는 세균이나 바이러스는 몇 분에서 몇 시간 이내에 사멸된다.</p>
<p>02 활용 및 한계</p>
<p>병원 및 공공장소 병원의 손잡이와 같은 공공장소의 표면은 구리를 사용하여 교차 감염을 줄일 수 있다. 하지만 구리는 상대적으로 비싼 소재이므로, 대규모로 사용하기에는 비용 부담이 있다.</p>
<p>박테리아 및 바이러스 제어 구리는 박테리아의 DNA를 파괴하여 증식을 막아주는 특성이 있지만, 항생제의 발전으로 인해 이 기능은 일부 잊혀지기도 했다.</p>
<p>최근 나노 기술과의 결합으로 구리의 살균 효과가 재조명되고 있으며, 병원과 공공장소에서 다시 구리에 대한 관심이 증가하고 있다.</p>
<p>03 구리의 대체 금속</p>
<ol type="1">
<li>구리 구리는 산업적으로 탁월한 소재이지만, 비용이 상대적으로 높아 대량으로 사용하기에는 부담이 될 수 있다.</li>
</ol>
<p>이에 따라 구리의 사용량을 줄이고 대체 금속을 사용하는 경우가 많다.</p>
<ol start="2" type="1">
<li>아연 아연도 구리와 비슷하게 비싼 금속이므로, 비용적인 측면에서 부담이 될 수 있다.</li>
</ol>
<p>하지만, 아연은 구리와 혼합할 때 특정 물성을 강화시킬 수 있어 여전히 산업적으로 중요한 역할을 한다.</p>
<ol start="3" type="1">
<li>구리 + 아연의 합금 구리에 아연(Zn)을 첨가하면 색상이 가미되어, 시간이 지남에 따라 누리끼리한 색상으로 변할 수 있다.</li>
</ol>
<p>아연을 더 많이 추가할수록 구리 특유의 붉은 색상이 줄어들고, 누런 느낌의 색상이 더 강해진다.</p>
<p>구리 합금에서 아연의 비율을 조정하면 다양한 색상과 물성을 얻을 수 있어, 장식품이나 화폐 등에 널리 사용된다.</p>
<ol start="4" type="1">
<li>청동과 황동의 차이 청동과 황동은 금속 혼합물로, 청동은 주로 구리와 주석의 합금이고, 황동은 구리와 아연의 합금이다.</li>
</ol>
<p>황동은 시간이 지나면 초록색으로 변할 수 있다. 이는 황동 표면에서 일어나는 산화 반응으로 인해 발생하는 색 변화이다.</p>
<ol start="5" type="1">
<li>알루미늄 구리나 아연에 비해 비용이 저렴하고, 경량이며 내식성이 뛰어나 다양한 산업 분야에서 구리와 아연을 대체하는 재료로 사용된다.</li>
</ol>
<p>예를 들어, 1원짜리 동전은 100% 알루미늄으로 제작되어 있다. 이는 알루미늄의 가벼운 무게와 저렴한 비용 때문이다.</p>
<p>알루미늄은 전기 전도도와 가공성이 우수하여, 구리의 역할을 대체하는 경우도 많다.</p>
<ol start="6" type="1">
<li>동전 가치 변화 500원을 제외한 모든 동전은 현재 액면가보다 제작 비용이 더 높아졌다. 이는 사용된 금속의 원재료 가격 상승 때문이다.</li>
</ol>
<p>이로 인해 동전 제작에는 값싼 금속을 내부에 사용하고, 겉 표면에는 다른 금속을 덧씌우는 방식이 사용된다.</p>
<p>04 철과 구리의 특성</p>
<ol type="1">
<li>기본 강도 철(Fe)은 구리(Cu)에 비해 기본적으로 더 높은 강도를 가진다.</li>
</ol>
<p>하지만 순수한 철은 연성(잘 늘어나고 휘어지는 성질)과 전성(얇게 늘어나는 성질)이 높아 약간 부드러워</p>
<p>실질적으로 사용하기엔 약점이 될 수 있다.</p>
<ol start="2" type="1">
<li>주철 탄소 함량이 약 2~4%로 높은 철 - 탄소 합금이다.</li>
</ol>
<p>매우 단단하고 압축 강도가 크지만, 탄소 함량이 높아 취성(충격에 약해 쉽게 부러지는 성질)을 가지므로 내구성이 떨어진다.</p>
<p>이러한 특성 때문에 주로 기계 부품이나 고정 구조물에 사용된다.</p>
<ol start="3" type="1">
<li>강철 주철에 비해 탄소 함량이 낮고(0.02~2%), 특성이 조절 가능하다.</li>
</ol>
<p>탄소와 함께 망간(Mn), 니켈(Ni), 크롬(Cr) 등의 합금을 추가하면 더 단단하고 충격에 강하며 유연성을 갖춘 소재로 변한다.</p>
<p>강철은 내구성이 뛰어나고 쉽게 휘거나 부러지지 않아 건축, 교량, 자동차, 칼 등 다양한 분야에서 사용된다.</p>
<ol start="4" type="1">
<li>강철로 만든 칼의 우수성 강철로 만든 칼은 순수한 철로 만든 칼보다 훨씬 더 강력하다.</li>
</ol>
<p>이는 탄소 함량과 추가 합금 요소 덕분에 강도, 경도, 내마모성 등이 뛰어나기 때문이다.</p>
<p>예를 들어, 일본의 사무라이 검(카타나)은 고탄소강과 저탄소강을 조합하여 내구성과 날카로움을 모두 만족시킨 사례로 유명하다.</p>
<p>05 제선 공정</p>
<ol type="1">
<li>철광석과 원료 철광석은 보통 누렇거나 붉은색을 띄며, 철을 추출하기 위한 주원료이다. 철광석과 탄소 덩어리(코크스)를 이용해 용광로에서 철을 추출한다.</li>
</ol>
<p>FINEX와 같은 공정도 활용되는데, 이는 철광석을 보다 효율적으로 처리하기 위한 최신 기술 중 하나이다.</p>
<ol start="2" type="1">
<li><p>용광로 내부 공정 철광석과 코크스는 용광로(고로) 내부로 들어간다. 코크스는 연료 역할을 하며, 용광로에서 뜨거운 바람과 만나면 불타면서 강한 열을 생성한다. 코크스가 불에 타면서 용광로 내부의 온도가 상승하고, 철광석의 온도도 함께 올라간다.</p></li>
<li><p>산소와의 반응 철광석에는 산소가 포함되어 있다.</p></li>
</ol>
<p>용광로 내부는 산소가 부족한 환경이기에, 코크스가 산소와 완전히 결합하지 못해 일산화탄소(CO)가 생성된다.</p>
<p>일산화탄소는 매우 불안정한 상태이며, 안정적인 이산화탄소(CO₂)로 변하려는 성질이 있다.</p>
<ol start="4" type="1">
<li>환원 반응과 철 추출 일산화탄소는 철광석에 포함된 산소와 결합하여 이산화탄소로 변한다.</li>
</ol>
<p>이 과정에서 철광석에 있던 산소가 제거되며, 순수한 철이 남게 된다. 이를 이산화탄소의 환원 반응이라고 부른다.</p>
<p>최종적으로, 이러한 환원 반응을 통해 선철이 생성되고, 용광로 하단에서 쇳물 형태로 추출된다.</p>
<ol start="5" type="1">
<li>HyREX 공정 전통적인 고로 공정을 개선한 최신 제선 기술.</li>
</ol>
<p>이 기술은 탄소 배출을 줄이고 에너지 효율을 높이기 위한 방식으로, 철광석의 환원 과정에서 수소를 활용할 수도 있다.</p>
<p>06 실리카 제거 공정</p>
<ol type="1">
<li><p>철광석과 실리카(SiO₂) 지구상의 거의 모든 암석에는 SiO₂(실리카)가 포함되어 있다. 철을 추출하기 위해서는 이 실리카를 제거해야 한다.</p></li>
<li><p>석회석의 사용 실리카를 제거하기 위해 석회석(탄산칼슘, CaCO₃)을 사용한다.</p></li>
</ol>
<p>석회석을 용광로에 넣고 열을 가하면, 석회석은 열풍에 의해 이산화탄소(CO₂)가 분리되어 날아가고, 산화칼슘(CaO)이 남게 된다.</p>
<p>산화칼슘은 실리카와 반응하여 슬래그(불순물을 제거하기 위한 부산물)를 형성한다. 이 슬래그는 용광로 상단에 떠오르며, 이를 갈고리로 긁어내어 제거한다.</p>
<ol start="3" type="1">
<li><p>이산화탄소 배출 문제 이 공정에서 이산화탄소가 발생하는 것이 환경 문제로 지적된다. 따라서, 탄소 배출을 줄이기 위한 새로운 기술이 필요하다.</p></li>
<li><p>수소 환원 기술 철광석을 환원할 때 기존의 탄소 대신 수소를 사용하는 방식을 수소 환원 반응이라고 한다. 수소는 철광석의 산소와 결합해 물(H₂O)로 변하므로, 이산화탄소 배출 없이 철을 추출할 수 있다.</p></li>
</ol>
<p>이러한 기술은 미래의 탄소 중립 목표를 달성하기 위한 핵심 기술로 주목받고 있다. 현재 이 기술은 아직 완성되지 않았으며, 수소 환원 철 기술은 개발 중인 상태이다.</p>
<p>우리나라는 포스코와 같은 기업을 통해 이 기술에 대한 연구를 진행하고 있으나, 개발 속도는 다소 뒤처진 상황이다.</p>
<p>07 제철 공정 철광석에서 철을 추출하여 다양한 철 제품을 만드는 공정을 단계별로 설명한다.</p>
<ol type="1">
<li>선철 쇳물의 생성 철광석을 용광로에서 가열하여 불순물이 많이 포함된 선철 쇳물을 만든다.</li>
</ol>
<p>이 과정에서 산소를 주입하여 탄소와 결합시켜 이산화탄소(CO₂) 형태로 제거하는 것이 목표이다.</p>
<p>탄소가 제거되면서 선철의 성질이 개선된다.</p>
<p>이 과정은 고온 상태를 유지해야 하며, 용광로가 꺼지면 다시 점화하는 데 오랜 시간이 걸리므로 연속적인 공정이 중요하다.</p>
<ol start="2" type="1">
<li>연주 공정 (Continuous Caster) 완제품이 아닌 반제품을 만드는 단계이며, 선철 쇳물을 일정한 형태로 만드는 공정이다.</li>
</ol>
<p>쇳물을 연속적으로 붓고 길을 따라 이동시키며, 유동성 고체 상태에서 서서히 경화되어 슬라브라는 넓은 판형태의 철 덩어리가 만들어진다.</p>
<p>슬라브는 필요한 길이로 잘라서 식힌 후 다음 공정으로 이동한다.</p>
<ol start="3" type="1">
<li>압연 공정 (Rolling) 슬라브를 다양한 형태로 가공하는 과정이다.</li>
</ol>
<p>두 개의 롤러 사이에 슬라브를 넣어 눌러주면, 얇고 긴 판 형태로 변한다. 이 과정을 압연 공정이라고 하며, 크게 두 가지 방식으로 나뉜다.</p>
<p>3-1. 열간 압연 (열연) 슬라브를 가열한 상태에서 압연한다.</p>
<p>슬라브를 화장지 두루마리처럼 말아서 저장할 수 있으며, 이 과정을 줄여서 열연 강판이라고 한다. 롤러의 굴곡을 조절하여 휘어지지 않도록 두꺼운 상태로 마무리한다.</p>
<p>조선업체, 자동차 산업, 파이프, 전자레인지 등의 소재로 활용된다.</p>
<p>3-2. 냉간 압연 (냉연) 열간 압연된 강판을 다시 가열하여 풀어낸 후, 더욱 얇게 눌러주는 과정이다. 이 과정을 통해 표면이 매끄럽고 정밀도가 높은 냉연 강판이 만들어진다.</p>
<p>자동차 외장, 가전제품 등 매끈한 표면이 요구되는 제품에 사용된다.</p>
<ol start="4" type="1">
<li><p>제철 공정의 전체 작업 제철회사에서는 이러한 과정을 통해 철광석에서 시작하여 여러 형태의 철 제품을 생산한다. 생산된 철 제품은 다양한 산업에 맞춰 가공되어 사용된다.</p></li>
<li><p>선재 공정 (Wire Rod) 선형 제품을 생산하는 공정이다.</p></li>
</ol>
<p>빌렛(작은 직사각형 철 덩어리)을 가열하여 특정한 기계에 통과시키고, 철사를 뽑아내는 방식이다.</p>
<p>철사, 케이블, 스프링 등의 얇고 긴 제품을 제작할 때 사용된다.</p>
<ol start="2" type="1">
<li>주조 공정 (Casting) 쇳물을 몰드(틀)에 부은 후 식히고 틀을 제거하여 원하는 형태를 만든다. 복잡한 형태나 내부 구조가 중요한 제품을 제작할 때 사용됩니다.</li>
</ol>
<p>자동차 엔진 블록, 기계 부품 등 복잡한 물체를 효율적으로 제조할 수 있다.</p>
<ol start="3" type="1">
<li>단조 공정 (Forging) 가열된 철 덩어리를 망치로 두들겨서 원하는 모양으로 만드는 공정이다.</li>
</ol>
<p>철의 내구성과 강도를 높이는 데 유리하며, 비교적 간단한 형태의 강한 제품을 제작할 때 사용된다.</p>
<p>공구, 무기, 기계 부품 등 강도가 중요한 제품을 만드는 데 활용된다.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>