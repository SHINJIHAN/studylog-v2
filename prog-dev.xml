<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>StudyLog</title>
<link>https://shinjihan.github.io/studylog/prog-dev.html</link>
<atom:link href="https://shinjihan.github.io/studylog/prog-dev.xml" rel="self" type="application/rss+xml"/>
<description>통계와 AI를 기록하는 개인 블로그</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Mon, 03 Mar 2025 15:00:00 GMT</lastBuildDate>
<item>
  <title>개발 일지4</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_06.html</link>
  <description><![CDATA[ 




<p>재실 감지 시스템을 개발하기 위한 기초 개념에 대해 다루고자 한다.</p>
<p>01 기본 개념</p>
<p>1 . 비동기 프로그래밍 (async/await) FastAPI는 비동기 처리를 지원하므로 기본적인 개념을 이해해야 한다.</p>
<p>2 . 데이터베이스 개념 SQL 기본 문법 (SELECT, INSERT, UPDATE, DELETE)</p>
<p>관계형 데이터베이스 (MySQL, PostgreSQL, SQLite 등)</p>
<p>https://www.w3schools.com/sql/</p>
<p>02 FastAPI 기본 사용법 FastAPI 설치 및 프로젝트 구조</p>
<p>기본적인 API 엔드포인트 만들기 (<span class="citation" data-cites="app.get">@app.get</span>(), <span class="citation" data-cites="app.post">@app.post</span>())</p>
<p>Pydantic을 이용한 데이터 검증 (BaseModel)</p>
<p>FastAPI에서 비동기(async def) 사용법</p>
<p>from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/”) async def home(): return {“message”: “Hello, FastAPI!”}</p>
<p>FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>Tutorial - User Guide - FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>03 SQLModel을 활용한 데이터베이스 연동 SQLModel 설치 및 기본 사용법</p>
<p>ORM 개념 이해하기 (객체를 데이터베이스 테이블과 매핑)</p>
<p>데이터베이스 모델 정의 및 CRUD(Create, Read, Update, Delete) 구현</p>
<p>SQLite로 간단한 DB 실습 후, MySQL/PostgreSQL 연동</p>
<p>SQLModel</p>
<p>SQLModel, SQL databases in Python, designed for simplicity, compatibility, and robustness.</p>
<p>sqlmodel.tiangolo.com</p>
<p>04 재실 감지 시스템 API 설계 및 구현 RESTful API 설계 방법</p>
<p>API 요청 및 응답 데이터 형식(Pydantic)</p>
<p>CRUD API 구현</p>
<p>API 테스트(Postman, Curl 활용)</p>
<p>from fastapi import FastAPI, Depends from sqlmodel import Session, select</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(“/rooms/{room_id}/status”) async def update_room_status(room_id: int, is_occupied: bool, session: Session = Depends(get_session)): room = session.exec(select(RoomStatus).where(RoomStatus.id == room_id)).first() if room: room.is_occupied = is_occupied session.commit() return {“message”: “Room status updated”} return {“error”: “Room not found”}</p>
<p>05 실시간 감지 시스템과 연동 (추가 학습) WebSocket을 이용한 실시간 데이터 전송</p>
<p>센서 데이터 연동 (IoT 장치와 연결)</p>
<p>백엔드에서 프론트엔드와 통신 (웹 애플리케이션 또는 모바일 앱과 연동)</p>
<p>WebSockets - FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>MQTT - The Standard for IoT Messaging</p>
<p>Why MQTT? Lightweight and Efficient MQTT clients are very small, require minimal resources so can be used on small microcontrollers. MQTT message headers are small to optimize network bandwidth. Bi-directional Communications MQTT allows for messaging betwe</p>
<p>mqtt.org 추가 학습 방향 ✅ Docker와 배포 방법</p>
<p>Docker로 FastAPI + SQLModel 앱 컨테이너화</p>
<p>서버에 배포 (AWS, GCP, Heroku 등)</p>
<p>✅ 보안 및 인증</p>
<p>JWT 인증 방식 (OAuth2)</p>
<p>API 보안 (CORS, CSRF 방어)</p>
<hr>
<p>https://pypi.org/project/paho-mqtt/</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_06.html</guid>
  <pubDate>Mon, 03 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지3</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_05.html</link>
  <description><![CDATA[ 




<p>재실감지 프로젝트의 2월 24일 오후 9시 회의에 대해 다루고자 한다.</p>
<p>01 API 정의 응용 프로그램 인터페이스, Application Programming Interface.</p>
<p>다른 프로그램과 소통할 수 있도록 만들어진 인터페이스. 사용하는 대상과 방식에 따라 다르게 분류될 수 있다.</p>
<p>API의 역할을 두 가지 측면에서 구분해서 봐야 한다.</p>
<p>1 . HTTP 통신을 위한 API 웹 애플리케이션이나 모바일 앱에서 백엔드 서버와 데이터를 주고받기 위한 API.</p>
<p>주로 HTTP 프로토콜을 사용하여 데이터를 요청하고 응답을 받는다.</p>
<p>예를 들어, 클라이언트(웹 브라우저, 모바일 앱 등)가 서버의 특정 URL에 요청을 보내면 서버가 JSON 형식으로 데이터를 응답하는 방식.</p>
<p>보통 REST API, GraphQL API 등이 이에 해당된다.</p>
<p>2 . 백엔드 내부에서 DB와 통신하는 API 백엔드 시스템 내부에서만 사용되는 API. 프로그램 내부에서 함수 호출을 통해 사용된다.</p>
<p>예를 들어, 백엔드 코드에서 DB에서 유저 정보를 가져오는 함수 같은 것이 이에 해당된다.</p>
<p>HTTP 요청 없이, 애플리케이션 내부의 모듈 간 통신을 위한 API라고 할 수 있다.</p>
<p>02 재실 확인 정의 연구실 내의 사람들의 재실 즉, 출입 여부를 확인하는 시스템을 구축하는 방식.</p>
<p>이를 이해하려면 프론트엔드(사용자 인터페이스)와 백엔드(서버) 간의 데이터 흐름을 살펴봐야 한다.</p>
<p>1 . 재실 상태 업데이트 방식 연구실 구성원이 출입할 때마다 해당 정보를 서버인 백엔드에 전송해야 한다.</p>
<p>이를 위해 POST 요청을 사용하여 현재 상태(입실/퇴실)를 백엔드에 전달한다. 백엔드는 이를 받아서 DB에 재실 정보를 저장한다.</p>
<p>2 . DB 직접 접근 불가 프론트엔드는 웹 브라우저에서 실행되는 화면(UI).</p>
<p>보안상 프론트엔드가 DB에 직접 접근하면 안 된다. 대신, 백엔드 서버에 GET 요청을 보내서 데이터를 가져와야 한다.</p>
<p>3 . GET 요청 연구실의 재실 상태가 바뀌어도 프론트엔드에서는 이를 자동으로 알 방법이 없다.</p>
<p>따라서 1초마다 백엔드에 GET 요청을 보내 최신 상태를 확인해야 한다. 이를 통해 연구실 출입 상태가 바꿜 때마다 UI가 자동으로 업데이트된다.</p>
<p>연구실 인원 수가 많지 않다면, 1초마다 GET 요청을 보내도 서버가 충분히 감당할 수 있다.</p>
<p>4 . 추가 최적화 방법 위 방식은 불필요한 트래픽이 발생할 수 있다.</p>
<p>웹소켓(WebSocket)을 사용하면 재실 상태가 변경될 때만 프론트엔드로 알림을 보낼 수 있다.</p>
<p>하지만 구현이 조금 더 복잡할 수 있다.</p>
<p>03 DB 설계</p>
<p>1 . DB의 정의 연구실 출입 정보를 저장해야 하므로 DB가 필요하다.</p>
<p>연구실 출입 기록을 관리하지 않고 메모리(RAM)에서만 처리하면 서버를 재시작하면 데이터가 사라진다.</p>
<p>따라서 DB에 출입 기록을 저장해야 한다.</p>
<p>2 . SQLite 연구실 시스템은 트래픽이 많지 않다.</p>
<p>SQLite는 파일 기반 경량 DB로, 연구실 같은 소규모 시스템에서 사용하기 적절하다.</p>
<p>대형 시스템이면 MySQL, PostgreSQL 같은 DB를 고려해야 하지만, 현재 상황에서는 SQLite로 충분하다.</p>
<p>3 . 로그 기록 남기는 방법 연구실 출입 기록을 DB에 어떻게 저장할지 고민하는 부분이다. 로그를 남기는 방식은 여러 가지가 있지만, 최소한의 정보만 저장하면 된다.</p>
<p>즉, 재실 상태를 실시간으로 저장하는 것이 아니라, “출입 로그만 남기면 충분하다”는 의미이다.</p>
<p>예를 들어, 한 사람이 하루에 5번 드나들면, 그 5번의 출입 로그만 기록하면 된다.</p>
<p>“현재 연구실에 있는 사람” 이 누구인지 확인하려면, status = ’ in ’ 중 가장 최신 로그를 보면 된다.</p>
<p>출입할 때만 기록을 남기므로 불필요한 데이터 저장을 최소화할 수 있다.</p>
<p>4 . DB 갱신 보류 데이터가 계속 쌓이면 DB 크기가 커지고 성능 저하 가능성이 있다. 그래서 “1달마다 오래된 로그를 삭제할까?” 라는 고민을 했지만, 결론적으로 필요 없다고 판단하였다.</p>
<p>SQLite는 소규모 데이터 저장에는 충분히 빠르고 효율적이다. 연구실 출입 기록을 하루 수십 ~ 수백 개 수준으로 가정해도 1년치 데이터는 몇 MB가 안 될 것이다.</p>
<p>따라서 데이터가 많아서 생기는 성능 문제는 걱정할 필요 없다.</p>
<p>5 . DB 제약사항 최소화 테이블을 만들 때, 외래키, 복잡한 관계 등 너무 많은 제약을 설정하지 말자는 의미.</p>
<p>SQLite는 간단한 DB이므로, 최대한 단순한 구조로 유지하는 것이 좋다. 최소한의 필드만 저장 (user_id, status, timestamp)</p>
<p>JOIN 남발하는 등 불필요한 복잡한 테이블 관계를 자제한다. ON DELETE CASCADE 같은 것을 최소화하여 강한 외래키 제약한다.</p>
<p>04 DB 라이브러리 선택 데이터베이스와 소통하려면 라이브러리(의존성)가 필요하며 다음과 같은 후보가 있다.</p>
<p>1 . SQLAlchemy Python에서 가장 널리 사용되는 ORM(Object-Relational Mapping) 라이브러리.</p>
<p>SQLAlchemy</p>
<p>The Database Toolkit for Python</p>
<p>www.sqlalchemy.org 트랜잭션, 복잡한 쿼리, DB 최적화 등 강력한 기능 제공하지만 설정이 복잡하고 학습 곡선이 가파르다.</p>
<p>장점 대규모 프로젝트에서 사용하기 좋다.</p>
<p>다양한 데이터베이스 지원 (PostgreSQL, MySQL, SQLite 등) ORM뿐만 아니라 직접 SQL을 실행하는 기능도 제공한다.</p>
<p>단점 문법이 복잡하고 설정이 어려우며, 초보자가 배우기에 부담스러울 수 있다.</p>
<p>추천 대상 ① 대규모 프로젝트에서 강력한 데이터베이스 기능이 필요한 경우 ② SQL을 잘 알고 있고 세부적인 최적화가 필요한 경우</p>
<p>2 . Peewee peewee — peewee 3.17.9 documentation</p>
<p>경량 ORM으로, 코드가 단순하고 배우기 쉽다. SQLAlchemy보다 기능이 적지만, 기본적인 CRUD 작업에는 충분하다.</p>
<p>장점 코드가 간결하고 직관적이며, 설정이 간단해 빠르게 시작 가능하다.</p>
<p>SQLite, PostgreSQL, MySQL을 지원한다.</p>
<p>단점 SQLAlchemy보다 기능이 부족하다. 대규모 프로젝트에는 부적절할 수 있다.</p>
<p>추천 대상 ① 작은 프로젝트나 빠르게 개발해야 하는 경우 ② 복잡한 DB 연산이 필요하지 않은 경우</p>
<p>3 . SQLModel SQLAlchemy를 기반으로 만든 최신 ORM. Pydantic과 통합되어 데이터 검증이 쉽다.</p>
<p>SQLModel</p>
<p>https://www.sqlalchemy.org/ SQLAlchemy의 강력한 기능을 유지하면서도 더 간단한 사용법 제공한다.</p>
<p>장점 공식 지원을 받으며, 최신 기술을 반영한다.</p>
<p>SQLAlchemy보다 더 간단한 문법 가지며, Pydantic과 연계되어 데이터 모델링과 검증이 쉽다.</p>
<p>단점 아직 SQLAlchemy만큼 성숙하지 않다. (상대적으로 신생 라이브러리) 복잡한 DB 기능을 다루려면 결국 SQLAlchemy의 일부 기능을 사용해야 한다.</p>
<p>추천 대상 ① FastAPI 같은 최신 프레임워크와 함께 사용할 경우 ② SQLAlchemy의 복잡함을 줄이고 싶지만, 강력한 기능이 필요한 경우</p>
<p>최종 결정으로 SQLModel을 선택하였다.</p>
<p>05 SQLite과의 비교</p>
<p>1 . 일반적인 DBMS MySQL, PostgreSQL 등이 해당된다.</p>
<p>독립적인 서버로 실행되며, 클라이언트가 네트워크를 통해 서버에 접속하여 데이터 요청한다.</p>
<p>여러 사용자가 동시에 접근할 수 있다.</p>
<p>2 . SQLite 서버가 없으므로, 별도의 프로그램을 실행할 필요 없다. 데이터를 ’ .db 파일 ’ 로 저장한다.</p>
<p>프로그램이 직접 파일을 읽고 쓰는 방식으로 동작한다. 가볍고 간단해서 로컬 데이터 저장용으로 적합하다.</p>
<p>06 쿼리</p>
<p>1 . 유저 테이블 랩원(사용자)에 대한 기본 정보를 저장한다.</p>
<p>2 . 로그 테이블 (presence)</p>
<p>입실 및 퇴실 시간을 기록한다.</p>
<p>각 로그에는 입실/퇴실 여부를 나타내는 정보와, 어떤 유저인지에 대한 정보가 포함된다.</p>
<p>이 쿼리는 presence 테이블에서 유저의 입실 및 퇴실 기록을 조회하는 쿼리이다.</p>
<p>SELECT DISTINCT ON (user_id) * FROM presence ORDER BY at_time, user_id DESC; 이 쿼리는 각 유저별로 가장 최근의 입실/퇴실 기록을 가져온다.</p>
<p>예를 들어, 유저 A가 오전 9시에 입실하고 오후 5시에 퇴실한 경우, presence 테이블에서 유저 A의 두 개의 레코드가 있을 수 있다.</p>
<p>이 쿼리는 유저 A의 가장 최근 퇴실 시간 또는 입실 시간을 선택하게 된다.</p>
<p>SELECT DISTINCT ON (user_id) DISTINCT ON (user_id)는 유저별로 가장 최근의 기록만 선택한다. 즉, 유저가 여러 번 입실/퇴실한 경우, 각 유저의 가장 최근 입실/퇴실 정보만 가져오게 된다.</p>
<p>’ * ’ 테이블의 모든 컬럼을 선택하겠다는 의미이다.</p>
<p>예를 들어, at_time (시간), user_id (유저 ID), 입실/퇴실 여부 등을 포함하는 모든 컬럼을 가져온다.</p>
<p>FROM presence presence 테이블에서 데이터를 가져온다. presence 테이블에는 입실과 퇴실 시간에 대한 기록이 저장되어 있다.</p>
<p>ORDER BY at_time, user_id DESC at_time으로 먼저 시간 순서대로 정렬한다. (입실/퇴실 시간을 기준으로 오름차순 정렬)</p>
<p>그 다음 user_id DESC로 유저 ID를 내림차순으로 정렬한다.</p>
<p>이는 같은 시간에 여러 번 입출입한 기록이 있을 수 있을 때, 가장 최신 기록을 가져오기 위함이다.</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_05.html</guid>
  <pubDate>Thu, 27 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지2</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_04.html</link>
  <description><![CDATA[ 




<p>01 VS코드 실행 관리자 권한으로 실행하기.</p>
<p>1 . uv 설치 pip install uv</p>
<p>2 . Python 3.12로 가상 환경 생성 uv venv -p 3.12 fastapi-env</p>
<p>3 . 프로제트 클론하기 djailab/backend를 클론 후 파일 생성 및 폴더에 저장.</p>
<p>git clone https://github.com/djailab/backend.git</p>
<p>4 . 프로젝트 설정 동기화 uv sync</p>
<p>5 . 파일 실행 명령어 uv run hello.py</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_04.html</guid>
  <pubDate>Sun, 23 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_03.html</link>
  <description><![CDATA[ 




<p>01 제목1 [ID 사용하기]</p>
<p>1 . 제목2 본문1</p>
<p>본문2</p>
<p>Sign In</p>
<p>Sign in to AILab ID Authenticate yourself with your passkey to access the admin panel. Authenticate</p>
<p>sso.llms.kr</p>
<p>키 값.</p>
<p>비밀번호 입력.</p>
<p>Sign in to Services</p>
<p>Sign in to Services Do you want to sign in to Services with your AILab ID account? Cancel Sign in</p>
<p>sso.llms.kr</p>
<p>재희 작품</p>
<p>깃허브 주소 보내면 이메일로 옴</p>
<p><a href="https://github.com/djailab">djailab</a></p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_03.html</guid>
  <pubDate>Wed, 19 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>FastAPI</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_02.html</link>
  <description><![CDATA[ 




<p>CHAPTER 3에 대해 다루고자 한다.</p>
<p>01 소개 https://fastapi.tiangolo.com/#requirements</p>
<p>02 FastAPI 애플리케이션</p>
<p>3 - 1 . hello 파일 생성하기 from fastapi import FastAPI #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI() <span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(): return “Hello? World?”</p>
<p>3 - 2 . cmd 실행 uvicorn hello:app –reload</p>
<p>3 - 3 . 파일에 추가 코드 if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 4 . 검색창 입력 http://localhost:8000/hi</p>
<p>3 - 5 . Requests로 /hi 테스트 import requests r = requests.get(“http://localhost:8000/hi”) r.json()</p>
<p>3 - 6 . Requests와 거의 동일한 HTTPX로 /hi 테스트 # pip install httpx import httpx r = httpx.get(“http://localhost:8000/hi”) r.json()</p>
<p>HTTPie 설치가 안되어 있을 경우 pip install httpie # 설치 명령어 where http # 설치된 경로 출력 명령어</p>
<p>3 - 7 . HTTPie로 /hi 테스트 httpie localhost:8000/hi</p>
<p>3 - 8 . HTTPie로 /hi 를 테스트해 응답 본문만 출력 http -b localhost:8000/hi</p>
<p>3 - 9 . HTTPie로 /hi를 테스트하고 모든 정보 출력 http -v localhost:8000/hi</p>
<p>03 HTTP 요청</p>
<p>3 - 11 . 인사말 경로 변환 from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi/{who}”) def greet(who): return f”Hello? {who}”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 12 . 브라우저에서 hi/Mom 테스트 http://localhost:8000/hi/Mom</p>
<p>3 - 13 . HTTPie로 hi/Mom 테스트 http localhost:8000/hi/Mom</p>
<p>3 - 14 . Requests로 /hi/Mom 테스트 import requests r = requests.get(“http://localhost:8000/hi/Mom”) r.json()</p>
<p>3 - 15 . 인사말 쿼리 매개변수 변환 from fastapi import FastAPI #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(who): return f”Hello? {who}”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 16 . 브라우저에서 테스트 http://localhost:8000/hi?who=Mom</p>
<p>3 - 17 . HTTPie 테스트 http -b localhost:8000/hi?who=Mom</p>
<p>3 - 18 . HTTPie 및 매개변수 사용 테스트 http -b localhost:8000/hi who==Mom</p>
<p>3 - 19 . Requests로 테스트 import requests r = requests.get(“http://localhost:8000/hi?who=Mom”) r.json()</p>
<p>3 - 20 . Requests 및 매개변수 테스트 import requests params = {“who”: “Mom”} r = requests.get(“http://localhost:8000/hi”, params=params) r.json()</p>
<p>3 - 21 . 인사말 본문 반환 from fastapi import FastAPI, Body #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(“/hi”) def greet(who : str = Body(embed=True)): return f”Hello? {who}?”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 22 . HTTPie로 테스트 http -v localhost:8000/hi who=Mom</p>
<p>3 - 23 . Requests로 테스트 import requests r = requests.post(“http://localhost:8000/hi”, json={“who”: “Mom”}) r.json()</p>
<p>3 - 24 . Requests로 테스트 from fastapi import FastAPI, Header #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(who : str = Header()): return f”Hello? {who}?”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 25 . Requests로 테스트 http -v localhost:8000/hi who:Mom</p>
<p>3 - 26 . 헤더 반환 from fastapi import FastAPI, Header</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/agent”) def get_agent(user_agent : str = Header()): return user_agent</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 27 . HTTPie로 User-Agent 헤더 테스트 http -v localhost:8000/agent</p>
<p>04 HTTP 요청</p>
<p>3 - 28 . HTTP 상태 코드 지정 from fastapi import FastAPI, Header</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/happy”) def happy(status_code=200): return “:)”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 29 . HTTP 상태 코드 지정 http localhost:8000/happy</p>
<p>3 - 30 . HTTP 상태 코드 지정 from fastapi import FastAPI, Response</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/header/{name}/{value}”) def header(name: str, value: str, response: Response): response.headers[name] = value return “normal body”</p>
<p>3 - 31 . 응답 HTTP 헤더 테스트 http localhost:8000/header/marco/polo</p>
<p>파일 저장</p>
<p>위 코드를 test_json.py 파일로 저장한다.</p>
<p>3 - 32 . JSON 폭발 방지 # pip install pytest import datetime import pytest from fastapi.encoders import jsonable_encoder import json</p>
<p><span class="citation" data-cites="pytest.fixture">@pytest.fixture</span> def data(): return datetime.datetime.now()</p>
<p>def test_json_dump(data): with pytest.raises(TypeError): _ = json.dumps(data)</p>
<p>def test_encoder(data): out = jsonable_encoder(data) assert out json_out = json.dumps(out) assert json_out</p>
<p>pytest 실행 pytest test_json.py</p>
<p>3 - 33 . 모델 변형 from datetime import datetime from pydantic import BaseModel</p>
<section id="pydantic-모델-정의" class="level1">
<h1>Pydantic 모델 정의</h1>
<p>class TagIn(BaseModel): tag: str</p>
<p>class Tag(BaseModel): tag: str created: datetime secret: str</p>
<p>class TagOut(BaseModel): tag: str created: datetime</p>
</section>
<section id="입력-데이터-생성" class="level1">
<h1>입력 데이터 생성</h1>
<p>input_data = {“tag”: “fastapi”}</p>
</section>
<section id="tagin-모델-사용-데이터-검증" class="level1">
<h1>TagIn 모델 사용 (데이터 검증)</h1>
<p>tag_in = TagIn(**input_data) print(tag_in)</p>
</section>
<section id="tag-모델-사용" class="level1">
<h1>Tag 모델 사용</h1>
<p>tag_data = { “tag”: “fastapi”, “created”: datetime.now(), “secret”: “my_secret” } tag = Tag(**tag_data) print(tag)</p>
</section>
<section id="tagout-모델-사용-tag에서-특정-필드-제외" class="level1">
<h1>TagOut 모델 사용 (Tag에서 특정 필드 제외)</h1>
<p>tag_out = TagOut(**tag.dict()) # secret 필드는 자동으로 제외됨 print(tag_out)</p>
<p>pytest 실행 python tag.py</p>
<p>3 - 34 . 모델 변형 from datetime import datetime from model.tag import Tag</p>
<p>def create(tag: Tag) -&gt; Tag: “““태그를 생성한다.”“” return tag</p>
<p>def get(tag_str: str) -&gt; Tag: “““태그를 반환한다.”“” return Tag(tag=tag_str, created=datetime.utcnow(), secret=““)</p>
<p>3 - 35 . 모델 변형 from datetime import datetime from model.tag import TagIn, Tag, TagOut import service.tag as service from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(‘/’) def create(tag_in: TagIn) -&gt; TagIn: tag: Tag = Tag(tag=tag_in.tag, created=datetime.utcnow(), secret=“shhhh”) service.create(tag) return tag_in</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(‘/{tag_str}’, response_model=TagOut) def get_one(tag_str) -&gt; TagOut: tag: Tag = service.get(tag_str) return tag</p>
<p>3 - 36 . 실행 uvicorn web.tag:app</p>
<p>3 - 37 . Tag 가져오기 요청 http -b localhost:8000/GoodTag</p>
<p>04 자동 문서화</p>
<p>3 - 1 . 접속하기 http://localhost:8000/docs</p>
<p>3 - 2 . ㅇ</p>
<p>3 - 3 . ㅇ</p>
<p>3 - 4 . ㅇ</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_02.html</guid>
  <pubDate>Thu, 13 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Git 사용법</title>
  <link>https://shinjihan.github.io/studylog/pd/od/od_01.html</link>
  <description><![CDATA[ 




<p>VS코드로 Git 사용법에 대해 다루고자 한다.</p>
<section id="버전-관리-시스템" class="level1">
<h1>01 버전 관리 시스템</h1>
<p><code>VCS, Version Control System</code> 소프트웨어 개발 및 문서 작업에서 변경 사항을 기록, 추적, 관리, 수정, 복구할 수 있도록 돕는 도구.</p>
<ol type="1">
<li>로컬 버전 관리 시스템 <code>Local VCS</code> 파일 변경 이력을 로컬 컴퓨터에서만 관리하는 시스템을 의미. 대표적인 로컬 버전 관리 시스템은 RCS이며, 이는 파일의 변경 이력을 개별적으로 저장하는 방식이다.</li>
</ol>
<p><code>Revision Control System</code> 과거 macOS 및 UNIX 시스템에서 사용되었으나, 현재는 Git과 같은 분산 버전 관리 시스템(DVCS)의 등장으로 거의 사용되지 않는다.</p>
<ol start="2" type="1">
<li>중앙집중식 버전 관리 시스템 <code>CVCS, Centralized VCS</code> 여러 사용자가 협업할 수 있도록 설계된 중앙 서버 기반의 버전 관리 시스템.</li>
</ol>
<p>모든 변경 사항이 중앙 서버에 저장되며, 사용자는 중앙 서버에서 데이터를 가져와 수정한 후 다시 업로드하는 방식으로 동작한다.</p>
<p>대표적으로, SVN (Subversion), Perforce, CVS (Concurrent Versions System) 등이 있다.</p>
<p>CVCS의 단점 ① 모든 변경 이력이 중앙 서버에 저장되므로, 서버가 다운되거나 손상되면 데이터를 잃거나 작업이 불가능할 수 있다.</p>
<p>② 파일을 가져오거나 변경 사항을 기록하려면 항상 중앙 서버에 연결해야 한다. 네트워크 연결이 불안정하면 효율적으로 작업하기 어렵다.</p>
<p>3 . 분산 버전 관리 시스템 (DVCS, Distributed VCS)</p>
<p>각 개발자가 히스토리가 포함된 전체 저장소를 로컬에 복제하여 관리하는 방식.</p>
<p>Git, Mercurial이 대표적인 DVCS이다.</p>
<p>Git의 장점 ① 모든 변경 이력을 로컬 저장소(Local Repository)에 저장한다. 따라서 네트워크 연결 없이도 히스토리를 조회하고, 로컬에서 자유롭게 작업할 수 있다.</p>
<p>② 가벼운 브랜칭(branching) 기능을 제공하여, 여러 작업을 독립적으로 진행할 수 있다. 브랜치를 쉽게 병합(merging)할 수 있어, 팀 협업 시 코드 충돌을 최소화할 수 있다.</p>
<p>③ 모든 개발자의 로컬 저장소에 프로젝트의 전체 히스토리를 저장한다. 중앙 서버에 문제가 발생해도, 로컬 저장소를 활용하여 데이터를 복구할 수 있다.</p>
<p>이러한 장점 덕분에 Git은 현대적인 소프트웨어 개발에서 가장 널리 사용되는 버전 관리 시스템이 되었다.</p>
<p>02 Git 사용법</p>
<p>1 . Git 설치하기</p>
<p>Git - Downloads</p>
<p>Downloads macOS Windows Linux/Unix Older releases are available and the Git source repository is on GitHub. Latest source Release 2.48.1 Release Notes (2025-01-13) Download Source Code GUI Clients Git comes with built-in GUI tools (git-gui, gitk), but ther</p>
<p>git-scm.com</p>
<p>설치가 완료되었다.</p>
<p>Git Bash를 관리자 권한으로 실행하기.</p>
<p>다음과 같은 창이 나오는 것을 확인할 수 있다.</p>
<p>2 . VS Code 실행하기 Git 창을 닫고 VS Code를 실행하기.</p>
<p>VS Code가 설치되지 않았다면, 먼저 설치한 후 실행하세요.</p>
<p>Visual Studio Code - Code Editing. Redefined</p>
<p>Visual Studio Code redefines AI-powered coding with GitHub Copilot for building and debugging modern web and cloud applications. Visual Studio Code is free and available on your favorite platform - Linux, macOS, and Windows.</p>
<p>code.visualstudio.com</p>
<p>첫 화면.</p>
<p>새 파일 만들기.</p>
<p>Open Folder &gt; New &gt; Folder</p>
<p>파일명이 왼쪽 상단에 생성된 것을 확인할 수 있다. 이제 오른쪽 상단의 Toggle Panel을 클릭한다.</p>
<p>3 . 터미널 (Terminal) 터미널에 Git 저장소를 로컬로 복제(clone)하는 명령어 입력하기.</p>
</section>
<section id="기본구조-git-clone-복제할-원격-저장소의-url" class="level1">
<h1>기본구조: git clone + 복제할 원격 저장소의 URL</h1>
<p>예제: git clone https://github.com/onlybooks/python-algorithm-interview.git</p>
<p>해당 저장소의 모든 파일과 이력이 현재 작업 디렉토리로 다운로드된다.</p>
<p>즉, python-algorithm-interview 폴더가 생성되며, 해당 저장소의 내용을 그대로 가져오게 된다.</p>
<p>4 . GitHub 저장소 클론</p>
<p>Github 업로드를 허용한다.</p>
<p>원하는 계정을 선택한다.</p>
<p>계정이 없으면 새 계정을 생성한다.</p>
<p>열기 버튼 클릭.</p>
<p>Private는 본인만 접근할 수 있고, Public는 모든 사용자가 접근할 수 있다.</p>
<p>필요에 따라 적절한 옵션을 선택한다.</p>
<p>커밋 내역 확인하기.</p>
<p>README.md 파일 확인하기.</p>
<ol start="7" type="1">
<li>파일의 수정 과정을 알 수 있다.</li>
</ol>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/od/od_01.html</guid>
  <pubDate>Wed, 05 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>함수형 프로그래밍</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_04.html</link>
  <description><![CDATA[ 




<p>(P.68)</p>
<p>기본적으로 함수들을 통해 프로그램을 구성하는 스타일에 대해 다루고자 한다.</p>
<p>Chapter 3 Functional programming with JavaScript</p>
<p>패러다임 (Paradigm) 한 시대의 사고 방식이나 가치관, 믿음 체계를 의미한다. 이는 특정 시대나 분야에서 표준으로 여겨지는 틀을 말하며,</p>
<p>학문, 기술, 예술 등 다양한 분야에서 어떤 접근이나 방법론이 주류로 자리잡고 그것을 중심으로 사고하게 되는 것을 가리킨다.</p>
<p>프로그래밍 패러다임 (Programming Paradigm) 프로그래머가 코드를 바라보는 관점을 제공하고, 어떻게 문제를 해결하고 코드를 작성할지에 대한 방향을 제시하는 역할을 한다.</p>
<p>패러다임마다 특정 방식과 철학을 가지고 있어, 각 패러다임이 지향하는 목표에 따라 문제를 다루고 해결하는 방식이 달라진다.</p>
<p>주요 프로그래밍 패러다임에는 다음과 같은 것들이 있다.</p>
<p>명령형 프로그래밍 (Imperative programming) 무엇(What)을 할 것인지 나타내기보다 어떻게(How) 할 건지를 설명하는 방식</p>
<ol type="1">
<li>절차지향 프로그래밍 (Procedural Programming) C 언어, C++ 같은 명령형 프로그래밍 언어는 수행되어야 할 순차적인 처리 과정을 포함하는 방식으로 프로그램을 작성한다.</li>
</ol>
<p>특히, C 언어는 1970년대에 등장하면서 시스템 프로그래밍의 기반이 되었다.</p>
<p>그러나 1만 줄 이상의 코드를 작성할 경우 오류를 수정하기 어렵고,</p>
<p>한 부분을 수정하기 위해 그것과 연관된 다른 줄을 모두 찾아서 수정해야 하는 상황이 발생할 수 있다.</p>
<p>소프트웨어 공학에서는 소프트웨어 개발 주기가 존재하며, 이 주기에서 가장 비용이 큰 부분은 유지 보수이다.</p>
<p>유지 보수 비용은 전체 개발 비용의 약 70%를 차지할 정도로 매우 높아서, 효율적인 유지 보수 방안이 중요한 요소로 여겨진다.</p>
<p>따라서 명령형 프로그래밍 언어는 유지보수를 하기에 적합한 언어가 아니라고 할 수 있다.</p>
<ol start="2" type="1">
<li>객체지향 프로그래밍 (Object-Oriented Programming, OOP) 객체들의 집합으로 프로그램의 상호작용을 표현하는 방식.</li>
</ol>
<p>C++, Java, C#과 같은 언어들이 대표적이며, 이들 언어는 1980년대에 개발된 이후 현실 세계의 모든 것을</p>
<p>객체로 바라보는 접근 방식을 채택하고 있다.</p>
<p>데이터와 그 데이터를 처리하는 메소드를 하나의 단위인 객체로 묶어서 관리함으로써, 코드의 재사용성과 유지보수성을 높이는 데 기여한다.</p>
<p>특히, 2000년대 이후에는 Java 개발자에 대한 수요가 급증하였다.</p>
<p>이는 Java가 플랫폼 독립성과 강력한 생태계, 다양한 프레임워크를 제공하므로, 많은 기업들이 Java를 기반으로 한 시스템 개발에 집중하고 있음을 나타낸다.</p>
<p>이는 소프트웨어 개발의 효율성을 높이고, 복잡한 시스템을 보다 쉽게 관리할 수 있도록 도와준다.</p>
<p>선언형 프로그래밍 (Declarative Programming) 어떻게 할 것인지를 나타내기보다 무엇을 할 것인지를 설명하는 방식</p>
<p>함수형 프로그래밍 (Functional Programming) 순수 함수를 조합하여 소프트웨어를 만드는 방식.</p>
<p>대표적인 언어로는 클로저(Closure), 하스켈(Haskell), 리스프(Lisp)가 있으며, 이 패러다임은 1930년대에 제안된 람다 함수법에 기반한다.</p>
<p>그러나 그 당시에는 이를 실제로 구현할 수 있는 환경이 마련되지 않았다. 2015년에는 함수형 프로그래밍의 개념이 실제로 구현될 수 있는 기술적 발전이 이루어졌다.</p>
<p>주요 특징은 거의 모든 것을 순수 함수(Pure function)로 나누어 문제를 해결하는 기법이며, 이는 다음과 같은 장점을 가진다.</p>
<ol type="1">
<li><p>복잡한 문제를 작은 문제로 나누어 각각을 해결하기 위한 함수를 작성함으로써, 코드의 구조가 명확해진다.</p></li>
<li><p>각 함수가 명확한 기능을 가지므로, 코드의 가독성이 높아져 유지보수가 용이해진다.</p></li>
<li><p>상태 변화가 없거나 최소화되어 부작용이 줄어드므로, 코드의 신뢰성과 예측 가능성이 향상된다.</p></li>
</ol>
<p>이러한 특성은 복잡한 소프트웨어 시스템을 더 쉽게 이해하고 관리할 수 있는 방법으로 자리 잡혀 있다.</p>
<p>클린 코드 저자 Rober C.Martin의 함수형 프로그래밍에 대한 의견</p>
<p>깨끗하게 작성하는 방법이란, 할당하는(대입연산자) 문장이 없는 프로그램이다.</p>
<p>코드만 보더라도 이것이 어떤 기능을 하는지 알 수 있도록 만든다.</p>
<p>함수형 프로그래밍은 대입문을 사용하지 않는 프로그래밍 방식이며, 작은 문제를 해결하기 위한 함수를 작성하는 데 중점을 둔다.</p>
<p>예를 들어, 함수는 다음과 같은 두 개의 인자를 가질 수 있다.</p>
<p>첫 번째 인자: 몇까지 반복(iteration)을 돌 것인지 받는 매개변수 두 번째 인자: 전달받은 값을 출력하는 함수</p>
<p>이러한 방식은 함수형 프로그래밍이 무엇을(What) 중시하는지를 보여준다. 즉, 함수형 프로그래밍에서는 ’출력을 하는 함수’를 파라미터로 넘길 수 있는 유연함을 가지고 있다.</p>
<p>이것은 함수형 프로그래밍의 기본 원리 중 하나인 함수를</p>
<p>1급 시민(First-Class Citizen) 또는 1급 객체(First-Class Object)로 관리하는 특징 때문이다.</p>
<p>1급 시민이라는 개념은 다음과 같은 특성을 의미한다.</p>
<ol type="1">
<li><p>함수를 변수에 할당할 수 있다.</p></li>
<li><p>함수를 다른 함수의 인자로 전달할 수 있다.</p></li>
<li><p>함수를 다른 함수의 결과로 반환할 수 있다.</p></li>
</ol>
<p>이러한 특성 덕분에 함수형 프로그래밍에서는 코드의 재사용성과 모듈화가 용이하며, 프로그램의 가독성을 높이는 데 기여한다.</p>
<p>Java에서는 멀티스레딩이 기본적으로 지원되며, 여러 스레드를 활용해 동시에 여러 작업을 처리할 수 있다.</p>
<p>스레드는 하나의 작업 단위로, 자바의 Thread 클래스나 Runnable 인터페이스를 통해 쉽게 만들 수 있다.</p>
<p>스레드 안전성이 보장되는 함수는 여러 스레드가 동시에 접근하더라도 데이터 충돌 없이 동작할 수 있어 동기화(synchronization) 없이도 병렬 처리가 가능합니다.</p>
<p>이로 인해 오버헤드가 줄어들고, 성능이 향상되는 장점이 있다. 이렇게 스레드 안전성이 보장된 코드는 동기화 없이도 각 스레드가 독립적으로 작업을 수행할 수 있어 효율적입니다.</p>
<p>Java에서 synchronized 키워드를 사용해 공통 데이터를 다룰 때 동기화를 적용하여, 여러 스레드가 동시에 접근하지 못하도록 제한할 수 있다.</p>
<p>특히, 동영상 재생처럼 화면, 소리, 자막 등 여러 요소가 동시에 다루어지는 환경에서는 스레드가 공통 데이터를 정확히 처리하지 않으면 원치 않는 값이 기록될 수 있고, 시각적이나 청각적인 어긋남이 발생할 수 있습니다.</p>
<p>synchronized 한 스레드가 잠금(lock)을 걸어 해당 코드 블록을 독점적으로 실행하고, 작업이 완료되면 다른 스레드가 접근할 수 있는 권한을 부여하게 된다.</p>
<ol type="1">
<li><p>데이터 일관성이 유지된다.</p></li>
<li><p>동기화된 처리가 보장되어 여러 스레드가 공통 데이터에 접근할 때 문제가 발생하지 않는다.</p></li>
<li><p>경쟁 상태(race condition)와 같은 문제를 예방할 수 있다.</p></li>
</ol>
<p>하지만, 오버헤드가 발생할 수 있어 성능 저하가 있을 수 있으므로, 필요한 곳에만 신중하게 사용하는 것이 좋습니다.</p>
<p>1급 객체 (First-Class Object) 프로그래밍 언어에서 특정 요소를 변수나 데이터 구조에 담을 수 있고, 함수의 파라미터로 전달하거나 반환값으로 사용할 수 있는 객체</p>
<p>JavaScript와 같은 언어에서 함수는 1급 객체로 취급되며, 이로 인해 함수 자체를 객체처럼 다룰 수 있다.</p>
<p>특징 1. 함수를 변수에 저장하거나 배열에 넣어 사용할 수 있다.</p>
<ol start="2" type="1">
<li><p>함수는 다른 함수의 파라미터로 전달될 수 있다.</p></li>
<li><p>함수는 다른 함수의 반환값으로 사용할 수 있다.</p></li>
<li><p>함수는 할당된 이름에 관계없이 고유하게 식별될 수 있다.</p></li>
</ol>
<p>이러한 특성 덕분에 고차 함수를 쉽게 만들 수 있다.</p>
<p>What It Means to Be Functional</p>
<p>함수는 변수로 사용될 수 있다.</p>
<p>var log = function(message) { console.log(message); }; log(“In JavaScript, functions are variables”);</p>
<p>화살표 함수(arrow function)</p>
<p>const log = message =&gt; { console.log(message); };</p>
<p>함수가 객체의 속성으로 추가될 수 있다.</p>
<p>const obj = { message: “They can be added to objects like variables”, log(message) { console.log(message); } }; obj.log(obj.message);</p>
<p>함수는 배열의 요소로도 추가될 수 있다.</p>
<p>const messages = [ “They can be inserted into arrays”, message =&gt; console.log(message), “like variables”, message =&gt; console.log(message)]; messages<a href="messages[0]">1</a>; messages<a href="messages[2]">3</a>;</p>
<p>함수가 다른 함수에 인수로 전달될 수 있다.</p>
<p>const insideFn = logger =&gt; { logger(“They can be sent to other functions as arguments”); }; insideFn(message =&gt; console.log(message));</p>
<p>함수를 반환하는 함수를 작성하고, 반환된 함수를 호출하는 방식.</p>
<p>const createScream = function(logger) { return function(message) { logger(message.toUpperCase() + “!!!”); }; }; const scream = createScream(message =&gt; console.log(message)); scream(“functions can be returned from other functions”); scream(“createScream returns a function”); scream(“scream invokes that returned function”);</p>
<p>화살표 함수를 사용하여 함수를 반환하는 함수를 간결하게 정의하였다.</p>
<p>const createScream = logger =&gt; message =&gt; { logger(message.toUpperCase() + “!!!”); };</p>
<p>Imperative Versus Declarative</p>
<p>명령형(Imperative) 프로그래밍과 선언형(Declarative) 프로그래밍의 차이를 이해하기 위해, 두 가지 접근 방식을 비교해보겠습니다. 선언형 프로그래밍은 “무엇을 해야 할지”를 설명하는 방식이고, 명령형 프로그래밍은 “어떻게 해야 할지”를 명시적으로 정의하는 방식입니다.</p>
<p>먼저, 명령형 프로그래밍 접근을 살펴봅시다. 여기서는 주어진 문제를 해결하기 위해 순차적인 단계를 명시적으로 정의합니다. 예를 들어, 문자열에서 공백을 하이픈(-)으로 바꾸는 작업을 수행할 때, 명령형 접근은 문자열을 한 문자씩 확인하고, 공백이 있을 경우 하이픈으로 바꾸는 방식입니다. 이 과정은 매우 구체적이고, 각 단계를 명확하게 기술해야 합니다.</p>
<p>공백을 하이픈으로 변환하여 URL 친화적인 문자열을 만드는 코드.</p>
<p>const string = “Restaurants in Hanalei”; let urlFriendly = ““;</p>
<p>for (var i = 0; i &lt; string.length; i++) { if (string[i] === ” “) { urlFriendly +=”-“; } else { urlFriendly += string[i]; } }</p>
<p>console.log(urlFriendly);</p>
<p>자바스크립트의 String 객체에 내장된 replace 메서드를 사용하여 문자열 내의 공백을 하이픈(-)으로 변환하는 방법.</p>
<p>const string = “Restaurants in Hanalei”; const urlFriendly = string.replace(/ /g, “-”); console.log(urlFriendly);</p>
<p>함수형 프로그래밍 패턴을 사용하여 여러 함수를 조합하고, 비동기적으로 데이터를 로드하여 가공하는 과정.</p>
<p>const loadAndMapMembers = compose( combineWith(sessionStorage, “members”), save(sessionStorage, “members”), scopeMembers(window), logMemberInfoToConsole, logFieldsToConsole(“name.first”), countMembersBy(“location.state”), prepStatesForMapping, save(sessionStorage, “map”), renderUSMap ); getFakeMembers(100).then(loadAndMapMembers);</p>
<p>HTML 문서에 새로운 요소를 동적으로 추가하는 예시.</p>
<p>const target = document.getElementById(“target”); const wrapper = document.createElement(“div”); const headline = document.createElement(“h1”);</p>
<p>wrapper.id = “welcome”; headline.innerText = “Hello World”;</p>
<p>wrapper.appendChild(headline); target.appendChild(wrapper);</p>
<p>React를 사용하여 Hello World 메시지를 화면에 렌더링하는 예제</p>
const { render } = ReactDOM; const Welcome = () =&gt; (
<div id="welcome">
<pre><code>    &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/div&gt;</code></pre>
<p>); render(<welcome>, document.getElementById(“target”));</welcome></p>
<p>Functional Concepts</p>
<p>함수형 프로그래밍의 핵심 개념에는 불변성(immutability), 순수성(purity), 데이터 변환(data transformation), 고차 함수(higher-order functions), 재귀(recursion)</p>
<p>불변성(Immutability) 불변성은 데이터를 변경할 수 없는 특성을 의미합니다.</p>
<p>변경하지 않음: 함수형 프로그래밍에서는 데이터가 절대 변경되지 않습니다. 한 번 생성된 데이터는 절대 바뀌지 않으며, 변화를 주고 싶을 때는 새로운 데이터 복사본을 생성하는 방식으로 작업을 수행합니다. 이점: 불변성을 유지하면 프로그램이 예측 가능하고 오류가 발생할 가능성이 줄어듭니다. 왜냐하면, 데이터가 어디서든 변하지 않기 때문에 한 부분에서 다른 부분으로 데이터가 변경되면서 발생하는 사이드 이펙트를 방지할 수 있기 때문입니다.</p>
<p>JavaScript에서 객체를 생성한 예시. color_lawn라는 객체는 잔디의 색상을 나타낸다.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>function rateColor(color, rating) { color.rating = rating; return color; } console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>이 코드에는 불변성이 지켜지지 않고 있습니다. rateColor 함수가 color_lawn 객체를 직접 수정하면서 원래 객체가 변경되는 <strong>부작용(side effect)</strong>이 발생합니다.</p>
<p>불변성을 지키기 위해 원본 데이터를 수정하지 않고 복사본을 생성하여 수정하는 방법.</p>
<p>기존 rateColor 함수는 원본 객체를 직접 수정했지만, 이를 수정하여 원본 객체를 건드리지 않고 새로운 객체를 반환하도록 개선한 방법을 보여준다.</p>
<p>rateColor라는 함수를 사용하여 객체의 속성 값을 변경하는 예제.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>function rateColor(color, rating) { return { …color, rating: rating }; }</p>
<p>console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>이 함수는 기존의 color 객체를 직접 수정하지 않고, …color를 사용하여 원본 객체의 복사본을 생성한 다음 rating 속성만 새로운 값으로 설정합니다.</p>
<p>let color_lawn = { title: “lawn”, color: “#00FF00”, rating: 0 };</p>
<p>const rateColor = (color, rating) =&gt; ({ …color, rating });</p>
<p>console.log(rateColor(color_lawn, 5).rating); console.log(color_lawn.rating);</p>
<p>다음과 같은 배열이 있다고 가정하자. addColor 함수는 배열에 항목을 추가하는 예시로, Array.push 메서드를 사용한다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }];</p>
<p>const addColor = function(title, colors) { colors.push({ title: title }); return colors; }; console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>이 함수는 colors.push()를 통해 원본 배열인 colors를 직접 수정한다. list 배열이 원본 데이터라면 addColor 함수 호출 후 list의 길이가 변경된다.</p>
<p>위 코드는 불변성을 지키지 않으므로, 원본 배열이 변경됩니다.</p>
<p>Array.concat 메서드는 배열을 합치는 역할을 하지만, 원본 배열을 수정하지 않고 새로운 배열을 반환하므로 불변성을 유지할 수 있다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }]; const addColor = (title, array) =&gt; array.concat({ title });</p>
<p>console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>array.concat({ title })는 array 배열의 복사본을 만들고 { title } 객체를 그 뒤에 추가합니다. 결과적으로 원본 배열은 그대로 유지되고, 새로운 배열이 반환됩니다.</p>
<p>이제 list 배열은 수정되지 않고, 새로운 배열만이 길이가 4인 상태로 반환됩니다.</p>
<p>Array.concat 대신 스프레드 연산자(…)를 사용해서도 동일한 결과를 얻을 수 있습니다. 스프레드 연산자를 사용하면 코드가 더욱 간결해집니다.</p>
<p>let list = [{ title: “Rad Red” }, { title: “Lawn” }, { title: “PartyPink” }]; const addColor = (title, list) =&gt; […list, { title }];</p>
<p>console.log(addColor(“Glam Green”, list).length); console.log(list.length);</p>
<p>Pure Functions</p>
<p>순수 함수 부수 효과들을 제거한 함수.</p>
<p>Memory OR I/O의 관점에서 Side Effect가 없는 함수로, 함수의 실행이 외부에 영향을 끼치지 않는다.</p>
<p>장점 함수 자체가 독립적이며, Side-Effect가 없으므로, 스레드(Thread)에 안정성을 보장받을 수 있다.</p>
<p>스레드 안정성을 확보하면 멀티스레드 환경에서 동시 실행 시 발생할 수 있는 데이터 경쟁(race condition), 교착 상태(deadlock) 등의 문제가 방지된다.</p>
<ol type="1">
<li>여러 스레드가 동일한 데이터를 동시에 수정하려 할 때 발생할 수 있는 예기치 않은 오류가 방지된다.</li>
</ol>
<p>스레드 안전성이 있으면 각 스레드가 독립적으로 동작해 코드의 신뢰성이 높아진다.</p>
<ol start="2" type="1">
<li><p>스레드 안전한 코드에서는 병렬 처리가 가능해 프로그램 성능이 개선된다. 각 스레드가 서로 간섭 없이 데이터를 처리할 수 있어 작업을 더 빠르게 완료할 수 있다.</p></li>
<li><p>스레드 관련 오류는 발생 시 찾기 어려운 경우가 많지만, 스레드 안전성을 확보하면 이런 오류 가능성이 줄어들어 디버깅과 유지 보수가 더 쉬워진다.</p></li>
<li><p>스레드 안전한 코드는 여러 프로세서나 코어에서 동시 실행이 가능해 고성능 환경에서도 효과적으로 확장할 수 있다.</p></li>
</ol>
<p>이 함수는 인자를 받지 않으며, 내부적으로 외부 변수 frederick의 속성을 변경한다. selfEducate 함수 호출 후에는 frederick 객체의 canRead와 canWrite 속성이 true로 변경된다.</p>
<p>이 함수는 외부 상태를 변경했으므로, 부작용이 발생하며 순수 함수가 아니다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>function selfEducate() { frederick.canRead = true; frederick.canWrite = true; return frederick; }</p>
<p>selfEducate(); console.log(frederick);</p>
<p>selfEducate 함수가 person이라는 인자를 받아 그 인자 객체의 속성을 변경했다.</p>
<p>selfEducate가 받은 인자를 변경하므로, 그 인자로 무엇이 전달되느냐에 따라 함수의 동작이 달라질 수 있다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>const selfEducate = person =&gt; { person.canRead = true; person.canWrite = true; return person; };</p>
<p>console.log(selfEducate(frederick)); console.log(frederick);</p>
<p>selfEducate 함수는 이제 person이라는 객체를 인자로 받아, 그 객체의 복사본에 canRead와 canWrite 속성만 변경하여 새로운 객체를 반환한다.</p>
<p>이 함수는 외부의 frederick 객체를 수정하지 않고, 새로운 객체를 생성하여 반환하므로, 부작용이 없다. 같은 person 객체가 주어지면 항상 동일한 결과를 반환하므로, 이 함수는 순수 함수가 됩니다.</p>
<p>const frederick = { name: “Frederick Douglass”, canRead: false, canWrite: false };</p>
<p>const selfEducate = person =&gt; ({ …person, canRead: true, canWrite: true });</p>
<p>console.log(selfEducate(frederick)); console.log(frederick);</p>
<p>selfEducate 함수는 frederick 객체를 변경하지 않고 새로운 객체를 반환했으므로, frederick은 여전히 변경되지 않은 상태이다.</p>
<p>Header 함수는 document.createElement와 document.body.appendChild를 사용하여 DOM을 변경한다.</p>
<p>function Header(text) { let h1 = document.createElement(“h1”); h1.innerText = text; document.body.appendChild(h1); } Header(“Header() caused side effects”); 이렇게 DOM을 변경하는 행위는 부수효과(side effect)를 일으킨다. 부수효과가 발생하면 이 함수는 순수 함수가 아니다.</p>
<p>즉, 함수 실행 후 상태가 변경되거나 외부 시스템에 영향을 미친다.</p>
<p>함수형 프로그램의 특징 부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.</p>
<ol type="1">
<li>부수 효과 (Side Effect)</li>
</ol>
<p>다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.</p>
<ol type="1">
<li><p>변수의 값이 변경된다.</p></li>
<li><p>자료 구조를 제자리에서 수정한다.</p></li>
</ol>
<p>불변성 (배열, 리스트, 튜플 ⇨ 여러 개의 데이터를 저장)</p>
<p>데이터 처리에서 원본을 그대로 두고, 사본을 만들어서 수정해야 한다는 점은 매우 중요합니다.</p>
<p>특히 실시간 데이터와 같은 유일한 데이터를 다룰 때 원본을 손상하면 해당 시간대의 의미가 상실될 수 있다.</p>
<p>따라서 정보화를 위해 가공할 때는 반드시 원본을 건들지 않고 사본으로 작업하는 것이 바람직하다.</p>
<ol start="3" type="1">
<li><p>객체의 필드값을 설정한다. (즉, 할당문 금지)</p></li>
<li><p>예외나 오류가 발생하며 실행이 중단된다.</p></li>
<li><p>콘솔 또는 파일 I/O가 발생한다.</p></li>
</ol>
<p>React에서는 UI를 표현할 때 순수 함수를 사용한다. 순수 함수는 부수효과를 일으키지 않고 입력값에 따라 결과값을 반환한다.</p>
<p>React 컴포넌트는 내부에서 DOM을 직접 변경하지 않는다. 대신 JSX나 React의 상태(state) 등을 활용하여 UI를 설명한다.</p>
<p>이 예제에서는 Header 컴포넌트가 순수 함수로 작성되었다.</p>
const Header = props =&gt;
<h1>
{props.title}
</h1>
<p>;</p>
<p>Data Transformations</p>
<p>JavaScript는 데이터를 변형하는 데 필요한 도구를 이미 내장하고 있으며, 그 중 두 가지 중요한 함수는 Array.map과 Array.reduce입니다.</p>
<p>이 함수들을 잘 활용하면 데이터 변환 작업을 효율적으로 처리할 수 있다.</p>
<p>다음은 학교 목록을 가진 배열이다. 이 배열을 쉼표로 구분된 문자열로 변환하려면 Array.join 함수를 사용할 수 있다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; console.log(schools.join(“,”));</p>
<p>불변성을 유지하면서 데이터를 필터링할 수 있다. 학교 이름이 “W”로 시작하는 학교만 선택하는 예제를 보겠다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const wSchools = schools.filter(school =&gt; school[0] === “W”); console.log(wSchools);</p>
<p>불변성을 지키면서 원본 배열을 수정하지 않으며,</p>
<p>school !== cut 조건을 통해 지정한 학교 이름을 제외한 배열을 생성한다. 이어서 join 메서드를 사용하여 새로운 배열을 문자열로 결합하였다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const cutSchool = (cut, list) =&gt; list.filter(school =&gt; school !== cut); console.log(cutSchool(“Washington &amp; Liberty”, schools).join(“,”));</p>
<p>Array.map 메서드는 배열의 각 항목에 대해 변환을 적용하여 새로운 배열을 만든다.</p>
<p>이 메서드는 배열의 각 항목을 변경한 새로운 배열을 생성하며, 원본 배열을 변형하지 않는다. 위의 예제에서는 각 학교 이름에 “High School”을 덧붙여 새로운 배열을 생성한다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const highSchools = schools.map(school =&gt; <code>${school} High School</code>); console.log(highSchools.join(“”));</p>
<p>여기서, schools 배열은 문자열 배열로 되어 있다.</p>
<p>map을 사용하여 각 학교 이름을 name 속성으로 갖는 객체로 변환한 새로운 배열을 생성했다.</p>
<p>결과는 각 학교 이름을 객체로 감싼 배열이 된다.</p>
<p>const schools = [“Yorktown”, “Washington &amp; Liberty”, “Wakefield”]; const highSchools = schools.map(school =&gt; ({ name: school })); console.log(highSchools);</p>
<p>배열 내의 특정 객체를 변경할 때도 map을 사용할 수 있다.</p>
<p>예를 들어, “Stratford”라는 학교 이름을 “HB Woodlawn”으로 변경하고 싶을 때, map을 사용하여 원본 배열을 변경하지 않고 새로운 배열을 만들 수 있다.</p>
<p>const editName = (oldName, newName, list) =&gt; { return list.map(school =&gt; school.name === oldName ? { name: newName } : school ); };</p>
<p>let schools = [ { name: “Yorktown” }, { name: “Stratford” }, { name: “Washington &amp; Liberty” }, { name: “Wakefield” } ];</p>
<p>let updatedSchools = editName(“Stratford”, “HB Woodlawn”, schools); console.log(updatedSchools[1]); console.log(schools[1]);</p>
<p>{ …item, name } 구문은 의도한 대로 name 속성만 업데이트하려고 하는데, 이 코드에서는 새로 정의된 name 속성이 이전 name 값을 덮어쓰게 된다.</p>
<p>실제로 name을 수정하려면 name을 덮어쓰는 게 아니라, name: newValue 형태로 작성해야 한다.</p>
<p>const editName = (oldName, name, arr) =&gt; arr.map(item =&gt; { if (item.name === oldName) { return { …item, name }; } else { return item; } });</p>
<p>이 코드는 editName이라는 함수를 한 줄로 작성한 버전이다.</p>
<p>이 함수의 역할은 특정 배열에서 name 속성이 oldName과 일치하는 객체의 name을 변경한 새로운 배열을 반환하는 것이다.</p>
<p>이 코드에서는 삼항 연산자를 사용하여 조건에 따라 배열을 변환하고 있다.</p>
<p>const editName = (oldName, name, arr) =&gt; arr.map(item =&gt; (item.name === oldName ? { …item, name } : item));</p>
<p>이 코드는 schools라는 객체를 schoolArray라는 배열로 변환하는 예제. 객체의 키와 값을 활용하여 새로운 배열을 만들고, 각 배열 항목은 객체 형태로 만들어진다.</p>
<p>const schools = { Yorktown: 10, “Washington &amp; Liberty”: 2, Wakefield: 5 };</p>
<p>const schoolArray = Object.keys(schools).map(key =&gt; ({ name: key, wins: schools[key] }));</p>
<p>console.log(schoolArray);</p>
<p>이 예제에서는 reduce 함수를 사용하여 배열을 단일 값으로 변환하는 방법을 설명한다. reduce 함수는 배열을 순회하면서 각 요소를 누적하여 최종적인 값을 도출할 수 있는 매우 유용한 도구이다.</p>
<p>const ages = [21, 18, 42, 40, 64, 63, 34];</p>
<p>const maxAge = ages.reduce((max, age) =&gt; { console.log(<code>${age} &gt; ${max} = ${age &gt; max}</code>); if (age &gt; max) { return age; } else { return max; } }, 0);</p>
<p>console.log(“maxAge”, maxAge);</p>
<p>이 코드는 reduce 함수를 사용하여 배열에서 가장 큰 값을 계산하는 간결한 방법.</p>
<p>shorthand if/else 문법을 사용하여 조건문을 간결하게 작성하고, console.log 없이 바로 최대값을 계산한다.</p>
<p>const ages = [-5, -18, -42, -40, -64, -63, -34]; const max = ages.reduce((max, value) =&gt; (value &gt; max ? value : max)); console.log(max);</p>
<p>reduce 메서드를 사용하여 배열을 객체로 변환하는 예제.</p>
<p>이 예제에서는 colors 배열을 key-value 쌍을 가진 객체로 바꾸고 있다. 각 색상 객체의 id 값을 객체의 key로 사용하고, title과 rating을 포함하는 객체를 그에 대응하는 value로 사용한다.</p>
<p>const colors = [ { id: “xekare”, title: “rad red”, rating: 3 }, { id: “jbwsof”, title: “big blue”, rating: 2 }, { id: “prigbj”, title: “grizzly grey”, rating: 5 }, { id: “ryhbhsl”, title: “banana”, rating: 1 }];</p>
<p>const hashColors = colors.reduce((hash, { id, title, rating }) =&gt; { hash[id] = { title, rating }; return hash; }, {});</p>
<p>console.log(hashColors);</p>
<p>reduce 메서드를 사용하여 배열을 다른 형태로 변환하는 방법을 보여준다. 특히, 배열에서 중복되는 값을 제거하고 고유한 값만 남기는 방법에 대해 설명하고 있다.</p>
<p>const colors = [“red”, “red”, “green”, “blue”, “green”];</p>
<p>const uniqueColors = colors.reduce( (unique, color) =&gt; unique.indexOf(color) !== -1 ? unique : […unique, color], [] );</p>
<p>console.log(uniqueColors);</p>
<p>Higher-Order Functions</p>
<p>고차 함수 다른 함수를 인자로 받거나 함수의 결과로 반환하는 함수.</p>
<p>JavaScript의 Array.prototype.map()이나 filter() 같은 메서드는 모두 고차 함수이다.</p>
<p>리액트에서의 활용 함수형 컴포넌트와 useEffect 또는 useCallback 등의</p>
<p>훅(hook)에서 함수를 인자로 전달하거나, 특정 이벤트 발생 시 전달된 함수를 실행하는 방식으로 자주 사용된다.</p>
<p>invokeIf는 조건에 따라 다른 함수를 호출하는 고차 함수입니다.</p>
<p>const invokeIf = (condition, fnTrue, fnFalse) =&gt; condition ? fnTrue() : fnFalse();</p>
<p>const showWelcome = () =&gt; console.log(“Welcome!!!”); const showUnauthorized = () =&gt; console.log(“Unauthorized!!!”);</p>
<p>invokeIf(true, showWelcome, showUnauthorized); invokeIf(false, showWelcome, showUnauthorized);</p>
<p>이 코드는 고차 함수와 클로저를 사용한 예제입니다.</p>
<p>const getFakeMembers = num =&gt; { return new Promise((resolve, reject) =&gt; { const members = Array(num).fill(“Member”); resolve(members); }); };</p>
<p>const userLogs = userName =&gt; message =&gt; console.log(<code>${userName} -&gt; ${message}</code>);</p>
<p>const log = userLogs(“grandpa23”);</p>
<p>log(“attempted to load 20 fake members”);</p>
<p>getFakeMembers(20).then( members =&gt; log(<code>successfully loaded ${members.length} members</code>), error =&gt; log(“encountered an error loading members”) );</p>
<p>Recursion</p>
<p>재귀(recursion) 를 사용하여 숫자를 10부터 0까지 카운트다운하는 함수.</p>
<p>const countdown = (value, fn) =&gt; { fn(value); return value &gt; 0 ? countdown(value - 1, fn) : value; }; countdown(10, value =&gt; console.log(value));</p>
<p>재귀 함수 countdown을 사용하여 숫자를 카운트다운하지만, 지연 시간(delay) 을 두고 실행된다. 이전에 설명한 카운트다운과 비슷하지만, setTimeout을 사용해 호출 간격을 조절한다.</p>
<p>즉, 지정한 시간이 지난 후에야 다음 숫자가 출력된다.</p>
<p>const countdown = (value, fn, delay = 1000) =&gt; { fn(value); return value &gt; 0 ? setTimeout(() =&gt; countdown(value - 1, fn, delay), delay) : value; };</p>
<p>const log = value =&gt; console.log(value); countdown(10, log);</p>
<p>deepPick이라는 함수를 사용하여, 객체 내의 중첩된 속성을 접근하고 가져오는 기능을 구현하고 있다. 이 함수는 객체에서 깊숙이 중첩된 경로(type, data.info.fullname.first 등)를 문자열 형태로 받아 그 값을 반환한다.</p>
<p>const deepPick = (path, obj) =&gt; { return path.split(‘.’).reduce((acc, key) =&gt; acc &amp;&amp; acc[key], obj); };</p>
<p>const dan = { type: “person”, data: { gender: “male”, info: { id: 22, fullname: { first: “Dan”, last: “Deacon” } } } };</p>
<p>console.log(deepPick(“type”, dan)); console.log(deepPick(“data.info.fullname.first”, dan)); console.log(deepPick(“data.info.id”, dan)); console.log(deepPick(“data.gender”, dan)); console.log(deepPick(“data.info.fullname.last”, dan));</p>
<p>deepPick 함수를 재귀적으로 구현하여 객체의 중첩된 속성에 접근하는 방법.</p>
<p>주어진 경로(fields)를 문자열 형태로 입력받아, ‘.’ 으로 구분된 경로를 따라가면서 해당하는 속성 값을 가져온다.</p>
<p>const dan = { type: “person”, data: { gender: “male”, info: { id: 22, fullname: { first: “Dan”, last: “Deacon” } } } };</p>
<p>const deepPick = (fields, object = {}) =&gt; { const [first, …remaining] = fields.split(“.”);</p>
<pre><code>if (!object || !(first in object)) {
    return undefined;
}

return remaining.length
    ? deepPick(remaining.join("."), object[first])
    : object[first];</code></pre>
<p>};</p>
<p>console.log(deepPick(“data.info.fullname.first”, dan));</p>
<p>“data”에 접근 → “info”에 접근 → “fullname”에 접근 → “first”에 접근 → 최종적으로 “Dan”이 반환된다. 따라서 deepPick 함수는 재귀를 사용하여 객체의 중첩된 속성에 안전하게 접근하도록 구현된 함수입니다.</p>
<p>Composition</p>
<p>함수형 프로그래밍에서 작은 순수 함수들을 조합하여 더 큰 기능을 수행하는 방식을 합성이라 한다.</p>
<p>함수형 프로그래밍은 각 함수가 특정 작업에 집중하도록 설계하는데, 이러한 작은 함수들을 서로 연결하여 더 복잡한 로직을 만들 수 있다.</p>
<p>JavaScript에서 체이닝(Chaining)은 함수 합성의 한 예로, 메서드를 연속으로 호출하여 이전 함수의 반환 값을 다음 함수의 입력 값으로 사용하는 방식이다.</p>
<p>문자열의 replace 메서드는 주어진 문자열을 특정 패턴으로 교체하고, 그 결과 문자열을 반환한다. 이 반환 값도 여전히 문자열이므로, replace 메서드를 다시 호출하여 연속적으로 변환할 수 있다.</p>
<p>const template = “hh:mm:ss tt”; const clockTime = template .replace(“hh”, “03”) .replace(“mm”, “33”) .replace(“ss”, “33”) .replace(“tt”, “PM”); console.log(clockTime);</p>
<p>이 코드는 함수 합성(Composition)의 예. 두 개의 함수 civilianHours와 appendAMPM을 합성하여 새로운 함수를 만들고 있다.</p>
<p>const civilianHours = date =&gt; date % 12;<br>
const appendAMPM = time =&gt; <code>${time} AM</code>;</p>
<p>const both = date =&gt; appendAMPM(civilianHours(date));</p>
<p>console.log(both(13));</p>
<p>함수가 많아지면 이런 방식은 확장성과 유지보수성에서 어려움이 있다. 예를 들어, 함수가 20개라면 코드가 매우 복잡해지므로, 가독성과 관리가 힘들어진다.</p>
<p>보다 깔끔하고 확장성 있는 방법은 고차 함수(Higher-order function)인 compose를 사용하는 것이다. compose 함수는 여러 개의 함수를 결합하여 하나의 함수로 만들어 주는 함수이다.</p>
<p>이 방법은 더 많은 함수가 필요할 때 쉽게 추가할 수 있고, 함수의 순서도 변경하기 쉽습니다.</p>
<p>compose를 사용하여 두 개의 함수를 결합하고, 그 결과를 새로운 함수로 만들어 사용하고 있다.</p>
<p>compose는 일반적으로 함수형 프로그래밍에서 여러 개의 함수를 합성하여 새로운 함수를 생성하는 방법이다.</p>
<p>const both = compose( civilianHours, appendAMPM ); both(new Date());</p>
<p>이 함수는 reduce를 사용하여 함수들을 하나씩 실행하면서 그 결과를 이어가게 만듭니다.</p>
<p>const compose = (…fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg);</p>
<p>Putting It All Together</p>
<p>이 코드는 JavaScript로 간단한 시계를 만들기 위한 명령형(Imperative) 해결 방법을 설명하고 있다.</p>
<p>이 시계는 시간, 분, 초를 표시하고, AM/PM 형식으로 표시된 시간을 군용 시간(civilian time) 형식으로 변환하여 출력한다.</p>
<p>각 시간 단위는 항상 두 자릿수로 표시되며, 1 또는 2와 같은 한 자릿수 값에는 선행 0을 추가해야 한다.</p>
<p>또한, 이 시계는 매초마다 업데이트되어 화면에 새로운 시간이 표시된다.</p>
<p>setInterval(logClockTime, 1000);</p>
<p>function logClockTime() { let time = getClockTime(); console.clear(); console.log(time); }</p>
<p>function getClockTime() { let date = new Date(); let time = { hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds(), ampm: “AM” };</p>
<p>if (time.hours == 12) { time.ampm = “PM”; } else if (time.hours &gt; 12) { time.ampm = “PM”; time.hours -= 12; }</p>
<p>if (time.hours &lt; 10) { time.hours = “0” + time.hours; }</p>
<p>if (time.minutes &lt; 10) { time.minutes = “0” + time.minutes; }</p>
<p>if (time.seconds &lt; 10) { time.seconds = “0” + time.seconds; }</p>
<p>return time.hours + “:” + time.minutes + “:” + time.seconds + ” ” + time.ampm; }</p>
<p>시계가 작동됨을 확인.</p>
<p>이 해결책은 잘 동작하고, 주석 덕분에 무엇이 일어나고 있는지 이해할 수 있습니다. 하지만 각 함수가 크고 복잡하며, 각 함수가 여러 일을 하므로 이해하기 어렵고, 주석을 많이 필요로 하며 유지보수가 힘들다.</p>
<p>이제 더 확장 가능하고 유지보수하기 쉬운 함수형 접근 방식을 사용하여 애플리케이션을 개선해보겠습니다.</p>
<p>목표 우리는 애플리케이션의 논리를 더 작은 부분인 함수로 나누고자 합니다. 각 함수는 하나의 작업에만 집중하며, 이를 조합해서 큰 함수로 만들어 시계를 구현할 수 있습니다.</p>
<p>함수형 접근 방식 각 기능을 작은 함수로 나누고, 각 함수는 하나의 일만 하도록 합니다. 이렇게 하면 각 함수가 명확하고, 테스트하기 쉬우며, 재사용 가능하게 됩니다.</p>
<p>함수형 프로그래밍에서는 값보다는 함수를 사용하는 것이 중요합니다. 값이 필요할 때마다 함수를 호출하여 값을 얻습니다.</p>
<p>const compose = (…fns) =&gt; arg =&gt; fns.reduce((composed, f) =&gt; f(composed), arg);</p>
<p>const oneSecond = () =&gt; 1000; const getCurrentTime = () =&gt; new Date(); const clear = () =&gt; console.clear(); const log = message =&gt; console.log(message);</p>
<p>이제 시계를 구현하기 위해 필요한 데이터 변환 함수를 작성해 보겠습니다. 이 세 가지 함수는 Date 객체를 시계를 위한 객체로 변환하는 데 사용됩니다.</p>
<p>변환 함수들 serializeClockTime: Date 객체를 받아 시계 시간을 담고 있는 객체를 반환합니다. 반환되는 객체는 시, 분, 초를 포함합니다. civilianHours: 시계 시간 객체를 받아 시간(hour)을 12시간제로 변환합니다. 예를 들어, 1300은 1:00으로 변환됩니다. appendAMPM: 시계 시간 객체를 받아 오전(AM) 또는 오후(PM)를 붙여주는 함수입니다. const serializeClockTime = date =&gt; ({ hours: date.getHours(), minutes: date.getMinutes(), seconds: date.getSeconds() });</p>
<p>const civilianHours = clockTime =&gt; ({ …clockTime, hours: clockTime.hours &gt; 12 ? clockTime.hours - 12 : clockTime.hours });</p>
<p>const appendAMPM = clockTime =&gt; ({ …clockTime, ampm: clockTime.hours &gt;= 12 ? “PM” : “AM” });</p>
<p>이제 데이터를 변환하는 데 사용할 고차 함수들을 작성하겠습니다. 이 함수들은 데이터를 변경하지 않고 불변성을 유지하면서 시간을 표시하거나 포맷을 변환하는 데 사용됩니다.</p>
<p>고차 함수들 display: target 함수(예: console.log)를 받아서, 시간을 그 함수로 전달하는 함수를 반환합니다. formatClock: 주어진 템플릿 문자열을 사용하여, hours, minutes, seconds, ampm 등의 값으로 시간을 포맷합니다. prependZero: 시계 시간 객체의 특정 key 값을 받아서, 그 값이 10 미만이면 앞에 0을 추가하여 반환합니다. const display = target =&gt; time =&gt; target(time);</p>
<p>const formatClock = format =&gt; time =&gt; format .replace(“hh”, time.hours) .replace(“mm”, time.minutes) .replace(“ss”, time.seconds) .replace(“tt”, time.ampm);</p>
<p>const prependZero = key =&gt; clockTime =&gt; ({ …clockTime, [key]: clockTime[key] &lt; 10 ? “0” + clockTime[key] : clockTime[key] });</p>
<p>이번에는 우리가 만든 모든 함수를 조합하여 틱킹 시계를 만드는 방법을 설명합니다. 이 시계는 1초마다 시간을 업데이트하며, 컴포지션을 사용하여 여러 함수를 결합합니다. 여기서는 compose 함수를 이용해 각 기능을 조합하고, 각 함수들이 하나의 흐름으로 이어지게 만듭니다.</p>
<p>주요 함수들 convertToCivilianTime: clockTime을 인자로 받아서, 시계를 민간 시간(AM/PM 형식)으로 변환하는 함수입니다. civilianHours와 appendAMPM을 차례로 적용하여 시간 객체를 변환합니다. doubleDigits: 민간 시간을 받아서, hours, minutes, seconds 값에 대해 두 자리를 보장하도록 만듭니다. 10보다 작은 값에는 앞에 0을 추가하는 방식입니다. prependZero 함수를 사용하여 이 작업을 수행합니다. startTicking: setInterval을 사용하여 1초마다 반복 실행되는 콜백을 설정합니다. 콜백 함수는 시계가 계속해서 시간을 가져오고, 변환하고, 포맷을 변경한 후 출력하는 역할을 합니다. 이 콜백은 앞서 정의한 함수들을 컴포지션을 통해 결합하여 하나의 흐름으로 만듭니다. const convertToCivilianTime = clockTime =&gt; compose( appendAMPM, civilianHours )(clockTime);</p>
<p>const doubleDigits = civilianTime =&gt; compose( prependZero(“hours”), prependZero(“minutes”), prependZero(“seconds”) )(civilianTime);</p>
<p>const startTicking = () =&gt; setInterval( compose( clear, getCurrentTime, serializeClockTime, convertToCivilianTime, doubleDigits, formatClock(“hh:mm:ss tt”), display(log) ), oneSecond() );</p>
<p>startTicking();</p>


</div>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_04.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(1)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_05.html</link>
  <description><![CDATA[ 




<p>(P.109)</p>
<p>Chapter 4 How React Works</p>
<p>01 리액트 프로젝트 환경을 설정하기.</p>
<ol type="1">
<li>Node.js 최신 버전 설치</li>
</ol>
<p>https://nodejs.org/en</p>
<p>설치 후, 명령 프롬프트(또는 터미널)에서 node -v 와 npm -v 를 입력해 버전 확인이 가능해야 한다.</p>
<ol type="1">
<li>Visual Studio Code (VS Code) 설치</li>
</ol>
<p>https://code.visualstudio.com/</p>
<p>설치 후, VS Code를 열어 React 프로젝트 작업을 시작할 수 있다.</p>
<ol start="3" type="1">
<li>React 프로젝트 생성</li>
</ol>
<p>터미널을 열고 React 프로젝트를 생성하고자 하는 폴더로 이동한 후, 다음 명령어를 입력하여 기본 React 템플릿을 생성하기.</p>
<p>npx create-react-app my-app</p>
<p>이 명령어는 my-app이라는 폴더에 React 프로젝트를 생성하며, 필요한 모든 패키지가 자동으로 설치된다.</p>
<ol start="4" type="1">
<li>프로젝트 실행</li>
</ol>
<p>생성한 프로젝트 폴더로 이동한 후, 다음 명령어를 입력해 로컬 서버에서 앱을 실행하기.</p>
<p>cd my-app npm start 이제 브라우저에서 http://localhost:3000 에 접속하여 React 애플리케이션을 볼 수 있다.</p>
<p>React 프로젝트 작업 폴더를 설정하기. C 드라이브 또는 보조 드라이브에 react class라는 폴더를 만들기.</p>
<p>예시: C:class 또는 다른 드라이브에 react class라는 이름으로 폴더를 생성.</p>
<ol type="1">
<li><p>Visual Studio Code를 열고 상단의 File 메뉴를 클릭하기.</p></li>
<li><p>Open Folder를 선택하고, 방금 만든 react class 폴더를 찾아 선택한다.</p></li>
<li><p>Select Folder 버튼을 누르면 VS Code에서 react class 폴더가 열리고, React 프로젝트를 생성하거나 파일을 추가하여 작업을 시작할 수 있다.</p></li>
</ol>
<p>초기 설치 시 오류가 발생할 수 있다. 1. React 프로젝트 생성 오류 해결</p>
<p>npx create-react-app 명령어 실행 시 오류가 나는 경우, 먼저 기존에 전역으로 설치된 create-react-app 패키지를 제거한다.</p>
<p>// 명령프롬프트(터미널)에 입력하기. npm uninstall -g create-react-app</p>
<ol start="2" type="1">
<li>다시 설치</li>
</ol>
<p>npm install 명령어를 사용해 패키지 설치를 다시 확인하고, 업데이트한다.</p>
<p>npm install</p>
<ol start="3" type="1">
<li>프로젝트 생성 재시도</li>
</ol>
<p>이제 npx create-react-app 명령어로 React 프로젝트를 다시 생성한다. 예시로 blog 라는 프로젝트를 생성하려면 아래와 같이 입력한다.</p>
<p>npx create-react-app blog</p>
<p>실행 후, 아래와 같이 확인 메시지가 나오면 Enter 키를 눌러 설치를 계속 진행한다.</p>
<p>이 과정을 통해 문제가 해결되고 정상적으로 React 프로젝트를 생성할 수 있을 것이다.</p>
<p>React 프로젝트 생성 명령어 작업 폴더에서 React 프로젝트를 생성하는 명령어.</p>
<p>npx create-react-app blog react class 폴더에서 실행하면 blog라는 이름의 폴더에 React 프로젝트가 생성된다.</p>
<p>명령어 구성 요소 설명 1. npx</p>
<p>라이브러리 실행 및 설치 명령어. Node.js가 설치되어 있어야 사용 가능하다.</p>
<ol start="2" type="1">
<li>create-react-app</li>
</ol>
<p>리액트 프로젝트 설정이 완료된 보일러플레이트를 자동으로 만들어 주는 라이브러리. 개발자가 프로젝트 기본 구조를 설정할 필요 없이 빠르게 시작할 수 있다.</p>
<ol start="3" type="1">
<li>blog</li>
</ol>
<p>생성할 프로젝트의 폴더명. blog 폴더가 생성되며, 블로그 개발을 위한 기본 구조가 포함된다.</p>
<p>즉, blog 폴더에 기본적인 React 환경이 준비되어, 바로 블로그 프로젝트 작업을 시작할 수 있다.</p>
<p>시간 지연 React 프로젝트를 생성하는 데 시간이 걸릴 수 있으며, 사용자에 따라 다소 차이가 있을 수 있다.</p>
<p>(나의 경우, 약 5분 정도 걸렸다.)</p>
<p>VS 코드의 왼쪽에 위치한 파일 탐색기에서 프로젝트 폴더와 파일들이 생성되는 것을 확인할 수 있다.</p>
<p>모든 파일 생성이 완료되면 터미널에 “성공적으로 작업이 완료되었습니다”와 같은 메시지가 나타나며, 프로젝트 생성이 완료된 것을 알 수 있다.</p>
<p>설치 완료 생성된 blog 폴더로 이동하여 프로젝트 파일들을 확인할 수 있다.</p>
<p>아래 명령어로 blog 폴더로 이동한다.</p>
<section id="폴더-이동-명령어" class="level1">
<h1>폴더 이동 명령어</h1>
<p>cd blog</p>
<p>프로젝트 폴더 구성 설명 1. node_modules</p>
<p>설치된 라이브러리들이 포함된 폴더.</p>
<p>프로젝트의 모든 종속성(dependencies)을 담고 있으며, package.json에 명시된 라이브러리를 자동으로 설치해 준다.</p>
<ol start="2" type="1">
<li>public</li>
</ol>
<p>공용 파일들이 저장된 폴더로, index.html과 같은 파일이 여기에 포함된다.</p>
<p>리액트 프로젝트에서 실제 HTML 페이지는 이 index.html을 기반으로 하며, 앱이 빌드될 때 이 파일을 활용하여 최종 사용자에게 보여진다.</p>
<ol start="3" type="1">
<li>src</li>
</ol>
<p>실제 개발 작업을 하는 주요 코드들이 들어 있는 폴더.</p>
<p>컴포넌트, 스타일시트, 이미지 등 프로젝트 코드 파일을 포함하며, App.js 등 주요 리액트 컴포넌트들이 여기에 위치한다.</p>
<p>이 구조를 통해 프로젝트 파일들을 효율적으로 관리하고, 나중에 퍼블리시할 때 최적화된 파일들이 빌드된다.</p>
<p>React 프로젝트에서 각 폴더의 역할 (1) public 폴더 정적 리소스 폴더로, 앱이 빌드되거나 프로젝트가 퍼블리시될 때 파일이 압축되지 않고 그대로 유지되는 파일들이 위치한다.</p>
<p>React 프로젝트에서는 기본적으로 public 폴더를 정적 파일들을 위한 폴더로 사용하지만, 가끔 static이라는 이름의 폴더를 따로 추가해 정적 파일을 관리하는 경우도 있다.</p>
<p>public 폴더와 static 폴더의 차이는, 프로젝트의 규모와 필요에 따라 정적 리소스를 구분 관리하고 싶을 때 static 폴더를 사용한다.</p>
index.html React 애플리케이션의 진입점으로, 가장 먼저 로드된다. 모든 React 컴포넌트가 이 HTML 파일 안의
<div id="root">

</div>
<p>태그 안에 렌더링된다.</p>
<p>보통 수정할 일이 거의 없다.</p>
<p>주요 역할 1. 자주 바뀌지 않는 이미지, 파비콘, 폰트 파일 등 변하지 않는 리소스를 보관한다.</p>
<ol start="2" type="1">
<li>이 폴더의 파일들은 빌드 시 별도로 최적화되지 않으며, 그대로 클라이언트에 전달된다.</li>
</ol>
<ol start="2" type="1">
<li>src 폴더</li>
</ol>
<p>코딩 작업의 중심으로, React 애플리케이션의 컴포넌트, 스타일, 로직 등이 여기에 위치한다.</p>
<p>App.js 애플리케이션의 메인 컴포넌트. 전체 앱 구조의 기본을 제공하고, 대부분의 기능 구현이 시작되는 핵심 파일.</p>
index.js App.js를 DOM에 마운트하고 애플리케이션을 브라우저에 연결하는 역할을 한다. ReactDOM.render()로 App 컴포넌트를
<div id="root">

</div>
<p>에 렌더링한다.</p>
<p>주요 역할 1. 컴포넌트 파일, CSS 파일, JavaScript 로직 파일이 위치하며, 애플리케이션의 동적 기능이 모두 여기에서 구현된다.</p>
<ol start="2" type="1">
<li>src 폴더의 파일에서 변경된 내용이 index.html을 통해 화면에 실시간으로 반영되므로, 앱의 동적 업데이트와 유지보수가 용이하다.</li>
</ol>
<p>src 폴더는 React 프로젝트의 핵심이며, 코딩과 개발의 중심이 된다.</p>
<p>프로젝트 실행 npm start 명령어를 입력하여 개발 서버를 시작한다.</p>
<p>코드에 변경 사항이 생기면 자동으로 웹 브라우저에 반영되어 실시간으로 확인할 수 있다.</p>
<p>개발 서버는 기본적으로 Chrome 브라우저를 자동으로 열어주지만, 자동으로 열리지 않는 경우 Chrome 주소창에 localhost:3000 을 입력해 접속할 수 있다.</p>
<p>div 태그 웹 페이지의 레이아웃을 설정하는 기본적인 요소이다. 여러 개의 화면 블록을 나누거나 레이아웃을 조정할 때 주로 사용된다.</p>
<p>CSS 스타일 속성 1. padding</p>
<p>요소 내부 여백으로, 내용(텍스트나 이미지)과 요소 테두리 간의 공간을 조절한다. 패딩 값을 주면 요소 내부의 글이나 이미지가 테두리와의 간격이 넓어진다.</p>
<ol start="2" type="1">
<li>margin</li>
</ol>
<p>요소 외부 여백으로, 요소와 다른 요소 사이의 간격을 설정한다. 마진을 통해 요소들이 서로 떨어져 보이게 만들 수 있다.</p>
<p>이러한 속성을 조정하면서 웹 페이지 레이아웃을 구성하고, 원하는 배치와 간격을 설정할 수 있다.</p>
<p>서버 서비스를 제공하는 쪽으로, 클라이언트(고객)로부터 요청된 데이터를 처리하고 응답한다.</p>
<p>클라이언트 데이터를 요청하는 쪽으로, 일반적으로 웹 브라우저에서 사용자(고객)가 보는 인터페이스이다. React는 클라이언트에서 데이터를 받아 동적으로 화면에 보여주는 역할을 한다.</p>
<p>JavaScript XML (JSX) JavaScript 코드 안에서 HTML 태그처럼 작성할 수 있도록 해주는 문법.</p>
<p>HTML과 JavaScript를 한 파일에서 결합하여 작성하므로, 인터페이스와 로직이 밀접하게 연결된다.</p>
<p>이로 인해, 코드의 가독성과 유지보수성이 높아진다.</p>
<p>데이터 바인딩 변수를 템플릿 문자열({ })을 통해 UI에 연결하여 실시간으로 데이터를 반영하는 것이다. src, id, href와 같은 속성에 변수를 동적으로 연결하여, 콘텐츠가 바뀌면 UI도 즉시 반영되게 할 수 있다.</p>
<p>const logoUrl = “https://example.com/logo.png”; return <img src="https://shinjihan.github.io/studylog/pd/re/{logoUrl}" alt="로고 이미지">;</p>
<p>사용 예시: 네이버 로고 기념일에 따라 로고가 바뀌는 것처럼, 디자이너가 제공하는 기념일 로고 이미지를 서버에 업로드하고, React 코드에서 해당 이미지를 불러온다.</p>
<p>이름이나 URL을 바꾸기만 하면 새로운 로고가 적용되므로, 서버와 클라이언트에서 데이터만 업데이트해도 쉽게 반영된다.</p>
<p>React에서 style 속성은 객체 형태로 넣어야 하며, { } 안에 작성한다. 이처럼 React는 JSX와 데이터 바인딩을 통해 동적이고 유연하게 UI를 생성하고 관리할 수 있다.</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_05.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(2)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_06.html</link>
  <description><![CDATA[ 




<p>대표적인 명령어 리눅스에서는 명령어와 옵션을 활용해 다양한 작업을 수행한다.</p>
<p>cd // (change directory, 디렉토리 이동) md // (make directory, 디렉토리 생성) ..cd // 상위 디렉토리로 이동 지난 시간에는 함수와 이미지가 데이터 바인딩을 통해 연결될 수 있다는 내용까지 다루었다.</p>
<p>JSX React에서 JavaScript와 HTML을 결합한 문법으로, 컴포넌트 안에서 HTML처럼 보이는 코드를 작성할 수 있게 해준다.</p>
<p>JSX를 사용하면 JavaScript의 표현력과 HTML의 직관성을 동시에 활용할 수 있어, UI 구성 요소를 작성하는 데 편리하다.</p>
<p>변환 과정 JSX는 브라우저에서 직접 실행되지 않으므로, 실행 전에 Babel과 같은 도구가 JSX 코드를 JavaScript로 변환한다.</p>
<p>이를 통해 브라우저는 일반 JavaScript로 처리된 코드를 실행하게 된다.</p>
<p>XML/HTML과의 차이점 HTML에서는 class 속성을 사용하지만, JSX에서는 className을 사용해야 한다. 이처럼 JSX는 React가 브라우저와 상호작용할 수 있도록 설계된 JavaScript 확장 문법으로, 순수 HTML과는 다른 방식으로 동작한다.</p>
<p>JSX는 코드 가독성을 높이고, 컴포넌트 기반 UI를 쉽게 구성할 수 있도록 도와준다. 또한 JavaScript의 로직과 HTML 형태의 UI를 결합해 하나의 컴포넌트 안에서 관리할 수 있게 한다.</p>
<p>React 요소 React 애플리케이션의 기본 구성 요소. 컴포넌트나 HTML처럼 화면에 표시될 수 있는 단위로, React 요소는 JSX 문법으로 작성된다.</p>
<p>JavaScript 삽입 JSX 내부에서 JavaScript 표현식을 사용하려면 중괄호 <code>{}</code>를 사용한다.</p>
<p>예를 들어, <code>&lt;h1&gt;{user.name}&lt;/h1&gt;</code>에서 <code>{user.name}</code>은 JavaScript 표현식이며, 이를 통해 동적으로 데이터를 렌더링할 수 있다.</p>
<p>자바스크립트 이름 작성 방식 낙타체 (Camel Case) 여러 단어로 구성된 변수나 함수 이름에서 첫 단어는 소문자로 시작하고, 두 번째 단어부터는 첫 글자가 대문자여야 하는 규칙이다.</p>
<p>예를 들어, <code>myDogName</code>, <code>userAge</code> 등이 낙타체로 작성된 이름이다.</p>
<p>언더스코어 방식 때로는 언더스코어(_)를 변수명 앞이나 중간에 넣어 작성하는 경우도 있지만, JavaScript에서는 주로 낙타체를 사용하는 것이 관례이다.</p>
<p>오류 주의 JSX에서는 HTML 속성을 camelCase로 작성해야 한다. 예를 들어, HTML에서는 <code>class</code>를 사용하지만, JSX에서는 <code>className</code>을 사용해야 한다.</p>
<p><code>class</code>를 사용하면 오류가 발생한다.</p>
<ol type="1">
<li><p>자체 종료 태그 예를 들어, <code>&lt;img /&gt;</code>와 같이 내용이 없는 태그는 자체 종료 태그로 사용할 수 있다. 하지만 내용이 있을 경우에는 <code>&lt;img&gt;&lt;/img&gt;</code>와 같이 여닫는 태그를 사용해야 한다.</p></li>
<li><p>배열 매핑: 리스트 렌더링 배열을 렌더링하려면 JavaScript의 <code>map()</code> 함수를 사용한다. <code>map()</code> 함수는 배열의 각 항목을 처리하여 새로운 배열을 반환하는 함수이다.</p></li>
</ol>
const items = [‘One’, ‘Two’, ‘Three’]; const list = items.map(item =&gt;
<li>
{item}
</li>
<p>); 이 코드는 <code>items</code> 배열의 각 항목을 <code>&lt;li&gt;</code> 요소로 매핑하고, 그 결과를 <code>list</code>에 저장한다.</p>
<p>매개변수 <code>item</code>은 배열의 각 항목을 의미한다. <code>li</code>는 <code>list item</code>의 약자로, <code>&lt;li&gt;</code> 태그를 사용하여 각 항목을 리스트 아이템으로 렌더링한다.</p>
<p>useState() React에서 자주 변경되는 데이터를 다룰 때는 useState를 사용하여 상태를 관리하는 것이 일반적인 방법이다.</p>
<p>반면, 자주 변경되지 않는 데이터는 일반 변수를 사용하여 저장한다.</p>
<p>사용 방법 useState는 상태(state)를 관리하기 위해 React에서 제공하는 내장 함수를 사용한다.</p>
<p>이 함수를 사용하면 컴포넌트 내에서 데이터를 상태로 저장하고, 해당 상태가 변경될 때마다 컴포넌트가 재렌더링된다.</p>
<p>예를 들어, const [count, setCount] = useState(0);는 count라는 상태 변수를 만들고, 이 상태를 변경할 수 있는 setCount 함수를 생성한다.</p>
<p>이 함수는 호출의 결과를 [변수, 함수]형태의 배열을 반환해준다.</p>
<p>useState(0)에서 0은 상태의 초기값을 설정하는 값이다.</p>
<p>setCount는 count 값을 변경할 때 사용된다. 버튼 클릭 시 setCount(count + 1)을 호출하여 count를 1씩 증가시킨다.</p>
<p>실습 이 코드에서는 React의 기능을 사용하여 간단한 블로그 스타일의 컴포넌트를 만들고 있으며, 버튼을 클릭할 때마다 카운트가 증가하는 인터랙티브한 기능이 포함되어 있다.</p>
<p>import React, { useState } from ‘react’; import logo from ‘./logo.svg’; import ‘./App.css’;</p>
<p>function App() { let [글제목, 글제목변경] = useState(“남자 코드 추천”); let posts = “대진대 고기 맛집”; const [count, setCount] = useState(0);</p>
return (
<div data-classname="App">
<pre><code>  &lt;div className="black-nav"&gt;
    &lt;div&gt;블로그 BLOG&lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h3&gt;{글제목}&lt;/h3&gt;
      &lt;p&gt;11월 4일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;p&gt;현재 카운트: {count}&lt;/p&gt;
    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;카운트 증가&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>
<ol type="1">
<li>useState Hook 함수형 컴포넌트에서 상태를 관리하기 위한 React의 Hook 아래 코드에서는 두 개의 상태 변수가 선언되어 있다.</li>
</ol>
<p>let [글제목, 글제목변경] = useState(“남자 코드 추천”); const [count, setCount] = useState(0);</p>
<ol type="1">
<li>글제목</li>
</ol>
<p>문자열 “남자 코드 추천”을 기본값으로 가지는 상태 변수.</p>
<ol start="2" type="1">
<li>글제목변경</li>
</ol>
<p>글제목의 값을 업데이트할 때 사용하는 함수.</p>
<ol start="3" type="1">
<li>count</li>
</ol>
<p>숫자 0을 기본값으로 가지는 상태 변수이며, 카운트 값이 저장된다.</p>
<ol start="4" type="1">
<li>setCount</li>
</ol>
<p>count의 값을 업데이트하는 함수.</p>
<p>이 함수는 5번에서 익명함수로 호출하여 사용된다.</p>
<p>함수 사용의 이유는 재사용성 때문이며, 이때 화살표 함수나 익명 함수가 사용된다. 익명 함수나 고차 함수는 고급 JavaScript의 중요한 개념으로, 코드의 간결함과 재사용성을 높여준다.</p>
<p>비슷한 요구사항이나 구조, 패턴을 해결하는 방식은 디자인 패턴으로 불리며, 이를 통해 코드의 유지보수성과 확장성을 향상시킬 수 있다.</p>
<p>반응형 웹은 사용자의 상호작용에 따라 동적으로 UI가 변하는 웹을 의미하며, 이는 현대 웹 개발의 추세입니다. React는 이러한 동적인 UI 업데이트를 손쉽게 구현할 수 있도록 도와주는 라이브러리입니다. React를 사용하면, 상태 변화에 따라 UI가 실시간으로 반영되어 반응형 웹 개발을 간단하게 할 수 있다.</p>
<ol start="2" type="1">
<li><p>JSX React가 화면에 표시할 HTML 요소의 구조와 내용을 정의하는 것으로, 코드에서 return 문 내부에 작성된 내용이 컴포넌트의 UI를 렌더링하는 부분이다.</p></li>
<li><p>div 요소 및 클래스명</p></li>
</ol>
<div data-classname="App">
<div data-classname="black-nav">
<div>
블로그 BLOG
</div>
</div>
…
</div>
<p>최상위 div에 “App” 클래스가 적용되어 App.css 파일에 정의된 스타일이 적용된다. “black-nav”라는 클래스를 가지는 div가 블로그의 상단 내비게이션 역할을 한다.</p>
<ol start="4" type="1">
<li>데이터 바인딩 및 JSX 사용
<div data-classname="list">
<h3 class="anchored">
{글제목}
</h3>
<p>
11월 4일 발행
</p>
</div>
h3 태그에서 {글제목}을 사용하여 데이터 바인딩을 한다. 이로 인해 글제목의 값 “남자 코드 추천”이 화면에 표시된다.</li>
</ol>
<p>데이터 바인딩을 위해 글제목 변수를 중괄호 { }로 감싸 JSX 내에서 사용한다.</p>
<ol start="5" type="1">
<li>상태 업데이트 및 이벤트 핸들링</li>
</ol>
<div>
<p>
현재 카운트: {count}
</p>
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;카운트 증가
</div>
<button>
<p>요소의 onClick 이벤트 핸들러에서 setCount를 사용하여 count 값을 1씩 증가시킨다.</p>
<p>버튼이 클릭될 때마다 setCount(count + 1)을 호출하여 count 상태를 업데이트하고, React는 count의 변경을 감지해 p 태그 안의 {count}를 자동으로 업데이트한다.’</p>
<p>전체 실습 코드 import React, { useState } from ‘react’; import logo from ‘./logo.svg’; import ‘./App.css’;</p>
<p>function App() { // useState의 초기값을 배열로 설정 let [글제목, 글제목변경] = useState([“소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석”]); let posts = “대진대 고기 맛집”; const [count, setCount] = useState(0);</p>
return (
<div data-classname="App">
<pre><code>  &lt;div className="black-nav"&gt;
    &lt;div&gt;대진대 맛집 소개&lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
    &lt;h3&gt;{글제목[0]}&lt;span onClick={() =&gt; {setCount(count + 1)}}&gt;👍&lt;/span&gt;{count}&lt;/h3&gt;
      &lt;p&gt;11월 4일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h3&gt;{글제목[1]}&lt;span onClick={() =&gt; {setCount(count + 1)}}&gt;👍&lt;/span&gt;{count}&lt;/h3&gt;
      &lt;p&gt;11월 5일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h3&gt;{글제목[2]}&lt;span onClick={() =&gt; {setCount(count + 1)}}&gt;👍&lt;/span&gt;{count}&lt;/h3&gt;
      &lt;p&gt;11월 6일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>


</div>
</button></div>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_06.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(3)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_07.html</link>
  <description><![CDATA[ 




<p>React Component UI의 구성 요소.</p>
<p>재사용 가능하고 독립적인 UI를 표현하는 함수 또는 클래스. 컴포넌트 기반 구조를 통해 UI를 작고 관리하기 쉬운 단위로 나눌 수 있어 유지보수성이 높아진다.</p>
<p>IT 관련 업계에서 사용되는 용어는 종종 부품이나 퍼즐 조각으로 비유할 수 있다. 각 부품이나 조각은 독립적으로 기능을 하면서 전체 시스템의 일부분을 이루는 역할을 한다. 이러한 방식은 복잡한 시스템을 구성하고 유지보수하기 위해 필수적이다.</p>
<p>파이썬에서는 이를 모듈로 부르며, 각 기능을 모듈 단위로 나누어 관리한다. 자바에서는 패키지라는 개념을 사용하여, 관련된 클래스를 묶어 관리한다. 이와 같은 구조적 분리는 코드를 더 읽기 쉽게 하고, 유지보수와 확장성을 향상시킨다.</p>
<p>리액트(React)는 이러한 개념을 컴포넌트 단위로 나누어 관리하는 방식으로, UI를 더 작은 부품으로 나누어 관리하고 재사용할 수 있게 해줍니다. 이로 인해 복잡한 애플리케이션을 보다 효율적으로 개발할 수 있다.</p>
<p>또한, C 언어에서는 분리 컴파일을 사용하여 소스 코드를 독립적인 단위로 나누고, 자바에서는 클래스를 사용하여 객체 지향적으로 코드의 재사용성과 모듈화를 제공한다. 이러한 방식들은 코드의 복잡도를 줄이고, 협업 시 충돌을 방지하며, 각 기능을 독립적으로 테스트하고 관리할 수 있게 해준다.</p>
<p>Component 종류 1. Functional Components (함수형 컴포넌트) 함수 형태로 정의된 컴포넌트로, 주로 useState, useEffect와 같은 React Hook을 사용해 상태와 생명주기를 관리한다.</p>
<ol start="2" type="1">
<li>Class Components (클래스형 컴포넌트) ES6 클래스 문법을 사용해 정의되며, this.state와 this.setState를 통해 상태를 관리하고, 생명주기 메서드를 제공한다.</li>
</ol>
<p>생명주기, 온크레이트, 다른 페이지로 띄울 때, 온퍼지 일시 정지 상태 다시 원래 상태로 돌아올 때 까지의 상태.</p>
<p>(React 16.8 이후로는 주로 함수형 컴포넌트를 권장한다.)</p>
<p>Props 부모 컴포넌트에서 자식 컴포넌트로 전달하는 데이터. 컴포넌트 간의 데이터 전달을 담당하며 변경할 수 없는(read-only) 값</p>
<p>State 컴포넌트 내에서 관리되는 동적 데이터. 상태가 변경될 때마다 컴포넌트가 다시 렌더링된다.</p>
<p>Hooks 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle)를 관리할 수 있게 해주는 기능이다. 이전에는 클래스형 컴포넌트에서만 사용할 수 있었던 상태 관리와 생명주기 관련 기능을 함수형 컴포넌트에서도 사용할 수 있도록 만들어준다.</p>
<p>“Hooks”라는 이름은 후크나 갈고리를 의미하는데, 이는 말 그대로 어떤 기능을 “훅”으로 걸어 넣는다는 느낌으로 비유할 수 있다.</p>
<p>외투의 후크: 외투의 끝부분에 달린 후크처럼, Hook은 특정 기능을 기존 코드에 “걸어놓는” 역할을 한다. 지퍼의 끝부분: 후크는 지퍼처럼, 여러 기능을 하나의 “구조” 안에서 잘 맞물리게 해준다. 피터팬의 후크 선장: 피터팬에서 악역으로 등장하는 후크 선장은 갈고리 손을 가진 인물로 알려져 있다.</p>
<p>주요 React Hooks 1. useState</p>
<p>상태를 관리하기 위한 기본 Hook 함수형 컴포넌트에서 로컬 상태를 선언하고 관리할 수 있게 합니다.</p>
<p>초기값을 인자로 받아 상태값과 상태 갱신 함수 [state, setState]를 반환한다.</p>
<ol start="2" type="1">
<li>useEffect</li>
</ol>
<p>컴포넌트가 렌더링될 때나 상태가 변경될 때 특정 코드를 실행할 수 있게 하는 Hook. 두 번째 인자로 의존성 배열을 받으며, 이 배열에 명시된 값이 변경될 때마다 콜백 함수가 재실행된다.</p>
<p>주로 데이터 가져오기, 구독, 타이머 설정 등에 사용된다.</p>
<ol start="3" type="1">
<li>useContext</li>
</ol>
<p>Context API와 함께 사용하여 컴포넌트 트리 전반에 데이터를 전달한다.</p>
<p>props를 계속 전달할 필요 없이 하위 컴포넌트에서 바로 데이터에 접근할 수 있어 전역 상태 관리에 유용하다.</p>
<p>고급 Hooks 1. useReducer</p>
<p>상태를 관리하기 위해 useState보다 복잡한 로직이 필요할 때 사용하는 Hook.</p>
<p>리듀서 함수와 초기 상태를 받아 상태와 디스패치 함수를 반환하며, Redux와 유사한 패턴으로 상태를 관리할 수 있다.</p>
<ol start="2" type="1">
<li>useMemo</li>
</ol>
<p>특정 값의 계산을 메모이제이션하여, 의존성이 변하지 않는 한 동일한 값을 반환하도록 한다. 계산 비용이 큰 함수의 결과를 캐싱하여 성능 최적화에 유용하다.</p>
<ol start="3" type="1">
<li>useCallback</li>
</ol>
<p>메모이제이션된 콜백 함수를 반환한다.</p>
<p>특정 함수가 재생성되는 것을 방지하고, 주로 의존성 배열이 변하지 않는 한 동일한 함수를 재사용하도록 해 성능을 개선할 수 있습니다.</p>
<p>이 Hook들을 조합해 복잡한 상태 관리와 최적화 작업을 효율적으로 수행할 수 있다.</p>
<p>useEffect로 대체하기 함수형 컴포넌트에서는 생명주기 메서드를 직접 사용할 수 없으므로, useEffect Hook을 통해 각 생명주기 단계에서 필요한 동작을 구현한다.</p>
<ol type="1">
<li>Mounting 컴포넌트가 처음 DOM에 추가되는 단계.</li>
</ol>
<p>componentDidMount 메서드를 사용해 첫 번째 렌더링 후 실행할 코드를 작성한다.</p>
<p>함수형 컴포넌트에서는 useEffect의 빈 배열 []을 의존성 배열로 설정하여, 컴포넌트가 처음 렌더링될 때 한 번만 실행되도록 한다.</p>
<ol start="2" type="1">
<li>Updating 상태나 props가 변경될 때 컴포넌트가 업데이트되는 단계.</li>
</ol>
<p>componentDidUpdate 메서드를 사용해 상태나 props가 변경될 때 실행할 코드를 작성한다.</p>
<p>함수형 컴포넌트에서는 useEffect의 의존성 배열에 특정 상태나 props를 넣어 해당 값이 변경될 때마다 코드가 실행되도록 설정한다.</p>
<ol start="3" type="1">
<li>Unmounting 컴포넌트가 DOM에서 제거되는 단계.</li>
</ol>
<p>componentWillUnmount 메서드를 사용해 컴포넌트가 제거되기 직전에 실행할 코드를 작성한다.</p>
<p>함수형 컴포넌트에서는 useEffect의 반환 함수에 cleanup 코드를 작성하여 컴포넌트가 언마운트될 때 해당 코드가 실행되도록 한다.</p>
<p>모바일 앱이나 복잡한 웹 애플리케이션의 경우, 생명주기는 8단계로 나눌 수 있다.</p>
실습
<div data-classname="modal">
<h2 class="anchored">
제목
</h2>
<p>
날짜
</p>
<p>
상세내용
</p>
</div>
<p>React에서 HTML 코드를 줄이고 재사용하기 위해 컴포넌트를 활용할 수 있다. 특히 함수형 컴포넌트는 간단하게 특정 UI를 캡슐화하고, 다른 곳에서 쉽게 사용할 수 있어 유용하다.</p>
<p>컴포넌트 작성 방법 1. 함수 이름 짓기 함수형 컴포넌트의 이름은 대문자로 시작해야 한다. (예시: Modal, Header, Footer 등)</p>
<ol start="2" type="1">
<li>HTML 코드 축약 축약할 HTML 코드를 return() 안에 작성한다. 여러 태그가 있을 경우, 반드시 하나의 루트 태그로 감싸야 한다.</li>
</ol>
여러 태그를 감싸기 위해
<div>
<p>태그를 사용할 수 있으며, 빈 태그(Fragment) &lt;&gt;&lt;/&gt;를 사용할 수도 있다. &lt;&gt;&lt;/&gt;(Fragment)을 사용할 경우 불필요한 HTML 구조가 생기지 않아 코드가 깔끔해진다.</p>
<ol start="3" type="1">
<li>컴포넌트 적용하기 컴포넌트를 원하는 위치에 &lt;컴포넌트명 /&gt; 형태로 작성하여 삽입한다.</li>
</ol>
<p>위 규칙을 지키지 않으면 컴포넌트가 제대로 렌더링되지 않거나 에러가 발생할 수 있다.</p>
실습2
</div>
<pre><code>  &lt;Modal/&gt;      
&lt;/div&gt;</code></pre>
); } function Modal(){ return(
<div data-classname="modal">
<pre><code>&lt;h2&gt;제목&lt;/h2&gt;
&lt;p&gt;날짜&lt;/p&gt;
&lt;p&gt;상세내용&lt;/p&gt;</code></pre>
</div>
<p>); }</p>
<p>export default App;</p>
<p>반복적으로 사용되는 HTML UI 덩어리들을 컴포넌트로 만들어서 관리하는 것은 매우 효율적이다. 컴포넌트를 재사용 가능한 작은 단위로 만들면 코드 유지보수가 용이해지고, UI 요소를 다른 페이지에서도 손쉽게 사용할 수 있기 때문이다.</p>
<p>장점 동일한 UI를 여러 페이지에서 사용하려면 컴포넌트를 만들어 재사용할 수 있다. 한 번 정의한 컴포넌트는 여러 곳에서 사용할 수 있어 코드 중복을 줄일 수 있다. 앱을 여러 작은 컴포넌트로 분리하여 앱을 더 구조적으로 관리할 수 있다.</p>
<p>단점 1. State 관리 복잡성</p>
<p>컴포넌트에서 상태(state)를 관리할 때, 상위 컴포넌트와 하위 컴포넌트 간의 데이터 흐름이 복잡해질 수 있다.</p>
<p>여러 컴포넌트에서 상태를 변경해야 할 때, 상태를 올바르게 관리하는 것이 중요한데, useState와 props를 잘 이해하고 사용해야 한다.</p>
<ol start="2" type="1">
<li>props를 통한 상태 전달</li>
</ol>
<p>상위 컴포넌트에서 관리하는 상태를 하위 컴포넌트에서 사용하려면 props를 사용해야 한다. 이때, props를 통해 전달된 데이터는 하위 컴포넌트에서 변경할 수 없고, 부모 컴포넌트에서만 업데이트할 수 있다. 이로 인해 상태 업데이트가 필요한 경우, 상태 변경을 위한 함수를 props로 전달해야 할 수도 있다.</p>
<pre><code>  &lt;/div&gt;
  &lt;Modal title = {글제목[0]}/&gt;      
&lt;/div&gt;</code></pre>
); } function Modal(props){ return(
<div data-classname="modal">
<pre><code>  &lt;h2&gt;{props.title}&lt;/h2&gt;
  &lt;p&gt;날짜&lt;/p&gt;
  &lt;p&gt;상세내용&lt;/p&gt;</code></pre>
</div>
<p>); }</p>
<p>export default App;</p>
<p>import React, { useState } from ‘react’; import ‘./App.css’;</p>
<p>function App() { let [글제목, 글제목변경] = useState([“소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석”]); let [따봉, 따봉변경] = useState(0); let [선택된제목, 선택된제목변경] = useState(글제목[0]); // 초기값 설정</p>
return (
<div data-classname="App">
<pre><code>  &lt;div className="black-nav"&gt;
    &lt;div&gt;대진대 맛집 소개&lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; 선택된제목변경(글제목[0])}&gt;
        {글제목[0]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 4일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; 선택된제목변경(글제목[1])}&gt;
        {글제목[1]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 5일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; 선택된제목변경(글제목[2])}&gt;
        {글제목[2]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 6일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  {선택된제목 &amp;&amp; &lt;Modal title={선택된제목} /&gt;}
&lt;/div&gt;</code></pre>
<p>); }</p>
function Modal(props) { return (
<div data-classname="modal">
<pre><code>  &lt;h2&gt;{props.title}&lt;/h2&gt;
  &lt;p&gt;발행 날짜: {props.title === '소고기 맛집-토방' ? '11월 4일' : props.title === '불고기 맛집-마포숯불갈비' ? '11월 5일' : props.title === '한식 맛집-백만석' ? '11월 6일' : ''}&lt;/p&gt;
  &lt;p&gt;이곳은 {props.title}에 대한 상세내용입니다.&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>
<p>이런 식으로 컨퍼넌트를 만들어서 관리할 수 있다.</p>


</div>
</div>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_07.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(4)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_08.html</link>
  <description><![CDATA[ 




<p>1 . 동적인 UI 만들기 사용자가 발행한 글 다루기 생성하는 기능과 삭제하는 기능</p>
<p>function App() { let [글제목, 글제목변경] = useState([“소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석”]); let [따봉, 따봉변경] = useState(0); let [선택된제목, 선택된제목변경] = useState(글제목[0]); // 초기값 설정 let [modal, setModal] = useState(false);</p>
<p>if 또는 for와 같은 기본 문법을 사용할 수 없음,</p>
<pre><code>  { 
    // 이 영역은 html 코드로 작성하는 곳으로 기본문법 if를 쓸 수 없다.
    (modal == true) ? &lt;Modal/&gt; : null
  }</code></pre>
<p>삼항 연산자만 사용가능 ? 또는 : 파이썬에는 없고, 자바와 C언어에서 쓰인다.</p>
<p>(조건식) ? (참) : (거짓)으로 구성되어 있다.</p>
<p>앱을 만들기 어려운 이유가 여러 개의 문법을 동시에 사용해야 되기 때문이다. DB 연동 및 쿼리 이용하는 것까지가 기본적으로 되어 있어야 한다.</p>
<p>프로파게이션: 전파하다, 즉, 전파를 막다, 이벤트 버블링</p>
<p>코드가 많으면 관리하기 어려움, 이를 줄여주는 map함수를 통해 자동으로 코드를 줄일 수 있다.</p>
<p>글제목이름 이라는 변수이름으로 만듦 글제목이라는 변수로 상태이름을 저장한 것임, 괄호 안에 작성, 맵이 처리가 될 때 처리</p>
<p>import React, { useState } from ‘react’; import ‘./App.css’;</p>
// Modal 컴포넌트 정의 function Modal() { return (
<div data-classname="modal">
<pre><code>  &lt;h2&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>); }</p>
<p>function App() { let [글제목, 글제목변경] = useState([“소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석”]); let [따봉, 따봉변경] = useState(0); let [선택된제목, 선택된제목변경] = useState(글제목[0]); // 초기값 설정 let [modal, setModal] = useState(false);</p>
return (
<div data-classname="App">
<pre><code>  &lt;div className="black-nav"&gt;
    &lt;div&gt;블로그&lt;/div&gt;  
  &lt;/div&gt;

  {
    /*&lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;
        {글제목[0]} &lt;span onClick={(e) =&gt; {e.stopPropagation(); 따봉변경(따봉 + 1)}}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 4일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;{글제목[1]}
        {글제목[1]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 5일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;{글제목[1]}
        {글제목[2]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 6일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;*/
  }

  {글제목.map(function (a, i) {
    return (
      &lt;div className='list' key={i}&gt;
        &lt;h4 onClick={() =&gt; { setModal(true); }}&gt;
          {a} 
          &lt;span onClick={(e) =&gt; { e.stopPropagation(); 따봉변경(따봉 + 1); }}&gt;👍&lt;/span&gt;
          {따봉}
        &lt;/h4&gt;
        &lt;p&gt;11월 {i + 4}일 발행&lt;/p&gt;
        &lt;hr /&gt;
      &lt;/div&gt;
    );
  })}

  { 
    // 이 영역은 html 코드로 작성하는 곳으로 기본문법 if를 쓸 수 없다.
    (modal == true) ? &lt;Modal/&gt; : null
  }    

  &lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>
<p>앱이 부모 모달이 자식</p>
<p>•<input type="“”/"> Type –text :텍스트 입력상자 –range : 범위 입력상자 –checkbox :선택 입력상자 –date :날짜 입력상자</p>
<p>•입력상자의 내용이 변경되면 –onchange={() - &gt; { } }</p>
<p>•입력된 내용을 가져오고 싶을땐 –onchange={(e) - &gt; {console.log(e.target.value) } }</p>
<p>function App() { let [글제목, 글제목변경] = useState([“소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석”]); let [따봉, 따봉변경] = useState(0); let [선택된제목, 선택된제목변경] = useState(글제목[0]); // 초기값 설정 let [modal, setModal] = useState(false); let [입력값, 입력값변경] = useState(’’)</p>
<p>입력값 state에 저장하기 - 입력값을 처리하기 위한 state생성 버튼에 이벤트 등록 이벤트 등록 코드 작성하기 –원본 state를 그대로 사용하면 안됨!! –사본 state를 만들기 –사본의 첫부분에 입력된 내용을 추가하기(unshift()) –state변경함수로 상태 변경하기</p>
<p>응용 – 발행된 글 아래에 삭제 버튼을 추가하기. 또한, 발행된 글은 발행된 날짜로 나오도록 추가.</p>
<p>import React, { useState } from ‘react’; import ‘./App.css’;</p>
<p>function App() { let [글제목, 글제목변경] = useState([ “소고기 맛집-토방”, “불고기 맛집-마포숯불갈비”, “한식 맛집-백만석” ]); let [따봉, 따봉변경] = useState([0, 0, 0]); // 각 글에 대한 따봉을 배열로 관리 let [선택된제목, 선택된제목변경] = useState(글제목[0]); // 초기값 설정 let [modal, setModal] = useState(false); let [입력값, 입력값변경] = useState(’’);</p>
<p>// 제목 추가하는 함수 const handleAddTitle = () =&gt; { let copy = […글제목]; copy.unshift(입력값); // 입력값을 맨 앞에 추가 글제목변경(copy); // 상태 업데이트 따봉변경([0, …따봉]); // 새로 추가된 글에 대한 따봉 초기화 };</p>
return (
<div data-classname="App">
<pre><code>  &lt;div className="black-nav"&gt;
    &lt;div&gt;블로그&lt;/div&gt;  
  &lt;/div&gt;

  {/* 제목 추가 */}
  &lt;input 
    type="text" 
    value={입력값} 
    onChange={(e) =&gt; 입력값변경(e.target.value)} 
  /&gt;
  &lt;button onClick={handleAddTitle}&gt;제목 추가&lt;/button&gt;

  {
    /* &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;
        {글제목[0]} &lt;span onClick={(e) =&gt; {e.stopPropagation(); 따봉변경(따봉 + 1)}}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 4일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;{글제목[1]}
        {글제목[1]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 5일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;hr/&gt;
  &lt;div&gt;  
    &lt;div className='list'&gt;
      &lt;h4 onClick={() =&gt; setModal(turn)}&gt;{글제목[1]}
        {글제목[2]} &lt;span onClick={() =&gt; 따봉변경(따봉 + 1)}&gt;👍&lt;/span&gt; {따봉}
      &lt;/h4&gt;
      &lt;p&gt;11월 6일 발행&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt; */
  }

  {글제목.map((a, i) =&gt; (
    &lt;div className='list' key={i}&gt;
      &lt;h4 onClick={() =&gt; { setModal(true); 선택된제목변경(a); }}&gt;
        {a} 
        &lt;span onClick={(e) =&gt; { e.stopPropagation(); 따봉변경(prev =&gt; { 
          const newThumbs = [...prev]; 
          newThumbs[i] = newThumbs[i] + 1;
          return newThumbs;
        }); }}&gt;👍&lt;/span&gt;
        {따봉[i]}
      &lt;/h4&gt;
      &lt;p&gt;11월 {i + 4}일 발행&lt;/p&gt;
      &lt;hr /&gt;
    &lt;/div&gt;
  ))}

  { 
    // 이 영역은 html 코드로 작성하는 곳으로 기본문법 if를 쓸 수 없다.
    (modal == true) ? &lt;Modal title={선택된제목} /&gt; : null
  }    
&lt;/div&gt;</code></pre>
<p>); }</p>
function Modal({ title }) { return (
<div data-classname="modal">
<pre><code>  &lt;h2&gt;{title}&lt;/h2&gt;

  &lt;p&gt;발행 날짜: 
    {title === '소고기 맛집-토방' ? '11월 4일' : 
    title === '불고기 맛집-마포숯불갈비' ? '11월 5일' : 
    title === '한식 맛집-백만석' ? '11월 6일' : ''}
  &lt;/p&gt;

  &lt;p&gt;이곳은 {title}에 대한 상세내용입니다.&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>
<p>/* eslint-disable */ import React, { useState } from ‘react’; //import Hello from ’ ./component/Hello’; import logo from ‘./logo.svg’; import ‘./App.css’;</p>
<p>function App() {</p>
let [글제목, 글제목변경] = useState([‘소고기 맛집 - 토방’,‘불고기 맛집 - 마포숯불갈비’,‘한식맛집 - 백만석’]); let [따봉, 따봉변경] = useState(0); let [선택된제목, 선택된제목변경] = useState(null); // 선택된 제목을 관리하는 상태 추가 let [modal,setModal] = useState(false); // Modal의 상태를 관리하기 위한 상태 let [입력값, 입력값변경] = useState(’’); //입력값을 저장하기 위한 상태 return (
<div data-classname="App">
<pre><code>     &lt;div className="black-nav"&gt;
        &lt;div&gt;대진대 맛집 소개&lt;/div&gt;    
     &lt;/div&gt;
    { /*&lt;div className="list"&gt;
        &lt;h4 onClick={() =&gt; setModal(true)}&gt;
           {글제목[0]} &lt;span onClick={(e) =&gt; { e.stopPropagation(); 따봉변경(따봉 + 1); }}&gt;&lt;/span&gt;{따봉}
        &lt;/h4&gt;
        &lt;p&gt;11월 4일 발행&lt;/p&gt;
        &lt;hr /&gt;
     &lt;/div&gt;
     &lt;div className="list"&gt;
        &lt;h4 onClick={() =&gt;{setModal(true)}}&gt;{글제목[1]}&lt;/h4&gt;
        &lt;p&gt;11월 5일 발행&lt;/p&gt;
        &lt;hr /&gt;
     &lt;/div&gt;
     &lt;div className="list"&gt;
        &lt;h4 onClick={() =&gt; {setModal(true)}}&gt;{글제목[2]}&lt;/h4&gt;
        &lt;p&gt;11월 6일 발행&lt;/p&gt;
        &lt;hr /&gt;
     &lt;/div &gt;*/}

     {
        글제목.map(function(a,i){
           return (
           &lt;div className="list"&gt;
           &lt;h4 onClick={() =&gt;{setModal(true); 선택된제목변경(글제목[i])}}&gt;{글제목[i]}&lt;span onClick={(e) =&gt; { e.stopPropagation(); 따봉변경(따봉 + 1); }}&gt;&lt;/span&gt;{따봉}&lt;/h4&gt;
           &lt;p&gt;11월 5일 발행&lt;/p&gt;
           &lt;hr /&gt;
           &lt;/div&gt;
           )
        })
     }
        &lt;input onChange={(e) =&gt; {입력값변경(e.target.value)}}/&gt;
        &lt;button onClick={() =&gt; {
           let copy = [...글제목];
           copy.unshift(입력값);
           글제목변경(copy);
        }}&gt;버튼&lt;/button&gt;
     {
        //이 영역은 html코드를 작성하는 곳이라 기본문법 if를 쓸수없다.
        (modal == true) ? &lt;Modal title = {선택된제목} /&gt; : null
     }
  &lt;/div&gt;</code></pre>
<p>); }</p>
// 함수형 컴포넌트 function Modal(props) { return (
<div data-classname="modal">
<pre><code>     &lt;h2&gt;{props.title}&lt;/h2&gt;
     &lt;p&gt;날짜&lt;/p&gt;
     &lt;p&gt;상세 내용&lt;/p&gt;
  &lt;/div&gt;</code></pre>
<p>); }</p>
<p>export default App;</p>


</div>
</div>
</div>
</div>
</div>
</div>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_08.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(5)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_09.html</link>
  <description><![CDATA[ 




<p>개발자는 수동화로 하는 방법의 불편함을 알아야 함 자동화 도중 발생하는 오류를 해결하기 위해 필수적임 빅데이터의 기본은 데이터베이스임</p>
<p>1 . Node.js 설치하기 (설치했음) 작업 폴더(todoapp)를 만들고 오픈하기</p>
<ol type="1">
<li>Express 라이브러리 사용하기 (Terminal) npm init 셋팅하기-entry point : server.js로 설정하고 나머진 그냥 Enter키</li>
</ol>
<p>(Terminal) npm install express로 설치하기</p>
<p>node_modules 폴더가 생성되고 패키지가 설치된다.</p>
<p>(VS-왼쪽탐색창) new file로 server.js 만들기</p>
<p>서버가 뭔가요? 기술면접, 고기집 서빙-서버(서비스를 제공해주는 것), 서브 포트 번호는 통로를 열어주도록 서버에 지정하는 것, 네트워크 프로그램(채팅, 웹서비스, 이메일) 같은 통로로 들어오면 안 됨, 다 달라야 함, 그래서 포트 번호가 서로 다름 이것을 포함한 것이 URL이고, 현재는 암묵적으로 80을 씀 지금 실습은 8080이라는 특별한 번호를 쓴 것 100이하는 예약이 있어서 함부로 쓰면 안 됨,</p>
<p>(VS-왼쪽탐색창) new file로 server.js 만들기. Server.js 파일을 열고 아래 코드 작성하기.</p>
<p>Get 요청 처리하기:특정 URL을 방문하면 보여지는 것.</p>
<p>’/pet’에 방문하면 ’펫용품 쇼핑할 수 있는 페이지입니다.’라는 메시지가 보이도록 요청해보자!</p>
<p>Server.js 수정후 ctrl + c로 서버 중지한 뒤, 다시 서버 가동한다. (node server.js) 브라우저에서 localjost:8080/pet을 작성하여 확인한다.</p>
<p>응용 해보기 /beauty를 방문하면, ‘뷰티용품을 쇼핑할 수 있는 페이지입니다’ 가 나오도록 작성하기.</p>
<p>매번 수정할 때마다 서버를 중지하고 재실행하는건 매우 번거로운일이다.</p>
<p>자동화로 바꾸는 방법 (nodemon 설치)</p>
<p>npm install –g nodemon</p>
<p>설치 후 실행할 경우, 에러가 날 것이다.</p>
<p>nodemon server.js</p>
<p>스크립트 실행 제한으로 인한 현상이다.</p>
<p>스크립트 실행 제한 풀기 Windows Power shell을 관리자 권한으로 실행한다. executionpolicy 입력 시, Restricte 라고 나온다.</p>
<p>set-executionpolicy unrestricted 실행한 뒤, 실행 화면에서 y(yes)를 입력한다.</p>
<p>Get 요청 변경</p>
<p>Localhost:8080/까지만 브라우저에 입력하면 띄울 페이지 만들기-index.html</p>
<p>Get 요청 변경</p>
<p>index.html 만들기, 코드 작성(기본 템플릿코드임)</p>
<p>우선 template.html 파일을 생성하고 아래 코드를 작성한다. 작성된 코드를 복사하여 index.html파일에 붙여넣는다.</p>
Get 요청 변경
<meta>
<p>태그</p>
<p>웹 페이지가 다양한 장치와 브라우저에서 어떻게 렌더링될지를 제어한다.</p>
<ol type="1">
<li><meta name="viewport" content="device-width, initial-scale=1.0"></li>
</ol>
<p>이 태그는 웹 페이지가 모바일 디바이스나 다양한 화면 크기에 적응하도록 브라우저가 뷰포트를 설정하는 방식을 지정한다.</p>
<p>name=“viewport”: 뷰포트 설정을 지정하는 태그임을 나타낸다.</p>
<p>content 속성:</p>
<p>device-width: 디바이스의 물리적인 화면 너비(픽셀 크기)에 맞추어 뷰포트를 설정.</p>
<p>initial-scale=1.0: 초기 확대/축소 비율을 1로 설정합니다. 즉, 1픽셀은 디바이스의 1픽셀로 보여지도록 함.</p>
<p>역할:</p>
<p>모바일 장치에서 적절한 크기로 콘텐츠를 보여줌.</p>
<p>화면 크기에 관계없이 콘텐츠가 스크롤 없이 잘 보이게 함.</p>
<p>현재는 edge 브라우저로 바꿔었는데, 이러한 변화는 보안상에 문제가 잦았기에 발생한 것이다. 그래서 사람들이 크롬을 쓰기 시작했고, 이후 크롬 브라우저로 몰리게 된다.</p>
<p>마이크로소프트웨어는 급하게 edge 브라우를 개발했으나 사람들은 돌아오지 않았다. 현재는 크롬에서 파이어 폭스로도 이동하는 추세이며, 크롬에서도 보안상에 문제가 있다.</p>
<p>개인정보를 가져가는 이유는 무료로 마케팅에 사용하기 위해서이다. 파이어 폭스는 비영리 기업이기에 더욱 안전하다.</p>
<ol start="2" type="1">
<li><meta http-equiv="X-UA-Compatible" content="ie=edge"></li>
</ol>
<p>이 태그는 Internet Explorer 브라우저에서 웹 페이지의 호환성 모드를 설정.</p>
<p>http-equiv=“X-UA-Compatible”: 브라우저가 페이지를 어떻게 렌더링할지 지시.</p>
<p>content=“ie=edge”: 최신 렌더링 엔진(Edge 모드)을 사용하도록 지정한다. 즉, IE가 과거 호환성 모드(예: IE7, IE8)를 사용하지 않고 최신 기능을 활용한다.</p>
<p>역할:</p>
<p>IE에서 최신 웹 표준을 최대한 활용하게 한다. 레거시(구형) IE 모드로 인해 발생할 수 있는 스타일 깨짐이나 비표준 동작을 방지한다.</p>
<p>HTML/CSS 디자인 – bootstrap 4</p>
<p>Bootstrap</p>
<p>Powerful, extensible, and feature-packed frontend toolkit. Build and customize with Sass, utilize prebuilt grid system and components, and bring projects to life with powerful JavaScript plugins.</p>
<p>getbootstrap.com</p>
<p>우측 상단의 버전을 4.6.x로 선택한다.</p>
<p>왼쪽 탐색창에서 Getting started 클릭한다.</p>
<p>해당 페이지 하단 아래에 Started template 코드가 있다. 복사하여 Index.html 코드에 붙여넣는다.</p>
&lt;!doctype html&gt;


<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<pre><code>&lt;!-- Bootstrap CSS --&gt;
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous"&gt;

&lt;title&gt;Hello, world!&lt;/title&gt;</code></pre>


<h1>
Hello, world!
</h1>
<!-- Optional JavaScript; choose one of the two! -->
<!-- Option 1: jQuery and Bootstrap Bundle (includes Popper) -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct" crossorigin="anonymous"></script>
<!-- Option 2: Separate Popper and Bootstrap JS -->
<!--
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>
    -->


<p>Button, Navbar 검색하여 붙여넣기 해보기</p>
<p>ol, ul, il의 정의</p>
<p>Navbar 수정하기</p>
<p>Nav -&gt; ToDo app</p>
<p>Feature -&gt; Write</p>
<p>Pricing -&gt; 임시</p>
<p>메인 글 수정하기</p>
<p>Jumbotron 검색</p>
<p>첫번째 내용 복사 붙여넣기- 아래 처럼 수정</p>
<p>Write 발행 메뉴 수정하기</p>
<p>Write.html파일을 만들어 form 만들기</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_09.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(6)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_10.html</link>
  <description><![CDATA[ 




<p>MongoDB를사용하여, 데이터베이스에서 단일 데이터를 삽입하는 작업인 Insert One 실습에 대해 다루고자 한다.</p>
<p>1 . 관계형 데이터베이스 (Relational Database) 데이터를 표(테이블) 형태로 구성하며, 각 테이블은 열(컬럼)과 행(레코드)으로 이루어져 있다. 열은 데이터의 속성을, 행은 데이터의 값을 나타낸다.</p>
<p>위에 데이터베이스가 있고 아래에 표가 있음 SNS 발달 이전은 모드 관계형 데이터베이스였음 일종의 파일로 관리를 했는데 이는 기업에서 문제가 있었음 바로, 갱신이 제대로 안 되는 문제가 있었기에 이를 보안하고자 관계형 데이터베이스라는 것을 만듦.</p>
<p>SQL (Structured Query Language) 데이터를 삽입(INSERT), 조회(SELECT), 수정(UPDATE), 삭제(DELETE)하는 데 사용된다. 데이터베이스를 생성하고 테이블 구조를 정의하는 데에도 사용된다.</p>
<p>데이터베이스용 문법을 사용해야 한다.</p>
<p>중복 데이터 비허용 데이터 무결성(Data Integrity)을 유지하기 위해 중복 데이터를 방지해야 한다. 기본 키(Primary Key) 또는 유니크 키(Unique Key)를 설정하여 테이블 내에서 중복을 방지한다.</p>
<p>정규화 (Normalization) 데이터를 논리적으로 나누어 중복을 제거하고, 데이터의 무결성과 효율성을 높이는 과정이다. 정규화 단계를 거치면 데이터의 불필요한 중복이 제거되고 유지보수가 쉬워진다.</p>
<p>정확도가 중요한 이유 관계형 데이터베이스는 금융, 의료, 제조 등 데이터의 정확성과 신뢰성이 중요한 분야에서 많이 사용된다. ACID(Atomicity, Consistency, Isolation, Durability) 속성을 지원하여 데이터의 신뢰성을 보장한다.</p>
<p>보통 MySQL(무료, 소규모 웹사이트), PostgreSQL, Oracle(주로 사용, 비쌈, 대규모 프로젝트), Microsoft SQL Server , 아마존Sql같은 시스템이 관계형 데이터베이스로 많이 쓰인다.</p>
<ol type="1">
<li>비관계형 데이터베이스 (NoSQL) 데이터를 유연한 구조로 저장할 수 있는 데이터베이스.</li>
</ol>
<p>관계형 데이터베이스처럼 고정된 스키마가 없으므로, 데이터의 구조를 미리 정의하지 않아도 되며, 다양한 데이터 형식을 지원한다.</p>
<p>키-값, 문서(Document), 컬럼(Column), 그래프(Graph) 등.</p>
<p>Redis 데이터 저장 방식: Key-Value 구조. 예: { “username”: “john_doe”, “score”: 100 }</p>
<p>속도가 빠르고, 캐싱(Cache), 실시간 데이터 처리에 적합하다. 메모리 기반 데이터 저장소로, 데이터를 휘발성(메모리 저장) 또는 영구적(디스크 저장)으로 저장 가능.</p>
<p>MongoDB Document 기반의 데이터 저장 방식을 사용하며, 이때 데이터는 JSON 형식으로 저장한다.</p>
<p>{ “name”: “Alice”, “age”: 30, “hobbies”: [“reading”, “cycling”] }</p>
<p>데이터 구조가 유연하며, 관계형 데이터베이스처럼 테이블 간 조인을 강제하지 않는다. 대량의 데이터를 처리하기 용이하며, 비정형 데이터(예: 로그, 소셜 미디어 데이터)에 적합하다.</p>
<p>고정된 테이블 스키마 필요 스키마 자유로움 데이터 정확성 우선 유연성과 확장성 우선 SQL 사용 각 DB마다 다른 쿼리 방식 트랜잭션 처리 강력 빠른 읽기/쓰기 성능 제공</p>
<p>사용 사례</p>
<p>Redis: 세션 관리, 실시간 채팅, 게임 점수판, 캐시.</p>
<p>MongoDB: 비정형 데이터 저장, 콘텐츠 관리 시스템(CMS), 로그 데이터 분석.</p>
<p>이런 비관계형 데이터베이스는 특히 빅데이터나 실시간 응용 프로그램에서 강점을 발휘한다.</p>
<p>왜 비관계형 데이터베이스가 적합한가?</p>
<p>데이터 크기</p>
<p>SNS 플랫폼에서는 매일 수십억 건의 텍스트, 이미지, 동영상 데이터가 생성됩니다. 관계형 데이터베이스는 대규모 데이터를 처리하기 위해 확장이 어렵고, 속도가 느려질 수 있습니다. 비관계형 데이터베이스는 수평적 확장(Scale-out)이 가능하여 서버를 추가함으로써 용량과 성능을 늘릴 수 있습니다.</p>
<p>데이터 구조의 다양성</p>
<p>SNS 데이터는 텍스트, 이미지, 동영상, 댓글, 해시태그 등 다양한 형태로 존재합니다. 비정형 데이터(동영상, 이미지 메타데이터 등)는 관계형 데이터베이스의 정형화된 스키마에 맞추기 어렵습니다. 비관계형 데이터베이스는 스키마가 없거나 유연하여 다양한 데이터를 쉽게 저장할 수 있습니다.</p>
<p>속도와 실시간 처리</p>
<p>SNS는 사용자가 게시물 업로드, 좋아요, 댓글 등을 실시간으로 처리해야 합니다. 비관계형 데이터베이스는 높은 쓰기/읽기 성능을 제공하여 실시간 데이터 처리가 가능합니다.</p>
<p>확장성</p>
<p>관계형 데이터베이스는 주로 <strong>수직적 확장(Scale-up)</strong>으로 성능을 높여야 하지만, 이는 비용이 많이 듭니다. 비관계형 데이터베이스는 <strong>수평적 확장(Scale-out)</strong>을 통해 저비용으로도 서버를 추가해 성능을 높일 수 있습니다.</p>
<p>SNS에서 자주 사용되는 비관계형 데이터베이스</p>
<p>Cassandra</p>
<p>유튜브: 대규모 동영상 메타데이터 관리에 사용. 분산 시스템으로 높은 가용성과 확장성을 제공.</p>
<p>MongoDB</p>
<p>인스타그램: 유저 프로필, 사진 메타데이터 저장. JSON 기반 데이터 처리에 최적화.</p>
<p>HBase</p>
<p>페이스북: 메시징 시스템과 같은 대량 데이터 저장에 사용. Hadoop 기반으로 동작하며, 빅데이터 처리에 강점.</p>
<p>Redis</p>
<p>캐싱 및 실시간 데이터 분석에 활용. 예: 실시간 좋아요 수 카운팅.</p>
<p>데이터 규모 이해 1페타바이트(1PB)는 1,024 테라바이트(TB)로, 약 50억 개의 고화질(HD) 사진을 저장할 수 있는 용량이다. 이처럼 초대형 데이터가 매일 쌓이는 환경에서는 유연하고 확장성 있는 비관계형 데이터베이스가 필수적이다.</p>
<p>SNS와 같은 플랫폼은 비관계형 데이터베이스를 통해 데이터를 효율적으로 관리하며, 사용자의 경험을 실시간으로 최적화하고 있다!</p>
<p>비관계형 데이터베이스의 장점 1. 빠른 데이터 입출력</p>
<p>데이터를 저장할 때 정규화(Normalization) 과정을 거치지 않으므로, 데이터를 바로 저장할 수 있다. 관계형 데이터베이스에서 테이블을 나누고 조합(join)하는 과정을 피할 수 있어 속도가 매우 빠르다.</p>
<ol start="2" type="1">
<li>단순한 데이터 구조</li>
</ol>
<p>데이터 구조를 복잡하게 설계하지 않아도 된다. 개발 초기 단계에서 빠르게 시스템을 구축하고 테스트할 수 있다.</p>
<p>단점 1. 데이터 정확성 문제</p>
<p>중복 데이터가 저장될 가능성이 높다. 예를 들어, 사용자 이름을 여러 곳에 저장해 놓은 경우, 한 곳에서 이름을 수정하면 모든 관련 데이터를 직접 수정해야 한다.</p>
<p>데이터 정합성(Consistency)을 유지하기 어렵다.</p>
<ol start="2" type="1">
<li>유지 보수 어려움</li>
</ol>
<p>데이터 구조를 정규화하지 않은 상태에서 시스템이 커지면, 수정 작업이 복잡해지고 시간이 많이 소요될 수 있다.</p>
<p>중복된 데이터를 처리하다가 오류가 발생할 가능성이 높아진다.</p>
<p>비관계형 데이터베이스가 적합한 경우</p>
<p>빠른 입출력 속도가 중요한 애플리케이션. 예: 게시판, SNS, 실시간 채팅.</p>
<p>데이터 정확성이 상대적으로 덜 중요한 경우. 예: 로그 데이터, 캐시, 임시 저장소.</p>
<p>관계형 데이터베이스가 적합한 경우</p>
<p>데이터 정합성과 정확도가 중요한 경우. 예: 금융 시스템, 재고 관리, 전자 상거래.</p>
<p>데이터 구조가 명확히 정의되어 있고, 테이블 간 관계가 중요한 경우.</p>
<ol start="3" type="1">
<li>Mongo-DB 이전에는 mysql로 웹사이트를 만들었음 위 db를 사용한다면 SQL 배울 필요가 없으며, 테이블스키마를 생성 안 해도 된다.</li>
</ol>
<p>이는 Document 데이터베이스라고도 불린다.</p>
<ol type="1">
<li>Document 기반 데이터베이스</li>
</ol>
<p>데이터를 JSON과 유사한 형식(BSON, Binary JSON)으로 저장한다. 관계형 데이터베이스처럼 행(Row)과 열(Column)이 아니라, 데이터가 Document(문서) 단위로 관리된다.</p>
<p>데이터 구조가 유연하므로, 다양한 형태의 데이터를 저장할 수 있다.</p>
<ol start="2" type="1">
<li>테이블 스키마 필요 없음</li>
</ol>
<p>사전에 테이블 구조를 정의할 필요가 없다. 필드와 데이터 타입은 문서마다 달라도 된다.</p>
<p>{ “name”: “Alice”, “age”: 25, “email”: “alice@example.com” } { “name”: “Bob”, “hobbies”: [“cycling”, “painting”] } 이런 유연성 덕분에 빠르게 프로토타입을 만들거나 동적 데이터 처리에 유리합니다.</p>
<p>사용 사례</p>
<p>게임 데이터, IoT 센서 데이터, 비정형 데이터 로그, 사용자 프로필 정보 등.</p>
<p>MongoDB 데이터 저장 방식 1. Database(데이터베이스)</p>
<p>데이터를 저장하는 최상위 단위입니다. 예: myDatabase</p>
<ol start="2" type="1">
<li>Collection(컬렉션)</li>
</ol>
<p>데이터의 그룹. 관계형 데이터베이스의 테이블과 유사하다. 예: users라는 컬렉션에 사용자 정보를 저장한다.</p>
<ol start="3" type="1">
<li>Document(문서)</li>
</ol>
<p>개별 데이터 단위. JSON 형태로 저장.</p>
<p>{ “name”: “John Doe”, “age”: 30 }</p>
<p>초보자와 숙련자 사용법 1. 로컬 설치 (숙련자)</p>
<p>MongoDB를 직접 컴퓨터에 설치하여 커스터마이징 가능하다. 복잡한 설정을 다룰 수 있는 개발자에게 적합하다.</p>
<ol start="2" type="1">
<li>클라우드 서비스 추천 (초보자)</li>
</ol>
<p>MongoDB Atlas를 사용하면 클라우드에서 바로 시작할 수 있다. 무료로 소규모 프로젝트를 호스팅할 수 있으며, 필요 시 비용을 지불해 업그레이드 가능하다.</p>
<p>백업, 보안 설정, 검색 기능 등 추가 서비스를 자동으로 제공한다.</p>
<p>주요 기능 1. Replica Set</p>
<p>데이터가 3개의 노드로 자동 복제되므로, 하나의 노드가 고장 나더라도 데이터 손실이 없다. 이를 통해 고가용성(High Availability)을 제공한다.</p>
<ol start="2" type="1">
<li>Full-Text Search</li>
</ol>
<p>문서 내 텍스트 데이터를 빠르게 검색할 수 있는 인덱스 생성 가능하다. 클라우드 호스팅(MongoDB Atlas)을 통해 더 쉽게 구현 가능하다.</p>
<p>결론적으로, MongoDB는 관계형 데이터베이스와는 다른 자유로운 설계와 확장성 덕분에 스타트업, 빅데이터 처리 및 애자일 개발 환경에 특히 유리하다.</p>
<ol start="3" type="1">
<li>Mongo-DB 사용하기 나는 초보자이므로, 클라우드에서 호스팅 받아 쓰는 것을 진행해 보겠다.</li>
</ol>
<p>MongoDB: 개발자 데이터 플랫폼</p>
<p>업계를 선도하는 모던 데이터베이스를 토대로 구축된 애플리케이션 데이터 플랫폼을 사용해 아이디어를 더욱 빠르게 실현하세요. MongoDB는 데이터를 손쉽게 처리할 수 있도록 지원합니다.</p>
<p>www.mongodb.com</p>
<p>MongoDB를 직접 컴퓨터에 설치하지 않을 것이므로, 다운로드가 아닌 왼쪽에 위치한 등록 버튼을 클릭한다.</p>
<p>본인이 원하는 방법으로 가입한다.</p>
<p>약관 허용 여부를 선택하고 제출한다.</p>
<p>그러면 다음 화면이 잠시 보일 것이다.</p>
<p>본인의 목적에 따라 다음 설문을 진행하면 된다.</p>
<p>나는 다음과 같이 작성했다.</p>
<p>첫 프로젝트이므로, 무료 버전을 사용하겠다.</p>
<p>본인이 원하는 이름을 쓰고, Provider을 선택하면 된다. 단, Region에 경우, Seoul로 해야 속도가 빠르므로 이 설정은 바꾸지 않는 것을 권장한다.</p>
<p>준비가 되었다면, Create Deployment를 클릭한다.</p>
<p>Username에는 본인의 계정 아이디가 적혀 있고, Password에는 자동으로 비밀번호가 생성되어 있을 것이다.</p>
<p>이 부분은 본인이 자유롭게 바꾸면 되는데, 비밀번호에 경우, 웹서버 연동에 써야 하므로 꼭 기억해 놓기를 바란다.</p>
<p>보안이 중요하지 않다면 비밀번호는 단순하게 설정해도 무방하다.</p>
<p>Create Database User - Choose a connection method 순으로 클릭한다.</p>
<p>첫 화면</p>
<p>Network Access - +ADD IP ADDRESS를 클릭한다.</p>
<p>전체 포트 번호를 지정해주며, 아래 경고는 모든 곳에서 접속할 수 있으니 주의하라는 메세지이다.</p>
<p>Confirm을 클릭한다.</p>
<p>Clusters - Browse Collections - + Create Database 순으로 클릭한다.</p>
<p>자유롭게 지으면 된다.</p>
<p>Create를 클릭한다.</p>
<p>위 과정을 끝내면, 다음과 같은 화면이 보일 것이다.</p>
<p>지금까지 데이터베이스를 설정하는 과정이었다. 이제 데이터베이스를 연결하여 구동해볼 것이다.</p>
<p>DB연동하기 post로 나옴, 웹 서버를 통해 데이터 입력하는 과정을 진행하겠다. 먼저, VS코드 프롬프트에 mongodb 버전 5를 설치한다.</p>
<p>이 버전은 최신 버전은 아니지만, 이미 검증되어 안정적이므로, 구버전을 설치하도록한다.</p>
<p>npm install mongodb@5</p>
<p>mongodb 설치 완료.</p>
<p>이전에 VS코드 파일인 Server.js에 아래의 코드를 추가한다.</p>
<p>// 서버 포트 설정(이전에 작성된 코드) app.listen(8080, function () { console.log(‘listening on 8080’); });</p>
<p>// 이번에 작성할 코드 const { MongoClient } = require(‘mongodb’);</p>
<p>let db; const url = ‘DB접속 URL’; // 여기에 실제 접속 URL을 넣는다. new MongoClient(url).connect().then((client) =&gt; { console.log(‘DB연결 성공’); db = client.db(‘todoapp’); // ‘todoapp’ 데이터베이스를 선택한다. }).catch((err) =&gt; { console.log(‘DB 연결 실패:’, err); }); 어떠한 용어를 쓰던 매우 흡사함.</p>
<p>Clusters - Connect 순으로 클릭하기.</p>
<p>데이터를 안전하게 주고받기 위해서는 코드로 감시자를 설정하여 보안을 강화해야 하며, 이곳에 접속을 시도하려면 서버 주소를 알고 있어야 한다.</p>
<p>클라우드 호스팅 서비스를 사용하면, 무료로 서버를 빌릴 수 있다. 이 경우에도 접속하려면 호스팅된 서버의 주소를 알아야 한다.</p>
<p>127.0.0.1은 로컬 주소로, 내 컴퓨터를 의미한다. 원격 서버에 접속하려면, 해당 서버의 IP 주소 또는 도메인 이름을 반드시 알아야 한다.</p>
<p>하단에 본인의 웹 서버 주소가 있을 것이다.</p>
<p>admin은 지정된 이름이며, ‘<db_password>’ 자리에 이전에 본인이 설정한 비밀번호를 기입한다.</db_password></p>
<p>몽고디비 호스팅 서버가 이걸로 접속하세요 하고 알려주는 것이므로 사람마다 다 다르다.</p>
<p>위 웹 주소를 복사하여 VS코드에 ‘DB 접속 URL’ 부분에 붙여 넣는다. Ctrl + S를 눌러 저장한 뒤, nodemon server.js를 입력한다.</p>
<p>연결이 될 경우, ‘DB 연결 완료’ 메세지가 나온다.</p>
<p>이제 가장 아래 부분에 다음 코드를 작성한다.</p>
<p>app.get(‘/news’, function (req, res) { db.collection(‘post’).insertOne({title:‘프론트웹개발’}) res.send(‘DB에 데이터 삽입’) });</p>
<p>저장을 한 뒤, 크롬 URL에 http://localhost:8080/news라고 입력하면 다음과 같은 화면이 보일 것이다.</p>
<p>그리고 다음과 같이 DB에 데이터가 생성된 것을 확인할 수 있다.</p>
<p>마지막으로 데이터를 데이터베이스에서 직접 생성한 뒤, 이를 출력하는 과정을 진행해보겠다.</p>
<p>본인의 화면 우측에 Insert Document 버튼을 클릭한다.</p>
<p>아래와 같이 입력해본다.</p>
<p>Insert 버튼을 클릭한다.</p>
<p>그러면, 다음과 같이 데이터가 추가된 것을 볼 수 있다.</p>
<p>이제 VS코드로 돌아가서 아래의 코드를 최하단에 입력한다.</p>
<p>app.get(‘/post’, async(req, res) =&gt; { // 익명 함수 let result = await db.collection(‘post’).find().toArray(); console.log(result[1].title) res.send(result[1].title) });</p>
<p>저장하면, 프롬프트에는 다음과 같이 나온다.</p>
<p>그리고 크롬을 새로고침 하면 다음과 같이 나온다.</p>
<p>이것으로 Insert One 실습을 마치도록 한다.</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_10.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React를 이용한 Blog 만들기(6)</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_11.html</link>
  <description><![CDATA[ 




<p>목록을 적성하기.</p>
<p>1 . 자 료 의 입 력</p>
<p>Cloud: MongoDB Cloud</p>
<p><a href="https://account.mongodb.com/account/login?n=https%3A%2F%2Fcloud.mongodb.com%2Fv2%2F674d0886cfb68655ff3271d0&amp;nextHash=%23overview&amp;signedOut=true">account.mongodb.com</a></p>
<p>Html 파일에 서버데이터 넣는 방법? 데이터가 왔다가는 건 매우 어려움</p>
<p>–template engine 사용 Pug/ejs/Handlebars…… 가장쉽고 간단한 ejs를 사용 다른 엔진은 자체 문법을 공부해야하지만, ejs는 자바스크립트 코드를 그대로 쓸 수 있음.</p>
<p>–Ejs 설치 •&gt;&gt;npm install ejs 설치후 server.js 안에 ejs 설정하기</p>
<p>•Html 파일에 데이터 넣기 –Ejs파일 만들기 •views폴더를 만들고 그 안에 list.ejs 생성 List.ejs코드와 main.css 코드 작성</p>
<p>•Main.css파일 작성 –우선 프로젝트 폴더에 public 폴더 생성 -&gt; main.css 생성후 작성 –Server.js에 다음 코드 추가하기</p>
<p>•데이터베이스 데이터를 ejs에서 사용하려면 –&lt;%=데이터 이름 %&gt;로 감싸서 사용 –HTML 코드를 ejs에서 사용하려면 위 특수태그를 사용하면 된다. –Html안에 &lt;%=데이터 이름 %&gt;을 쓰면 object 자료형이 깨져서 나옴 –&lt;%=JSON.stringify(데이터 이름) %&gt;으로 사용하면 데이터가 나옴.</p>
<p>•/time 이라고 접속하면 현재 서버의 시간을 보내주는 기능을 만들어보자. –Ejs로 웹페이지를 만들어서 거기 안에 서버의 시간을 박아넣어서 보내주면 됨. –(팁) 서버의 시간은 server.js 파일 아무데서나 new Date() 라고 쓰면 나옴</p>
<p>•데이터베이스 데이터를 ejs에서 사용하려면 –&lt;%=데이터 이름 %&gt;로 감싸서 사용 –HTML 코드 및 자바스크립트를 ejs에서 사용하려면 위 특수태그(&lt;% %&gt;)를 사용하면 된다. –Html안에 &lt;%=데이터 이름 %&gt;을 쓰면 object 자료형이 깨져서 나옴 –&lt;%=JSON.stringify(데이터 이름) %&gt;으로 사용하면 데이터가 나옴. –자바스크립트 반복문을 사용하여 여러 개의 게시물을 화면에 보이도록 하자.</p>
<p>•지금까지 코드엔 네비게이션 바가 안보인다?! –Index.html의 네브바 코드만 복사에서 붙여넣으면 되지만, 모든 페이지마다 이러한 작업을 하는건 매우 비효율적이다. –Nav.ejs를 만들고, 네브바 코드를 넣은뒤, 이걸 포함시키는 방법이 더 효과적이다. –이를 위해 &lt;%- include(‘nav.ejs’) %&gt;를 사용하자.</p>
<p>서버에 HTTP 요청하는법 서버로 진짜 요청 날리려면</p>
<p>REST원칙</p>
<p>좋은 URL 작명방법</p>
<p>Method : GET, POST, PUT, UPDATE, DELETE</p>
<ol type="1">
<li><p>GET : 서버에 데이터 출력요청할때</p></li>
<li><p>POST : 서버에 데이터 입력요청할때</p></li>
<li><p>PUT,UPDATE: 서버에 데이터 수정요청할때</p></li>
<li><p>DELETE : 서버에 데이터 삭제요청할때</p></li>
<li><p>URL : /어쩌구</p></li>
</ol>
–POST요청은 어떻게?
<form>
<p>태그 이용 –REST(Representation state transper) API •좋은 API 디자인하는 원칙 6개 1. 일관성 있는 URL이 좋음 - 2가지 역할 금지 »하나의 URL+method는 하나의 데이터를 보내야 좋음</p>
<ol start="2" type="1">
<li><p>유저에게 서버역할을 맡기지 마라</p></li>
<li><p>요청끼리 서로 의존성이 있으면 안된다. - 독립적</p></li>
<li><p>요청은 캐싱이 가능해야 한다.</p></li>
</ol>
<p>여기서, 캐싱이란 자주 수신되는 자료들은 요청을 날리지 않고 하드에 저장해놓고 쓰도록 하는 기술</p>
<p>Layered System :요청하나는 최종 응답전까지 여러 단계를 거쳐도 된다.(잘 몰라도 됨)</p>
<p>Code on demand : 서버는 유저에게 실행가능한 코드를 보내줄 수도있음. (잘 몰라도 됨)</p>
<p>좋은 URL 작성법 1. 동사보다는 명사 위주로</p>
<ol start="2" type="1">
<li><p>띄어쓰기는 언더바_대신 대시-기호</p></li>
<li><p>파일 확장자 쓰지말기(.html)</p></li>
<li><p>하위 문서들을 뜻할땐 /기호를 사용함(하위 폴더같은 느낌)</p></li>
</ol>
<p>다음과 같은 문제를 풄 있어야 된</p>
<p>Q1.facebook.com/bbc/photos로 GET요청하면 어떤 데이터 보여줄까?</p>
<p>BBC뉴스 이미지를 보여준다.</p>
<p>Q2.Instagram.com/explore/tags/food로 GET요청하면 어떤 데이터 보여줄까?</p>
<p>글 작성 페이지와 form 만들고, 서버는 전송받은 글 확인</p>
<p>글 작성기능? 1.글작성 페이지에서 글 써서 서버로 전송 2.서버는 글을 검사 3.이상없으면 DB저장 –Views/write.ejs 생성</p>
<p>write.ejs 코드-list.ejs코드를 복사 붙여넣고 아래처럼 수정</p>
<p>•글 작성페이지와 form 만들기 –버튼을 클릭한다고 입력이 되는가? NO!!</p>
<p>Url과 method를 지정해야 함!! –form태그의 속성으로 action과 method를 지정해야 한다 –또한 input태그에 name속성을 지정해야 입력된다.</p>
<p>서버로 글 전송(server.js) res.body를 쓰면 유저가 보낸 데이터 출력가능 쓰기 전에 셋팅이 필요</p>
<p>–Localhost/write페이지에서 글 입력하고 서버로 데이터 전송뒤 콘솔로 터미널에 출력하기 –DB 저장은? 앞서서 공부했음.알아서 해보자!! ^^;;;</p>
<p>vjqmfflt</p>



</form> ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_11.html</guid>
  <pubDate>Mon, 04 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>비동기 자바스크립트</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_03.html</link>
  <description><![CDATA[ 




<p>(P.56)</p>
<p>01 비동기 자바스크립트 (Asynchronous JavaScript) 프로그램이 멈추지 않고, 여러 작업을 동시에 처리할 수 있도록 설계된 개념. 기본적으로 자바스크립트는 싱글 스레드 언어이므로, 한 번에 하나의 작업만 처리할 수 있다.</p>
<p>따라서 비동기 작업이 없으면 어떤 작업이 완료될 때까지 다른 작업들이 대기해야 하고, 이로 인해 화면이 멈추는 현상이 발생할 수 있다.</p>
<ol type="1">
<li>비동기 처리의 필요성 초기에는 웹 페이지에서 동적인 변화가 적어 화면이 멈추는 일이 큰 문제가 되지 않았다.</li>
</ol>
<p>하지만 현대적인 웹 애플리케이션에서는 사용자 경험이 중요해졌고, 작업이 멈추면 페이지가 느려지거나 비정상적으로 작동하는 것처럼 보일 수 있었다.</p>
<p>특히, 서버에서 데이터를 불러오거나 큰 계산 작업을 하는 동안 사용자 인터페이스가 멈추는 것을 방지하는 것이 중요해졌다.</p>
<ol start="2" type="1">
<li>비동기 처리 방법 자바스크립트에서 비동기 처리를 위해 다양한 방법을 사용할 수 있다.</li>
</ol>
<ol type="1">
<li>콜백 함수 (Callback) 함수가 완료되면 그 다음에 실행할 작업을 함수로 전달하여 실행하는 방식.</li>
</ol>
<p>하지만 콜백 함수의 중첩이 많아지면 코드가 복잡해지고 관리하기 어려워지는 “콜백 지옥”이 발생할 수 있다.</p>
<ol start="2" type="1">
<li>프로미스 (Promise) 콜백 함수의 단점을 보완한 비동기 처리 방식. 작업이 완료되면 성공(resolve)이나 실패(reject)에 대한 결과를 반환한다.</li>
</ol>
<p>.then()이나 .catch()로 결과를 처리할 수 있다.</p>
<ol start="3" type="1">
<li>async/await ES8에 도입된 방식으로, 프로미스를 더 직관적이고 순차적으로 처리할 수 있게 만들어준다.</li>
</ol>
<p>async 키워드를 함수에 붙이고, 그 안에서 await를 사용하여 비동기 작업이 완료될 때까지 기다릴 수 있다.</p>
<p>입력 함수와 콜백 함수 자바스크립트에서 입력 함수는 사용자로부터 데이터를 입력받는 작업을 수행하는 함수.</p>
<p>비동기 작업에서는 입력이 완료된 후에도 다른 작업이 바로 실행되며, 이때 콜백 함수를 사용하여 입력이 완료된 후 특정 작업을 처리하게 됩니다.</p>
<p>콜백 함수는 특정 이벤트가 발생하거나 작업이 완료되었을 때 호출되는 함수입니다.</p>
<p>2초 뒤에 “첫 번째 작업 완료”라는 메시지를 출력하는 비동기 코드. 이 경우 콜백 함수가 사용됩니다.</p>
<p>중요한 점은, 2초가 지나기 전에 다른 작업이 바로 실행된다는 것입니다. 즉, 프로그램은 기다리지 않고 계속 실행되며, 작업이 완료되면 콜백 함수가 호출됩니다.</p>
<p>이것이 블로킹되지 않는다는 의미입니다.</p>
<p>API 요청과 fetch 함수 과거에는 API 요청을 보내는 작업이 복잡하고 번거로웠지만, fetch 함수의 도입으로 간편하게 API 호출을 할 수 있게 되었다.</p>
<p>fetch 함수는 기본적으로 프로미스를 반환하며, 비동기적으로 데이터를 받아옵니다. 이는 REST API를 사용하여 서버에서 데이터를 가져올 때 매우 유용합니다.</p>
<p>Promise 비동기 작업의 상태와 결과를 나타내는 자바스크립트 객체</p>
<p>이 개념을 비유적으로 설명하면, 브라우저가 데이터를 요청하면서 “최선을 다해 데이터를 가져올게. 성공하든 실패하든 그 결과를 알려줄게.” 라고 약속하는 것과 같다.</p>
<p>기본 동작 진행 중 (pending): 비동기 작업이 아직 완료되지 않은 상태.</p>
<p>성공 (fulfilled): 비동기 작업이 성공적으로 완료된 상태.</p>
<p>실패 (rejected): 비동기 작업이 실패한 상태.</p>
<ol type="1">
<li>.then() ⇨ 작업 체이닝(연결) 비동기 작업이 성공한 후 실행될 작업(콜백 함수)을 등록합니다. 이 함수는 이전 작업이 완료되면 호출됩니다.</li>
</ol>
<p>여러 then()을 연결하여 작업을 순차적으로 수행할 수 있다.</p>
<ol start="2" type="1">
<li>.catch() ⇨ 예외 처리 Promise에서 발생한 오류를 잡아서 처리하는 메서드.</li>
</ol>
<p>데이터 요청 중 네트워크 문제나 서버 오류 등의 이유로 작업이 실패할 때, 그 에러를 처리할 수 있다.</p>
<p>Async 일반적인 함수를 비동기적으로 처리하게 해주는 함수. .then() 체인을 사용해 promise의 결과를 기다리는 대신, async 함수는 코드 실행을 promise가 해결될 때까지 기다리도록 함.</p>
<p>앞서서 API 요청을 Async 함수로 처리하는 코드 async function getFakePerson() { try { const response = await fetch(‘https://api.randomuser.me/?nat=US&amp;results=1’); const data = await response.json(); console.log(data.results); } catch (error) { console.error(‘Error:’, error); } } getFakePerson() 동시 접근이 안된다. 해결할 때까지 기다려 준다.</p>
<p>개발자는 이를 미리 예측하여, 멈추지 않고 작업이 가능하도록 예외처리를 하는 것이 중요함. 패치 시 await를 해줌, 함수 호출을 하면 한 명의 데이터가</p>
<p>뉴 바인딩, 뒤에 클래스 문법이 나옴, 클래스의 이름의 첫 글자는 대문자이다. 이는 객체로 사용 가능한으로 판단할 수 있다.</p>
<p>괄호 안에 매개변수()에 각각 성공과 실패에 대한 정보가 담긴다. 웹 문서에서 데이터 요청할 때 쓰는 2가지 방식</p>
<p>GET(노출하여 가져오는 것, 해킹 당할 위험이 큼) POST(노출하지 않아, 더 안전하다.)</p>
<p>성공했다면(200), 상한 연산자 - 참(?)/거짓(:)</p>
<p>Classes 2015이전에는 자바에서 클래스를 쓸 수 없었음 이후 클래스를 써서 개발자들에게 각광을 받았다.</p>
<p>방학 때 어디로 놀러갈 것인가?</p>
<p>// p.62</p>
<p>function Vacation(destination, length) { this.destination = destination; this.length = length; } Vacation.prototype.print = function() { console.log(this.destination + ” | ” + this.length + ” days”); }; const maui = new Vacation(“Maui”, 7); maui.print(); // Maui | 7 days 생성자 호출, 마오이로 7일 간 자바 스크립트 클래스 문법 차별화를 두겠다고 따라한 걸 안 들키려고 함. 이는 파이썬도 마찬가지이다.</p>
<p>C언어로 배운 사람은 혼란할 수 있음</p>
<p>class Vacation { constructor(destination, length) { this.destination = destination; this.length = length; } print() { console.log(<code>${this.destination} will take ${this.length} days.</code>); } }</p>
<p>const trip = new Vacation(“Santiago, Chile”, 7); trip.print(); // Chile will take 7 days.</p>
<p>자바 기능의 모든 것.</p>
<p>class Expedition extends Vacation { constructor(destination, length, gear) { super(destination, length); this.gear = gear; } print() { super.print(); console.log(<code>Bring your ${this.gear.join(" and your ")}</code>); } } super의 의미: 부모의</p>
<p>매개변수 2개, 1.상속: 부모의 기능을 그대로 사용하려는 것 객체 지향에서는 가장 중요하다.</p>
<p>2.다형성, 3.인터페이스</p>
<p>const trip = new Expedition(“Mt. Whitney”, 3, [ “sunglasses”, “prayer flags”, “camera”]); trip.print(); // Mt. Whitney will take 3 days. // Bring your sunglasses and your prayer flags and your camer</p>
<p>스크립트도 모듈로 쓸 수 있도록 모듈은 쉽게 말해 부품이다.</p>
<p>export const print=(message) =&gt; log(message, new Date()) export const log=(message, timestamp) =&gt; console.log(<code>${timestamp.toString()}: ${message}</code>) 외부에서 가져다 쓸 수 있도록 인폴트시킨 것. C언어에서 블리컨파일 불러오기를 자바에서는 모듈이라는 기능으로 불린것 뿐</p>
<p>객체도 외부에 공개할 수 있다.</p>
<p>import { print, log } from “./text-helpers”; import freel from “./mt-freel”; print(“printing a message”); log(“logging a message”); freel.print(); C언어는 인클루드이고, 자바나 파이썬은 인폴트를 사용한다. 모듈을 이용해서 외부의 기능을 사용한 것. 이는 관리하기 용이하고 이름이 중복되는 것을 방지.</p>
<p>아바스틴줄 약</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_03.html</guid>
  <pubDate>Wed, 09 Oct 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Chapter 2. JavaScript forReact</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_02.html</link>
  <description><![CDATA[ 




<p>44 페이지부터 시작 자바스크립트에는 여러가지 이것을 알고 리엑트를 써먹어야 한다.</p>
<p>01 Code Runner 설치하기</p>
<p>위와 같이 이동하거나 단축키 [Ctrl + Shift + X]를 누르면 Extensions으로 이동한다.</p>
<p>code까지만 입력해도, 좌측 최상단으로 Code Runner 나온다.</p>
<p>install 버튼을 클릭해서 Code Runner를 설치한다.</p>
<p>Uninstall로 바뀌면 설치가 완료된 것이다.</p>
<p>객체 리터럴 구문 (Object Literal Syntax)</p>
<p>자바스크립트에서 객체를 생성하는 간단한 방법으로, 이 구문을 사용하면 중괄호 {}를 이용하여 객체를 정의하고, 그 안에 속성과 값을 직접 설정할 수 있다.</p>
<p>아래 코드의 문제는 객체 리터럴을 반환하려는 의도와 JavaScript 구문 오류 때문이다. 코드를 살펴보면, JavaScript는 중괄호 {}를 함수 본문의 시작과 끝으로 해석하므로 객체를 반환하려는 시도가 제대로 작동하지 않는다.</p>
<p>const person = (firstName, lastName) =&gt; { first: firstName, last: lastName } console.log(person(“Brad”, “Janson”));</p>
<p>위 코드를 실행하면 ” SyntaxError: Unexpected token ’ : ’ ” 오류가 발생한다. 이는 함수 내에서 올바른 객체 리터럴 구문 사용하지 않아 발생하는 문제이다.</p>
<p>이 문제를 해결하려면, 반환하고자 하는 객체를 소괄호()로 감싸면 된다.</p>
<p>위 코드가 어떤 과정을 거쳐 오류가 출력되는지 자세히 알아보고자 한다.</p>
<p>속성부터 시작해서 객체가 반환되는 과정을 담은 그림. firstName 매개변수로 전달된 값이 객체의 first 속성에 설정된다. person 함수는 { first: firstName, last: lastName } 이러한</p>
<p>객체 리터럴을 생성하고, 그 객체를 반환한다.</p>
<p>매개변수 firstName과 lastName는 함수가 호출되면, 전달된 값(예: “Brad”, “Janson”)을 담는다. 이 값들은 객체의 속성으로 사용된다.</p>
<p>객체는 메모리 상에 저장되며, 함수는 그 객체의 참조(메모리 주소)를 반환한다. 이 참조를 통해 메모리 상에 객체에 접근할 수 있다.</p>
<p>결과적으로, { first: ‘Brad’ , last: ‘Janson’ }와 같은 객체가 반환되어야 하지만, 위 코드는 반환되지 않고 오류가 출력되는 것이다.</p>
<p>그러면, 어떤 이유로 오류가 출력되는 것인가?</p>
<p>자바스크립트에서는 중괄호{}만 있을 경우,</p>
<p>first: firstName은 객체 리터럴의 속성 정의가 아닌, labelled statement로 해석이 가능해진다.</p>
<p>자바스크립트 문법에서 labelled statement 다음에 유효한 표현식이 필요하며, 이것이 코드에 제대로 반영되어 있지 않아서</p>
<p>컴파일러가 스스로 이 코드 구조에 오류가 있다고 판단한 것이다.</p>
<p>따라서, 객체 리터럴 속성 정의로 단정할 표현식이 필요하므로, 소괄호로 한 번 더 감싸는 과정을 거치는 것이다.</p>
<p>const person = (firstName, lastName) =&gt; ({ first: firstName, last: lastName }); console.log(person(“Flad”, “Hanson”));</p>
<p>클래스와 객체의 차이 객체를 위한 설계도를 클래스라고 한다. 클래스는 만든다고 해서 메모리에 올라가지 않음</p>
<p>클래스는 객체를 만들기 위한 설계도.</p>
<p>클래스 자체는 그저 정의일 뿐, 이것을 만들었다고 해서 바로 메모리에 올라가거나 실행되는 것은 아닙니다. 클래스는 객체가 가져야 할 속성(데이터)과 동작(메서드)을 정의할 뿐입니다.</p>
<p>클래스가 메모리에 올라가는 시점은 객체를 생성할 때입니다.</p>
<p>객체는 클래스의 인스턴스로, 클래스에서 정의한 속성들과 메서드를 실제로 사용하는 실체입니다. 객체가 생성되면 그때 클래스의 구조에 따라 메모리에 적재됩니다.</p>
<p>일반 함수는 this를 새롭게 바인딩한다.</p>
<p>바인딩(Binding)이란?</p>
<p>바인딩은 프로그래밍에서 특정 값이나 객체를 특정 변수 또는 키워드에 연결하는 과정을 의미한다. 쉽게 말해, 어떤 변수나 키워드가 실제로 가리키는 대상(값 또는 객체)을 결정하는 과정이다.</p>
<p>왜 바인딩이 중요한가?</p>
<p>과거에는 프로그래밍에서 바인딩 개념이 명확하지 않았을 수 있지만, 점점 더 복잡한 프로그램을 작성하다 보면 바인딩이 왜 중요한지 느끼게 됩니다.</p>
<p>특히 객체지향 프로그래밍에서, 객체들이 상호작용하는 방식과 객체 내의 메서드가 특정 컨텍스트에서 어떻게 동작하는지 이해하는 데 있어서 바인딩은 중요한 개념이다.</p>
<p>예를 들어, 객체지향 프로그래밍에서는 클래스의 인스턴스를 생성하고, 그 인스턴스의 메서드가 특정 객체와 결합되어 동작하게 된다.</p>
<p>이 과정에서 변수나 메서드가 어떤 객체에 연결되는지(바인딩되는지)를 알아야 합니다.</p>
<p>자바스크립트에서 this 바인딩 자바스크립트에서는 바인딩은 중요한 개념이다. 자바스크립트의 this 키워드는 함수가 호출될 때 그 함수의 문맥에 따라 달라진다.</p>
<p>그 이유는 함수가 호출되는 방식에 따라 this가 가리키는 객체가 결정되기 때문이며, 이것은 5가지 방식으로 나타낼 수 있다.</p>
<p>this 바인딩의 5가지 방식</p>
<ol type="1">
<li><p>전역 바인딩 (Default Binding)함수가 그냥 호출되면 this는 전역 객체 (브라우저에서는 window, Node.js에서는 global)를 가리킨다.</p></li>
<li><p>암시적 바인딩 (Implicit Binding)함수가 객체의 메서드로 호출되면 this는 그 객체를 가리킨다.</p></li>
<li><p>명시적 바인딩 (Explicit Binding)call, apply, bind를 사용해서 명시적으로 this를 설정할 수 있다.</p></li>
<li><p>new 바인딩</p></li>
</ol>
<p>new 키워드를 사용해 생성자 함수를 호출하면, this는 새로 생성된 객체를 가리킨다.</p>
<ol start="5" type="1">
<li>화살표 함수 바인딩 (Lexical Binding)화살표 함수는 this를 자신의 외부 컨텍스트에서 상속받는다. 즉, 화살표 함수의 this는 정의된 위치의 문맥에 의해 결정된다.</li>
</ol>
<p>호출시점이 동적으로 결정된다.</p>
<p>const tahoe = { mountains: [“Freel”, “Rose”, “Tallac”, “Rubicon”, “Silver”], print: function(delay = 1000) { setTimeout(function() { console.log(this.mountains.join(“,”)); }, delay); } }; tahoe 객체를 가리키지 않아 에러가 난다. function()함수를 화살표 함수로 바꿔야만 오류가 해결된다.</p>
<p>const tahoe = { mountains: [“Freel”, “Rose”, “Tallac”, “Rubicon”, “Silver”], print: function(delay = 1000) { setTimeout(() =&gt; { console.log(this.mountains.join(“,”)); }, delay); } }; tahoe.print(); // Freel, Rose, Tallac, Rubicon, Silver Compiling JavaScript JavaScript는 전통적으로 인터프리터 언어로, 컴파일 단계 없이 실행 시에 코드가 해석된다.</p>
<p>그러나 최신 JavaScript와 다양한 브라우저 환경을 지원하기 위해 컴파일처럼 작동하는 몇 가지 도구가 사용되기도 한다.</p>
<p>이를 컴파일링이나 트랜스파일링이라고 부르며, 대표적인 도구로는 Babel(바벨)이 있다.</p>
<p>JavaScript의 컴파일 개념 JavaScript는 보통 직접 기계어로 변환되는 것이 아니라, 바이트코드로 변환되어 실행된다.</p>
<p>예를 들어, V8 엔진(Chrome, Node.js에서 사용)은 JavaScript 코드를 바이트코드로 변환하여 최적화된 방식으로 실행한다.</p>
<p>여기서 바이트코드는 Java와 유사하게 가상 머신(Virtual Machine)에서 실행된다.</p>
<p>Babel(바벨)</p>
<p>최신 ECMAScript(ES6, ES7 등) 표준을 옛 브라우저나 구형 환경에서도 사용할 수 있도록 트랜스파일링을 수행하는 도구입니다.</p>
<p>트랜스파일링은 최신 문법을 구형 문법으로 변환해 주는 작업으로, 예를 들어 const, let, arrow function 등을 구버전 브라우저에서 지원할 수 있게 변환합니다.</p>
<p>Babel을 사용하면, 새로운 기능이나 문법을 적용한 코드를 구형 환경에서도 동작할 수 있게 해 주므로, 개발자는 최신 기능을 활용할 수 있습니다.</p>
<p>엄격 모드(Strict Mode)</p>
<p>use strict;를 통해 JavaScript의 엄격 모드를 활성화하면, 더 엄격한 오류 검사가 이루어집니다.</p>
<p>선언되지 않은 변수를 사용하는 것이 금지되고, JavaScript의 몇 가지 불안정한 기능이 비활성화됩니다.</p>
<p>바벨로 변환할 때 이 엄격 모드 역시 코드의 일관성을 유지하고 잠재적인 오류를 방지하는데 도움을 줍니다.</p>
<p>이 코드는 ES6(ECMAScript 2015)의 문법을 사용하는 예이다.</p>
<p>// p.46 const add = (x = 5, y = 10) =&gt; console.log(x + y); add() // 함수 호출</p>
<ol type="1">
<li>기본 매개변수(Default Parameters) 함수의 매개변수 x와 y는 각각 5와 10이라는 기본값을 가지고 있다. 만약 함수 호출 시 x나 y 값을 전달하지 않으면 기본값이 사용된다.</li>
</ol>
<p>예: add()를 호출하면 x는 5, y는 10으로 계산되어 15가 출력된다.</p>
<ol start="2" type="1">
<li>화살표 함수(Arrow Function) 화살표 함수 문법을 사용하여 함수를 정의한 것이다.</li>
</ol>
<p>화살표 함수는 더 짧고 간결하게 함수를 작성할 수 있게 해 주며, 기존의 function 키워드 대신 사용할 수 있다.</p>
<ol start="3" type="1">
<li>console.log() 주어진 인자를 콘솔에 출력하는 함수. 이 코드에서는 x, y를 더한 결과를 콘솔에 출력한다.</li>
</ol>
<p>이전 코드에 비해 확실히 길어진 것을 알 수 있다. 이 코드는 use strict를 사용하여 JavaScript의 엄격 모드에서 동작하도록 설정한 후, add라는 함수를 정의한 것이다.</p>
<p>// p.47 “use strict”; var add = function add() { var x = arguments.length &lt;= 0 || arguments[0] === undefined ? 5 : arguments[0]; var y = arguments.length &lt;= 1 || arguments[1] === undefined ? 10 : arguments[1]; return console.log(x + y); }; add() // 함수 호출</p>
<p>이 코드는 Babel과 같은 트랜스파일러를 사용했을 때 최신 JavaScript 문법(ES6)에서 구문이 변환된 형태처럼 보입니다.</p>
<p>함수는 두 개의 기본 매개변수 x, y를 사용하며, 각각 기본값으로 5와 10을 가지도록 설정되었다.</p>
<p>코드를 실행하면 x와 y의 합을 콘솔에 출력합니다.</p>
<ol type="1">
<li><p>use strict (엄격 모드) 엄격 모드를 활성화하면 JavaScript의 더 엄격한 오류 검사를 수행한다. 선언되지 않은 변수를 사용하는 등의 실수를 방지해준다.</p></li>
<li><p>함수 정의 함수는 add라는 이름을 가지고 있으며 기본 매개변수 x = 5, y = 10을 사용한다. ES5로 변환된 코드에서 arguments 객체를 사용하여 함수에 전달된 인수를 확인한다.</p></li>
</ol>
<p>만약 x와 y가 전달되지 않으면 각각 기본값이 할당된다.</p>
<ol start="3" type="1">
<li>변환된 코드 설명 이 코드는 최신 화살표 함수 문법을 전통적인 함수로 변환한 것과 유사합니다. 다음과 같이 변환된 이유는 최신 ES6 문법을 지원하지 않는 환경에서도 동작하도록 하기 위함이다.</li>
</ol>
<p>첫번째 인자가 정의되어 있지 않으면, 뭐뭐해라 매우 엄격하게 정의해서 실행하게끔 이러한 식으로 변환이 된다.</p>
<p>객체와 배열</p>
<p>const sandwich = { bread: “dutch crunch”, meat: “tuna”, cheese: “swiss”, toppings: [“lettuce”, “tomato”, “mustard”] }; const { bread, meat } = sandwich; console.log(bread, meat); // dutch crunch tuna 매칭을 시켜서 재구화되어서 출력이 된다. 객체의 필드를 띄어내서 매칭을 시키는 유연한 문법이다.</p>
<p>다른 언어에서는 볼 수 없는 문법이다.</p>
<p>//이전과 동일한 코드 const sandwich = { bread: “dutch crunch”, meat: “tuna”, cheese: “swiss”, toppings: [“lettuce”, “tomato”, “mustard”] };</p>
<p>let { bread, meat } = sandwich; bread = “garlic”; meat = “turkey”; console.log(bread); // garlic console.log(meat); // turkey console.log(sandwich.bread, sandwich.meat); // dutch crunch tuna</p>
<p>재구조화</p>
<p>const lordify = regularPerson =&gt; { console.log(<code>${regularPerson.firstname} of Canterbury</code>); }; const regularPerson = { firstname: “Bill”, lastname: “Wilson” }; lordify(regularPerson); // Bill of Canterbury 전달되는 사람의 이름을 출력하는 것 이 객체를 함수에 전달, 함수는 잘라서 전달 즉, 스크립트 엔진이 알아서 해준다는 것.</p>
<p>퍼스트 네임은 맴버이다.</p>
<p>도트를 안 써도 도출이 된다. 리플레트 효과라고 한다.</p>
<p>const lordify = ({ firstname }) =&gt; { console.log(<code>${firstname} of Canterbury</code>); }; const regularPerson = { firstname: “Bill”, lastname: “Wilson” }; lordify(regularPerson); // Bill of Canterbury</p>
<p>빅데이터에서 자주 사용되는 기</p>
<p>const regularPerson = { firstname: “Bill”, lastname: “Wilson”, spouse: { firstname: “Phil”, lastname: “Wilson” } };</p>
<p>list matching</p>
<p>const [firstAnimal] = [“Horse”, “Mouse”, “Cat”]; console.log(firstAnimal); // Horse 이것을 전달하니 첫번째 데이터가 나온다. 즉, 객체처럼 작동한다.</p>
<p>배열의 첫번째 주소를 넘기기 때문이며 절대 전체 주소를 넘길 수 없다.</p>
<p>C언어를 배웠다면, 알고 있을 지극히 당연한 문법 성질이다.</p>
<p>const [, , thirdAnimal] = [“Horse”, “Mouse”, “Cat”]; console.log(thirdAnimal); // Cat</p>
<p>리터럴, 고정된 값</p>
<p>const name = “Tallac”; const elevation = 9738; const funHike = { name, elevation }; console.log(funHike); // {name: “Tallac”, elevation: 9738} 약 2968m</p>
<p>const name = “Tallac”; const elevation = 9738; const print = function() { console.log(<code>Mt. ${this.name} is ${this.elevation} feet tall</code>); }; const funHike = { name, elevation, print }; funHike.print(); // Mt. Tallac is 9738 feet tall 기능을 만들어 놓음 이것은 객체를 만들 다음</p>
<p>구식(old) 방식과 신식(new) 방식의 자바스크립트 객체 생성 방식의 차이 // Old var skier = { name: name, sound: sound, powderYell: function() { var yell = this.sound.toUpperCase(); console.log(<code>${yell} ${yell} ${yell}!!!</code>); }, speed: function(mph) { this.speed = mph; console.log(“speed:”, mph); } }; // New const skier = { name, sound, powderYell() { let yell = this.sound.toUpperCase(); console.log(<code>${yell} ${yell} ${yell}!!!</code>); }, speed(mph) { this.speed = mph; console.log(“speed:”, mph); } }; 타이핑을 덜하도록 만들었다.</p>
<p>var는 함수 스코프를 가지며 재선언이 가능하지만, const는 블록 스코프를 가지며 재할당이 불가능합니다.</p>
<p>신식 방식에서는 메서드를 정의할 때 function 키워드를 생략할 수 있어 코드가 더 간결해집니다.</p>
<p>속성의 이름과 값이 같을 경우 축약 표현을 사용할 수 있어 코드의 가독성이 높아집니다.</p>
<p>스프레드 연산자</p>
<p>가변인자</p>
<p>const peaks = [“Tallac”, “Ralston”, “Rose”]; const canyons = [“Ward”, “Blackwood”]; const tahoe = […peaks, …canyons]; console.log(tahoe.join(“,”)); // Tallac, Ralston, Rose, Ward, Blackwood</p>
<p>역순 출력</p>
<p>const peaks = [“Tallac”, “Ralston”, “Rose”]; const [last] = peaks.reverse(); console.log(last); // Rose console.log(peaks.join(“,”)); // Rose, Ralston, Tallac 여기서 원본 배열은 절대 건드리면 안된다.</p>
<p>현재는 데이터가 매우 많다 어떠한 작업을 할 때 원본 데이터가 회손이 되면 원본 데이터를 볼 수가 없게 되는 것이다.</p>
<p>이것은 문법적인 오류가 아니므로 이를 원본이 이미 회손된 이후에는 늦으므로 이를 인지하는 것이 매우 중요하다</p>
<p>그러므로, 자바에세는 클론이라는 것이 있음 얕은 복사, 깊은 복사를 통해 원본 데이터를 유지하는 것이다.</p>
<p>사본 만들기</p>
<p>const peaks = [“Tallac”, “Ralston”, “Rose”]; const [last] = […peaks].reverse(); console.log(last); // Rose console.log(peaks.join(“,”)); // Tallac, Ralston, Rose 모든 데이터에 대한 작업은 사본을 먼저 만든 다음에 해야 된다.</p>
<p>자동 분할</p>
<p>const lakes = [“Donner”, “Marlette”, “Fallen Leaf”, “Cascade”]; const [first, …others] = lakes; console.log(others.join(“,”)); // Marlette, Fallen Leaf, Cascade</p>
<p>function directions(…args) { let [start, …remaining] = args; let [finish, …stops] = remaining.reverse(); console.log(<code>drive through ${args.length} towns</code>); console.log(<code>start in ${start}</code>); console.log(<code>the destination is ${finish}</code>); console.log(<code>stopping ${stops.length} times in between</code>) ;} directions(“Truckee”, “Tahoe City”, “Sunnyside”, “Homewood”, “Tahoma”); 출력 결과 예측하기</p>
<p>const morning = { breakfast: “oatmeal”, lunch: “peanut butter and jelly” }; const dinner = “mac and cheese”; const backpackingMeals = { …morning, dinner }; console.log(backpackingMeals); // { // breakfast: “oatmeal”, // lunch: “peanut butter and jelly”, // dinner: “mac and cheese” // } 스프레드 시크 모닝</p>
<p>비동기</p>
<p>쿠팡 쇼핑몰과 같은 사이트를 만드는 개발자에게 최적화된 자바스크립트 노드에서 만들면 앱에서도 빌려서 쓰는 것이 가능하기 때문</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_02.html</guid>
  <pubDate>Fri, 04 Oct 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개론</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_00.html</link>
  <description><![CDATA[ 




<section id="서론" class="level1">
<h1>1. 서론</h1>
<p>프로그래밍 언어(특히 고급언어)는 인간이 이해하기 쉬운 형태로 작성되지만, 컴퓨터는 기계어(이진수 형태)만을 이해할 수 있다.</p>
<p>그래서 소스 코드를 작성한 후, 컴파일러라는 프로그램을 사용하여 소스 코드를 기계어로 변환하는 과정이 필요하다.</p>
<p>이 과정을 컴파일이라고 부르며, 기계가 실행할 수 있는 바이너리 코드 또는 실행 파일을 생성하게 된다.</p>
<p>하지만 스크립트 언어는 보통 컴파일 과정 없이 소스 코드를 바로 실행할 수 있다.</p>
<p>스크립트 언어는 주로 인터프리터라는 프로그램이 코드를 한 줄씩 읽고 바로 실행한다. 대표적인 스크립트 언어로는 <code>Python, JavaScript</code> 등이 있다.</p>
<p>컴퓨터 기술의 초기 개발은 군사 목적으로 진행된 경우가 많았다.</p>
<p>특히 제2차 세계대전 동안 미사일 발사와 암호 해독과 같은 군사 목적을 위해 컴퓨터가 발명되었다.</p>
<p>앨런 튜링은 컴퓨터 과학의 아버지로 불리며, 제2차 세계대전 당시 독일의 에니그마 암호를 해독하는 데 중요한 역할을 했다.</p>
<p>이를 통해 현대 컴퓨터 과학의 기초를 세웠다.</p>
<p>초기 컴퓨터들은 크기가 매우 컸다.</p>
<p>예를 들어, 애니악(ENIAC)은 운동장만한 크기의 첫 상업용 컴퓨터 중 하나로, 많은 진공관을 사용해 작동했으며, 이 진공관의 전원을 끄고 켜는 방식으로 0과 1의 이진수(기계어)를 표현했다.</p>
<p>이는 컴퓨터가 논리적 연산을 수행하는 기본 방식이다.</p>
<p>CPU는 컴퓨터의 중앙 처리 장치로, 저급언어(기계어)로 작동한다. 이 저급언어는 0과 1로 구성되어 있으며, CPU가 직접 이해하고 실행할 수 있다.</p>
<p>고급언어는 인간이 이해하기 쉽게 작성된 언어로, CPU가 실행할 수 있도록 기계어로 변환하는 컴파일 과정이 필요하다.</p>
<p>예를 들어 C 언어는 고급언어이며, 유닉스는 C 언어로 개발된 대표적인 운영체제이다.</p>
<p>변수는 데이터를 저장하는 임시 공간이다. 프로그래밍에서 변수는 값을 저장하고 나중에 재사용할 수 있게 해준다.</p>
<p>var는 자바스크립트에서 오래된 방식으로 변수를 선언하는 키워드. var로 선언된 변수는 함수 스코프를 가진다.</p>
<p>let는 ES6(ECMAScript 2015)에서 추가된 키워드로, 블록 스코프를 가진다. 즉, 변수가 선언된 블록 내에서만 유효하다.</p>
<p>const도 ES6에서 추가된 키워드로, 상수를 선언할 때 사용한다. const로 선언한 변수는 재할당이 불가능하며, 블록 스코프를 가진다.</p>
<p>즉, 한번 값을 할당하면 변경할 수 없고 const 키워드로 선언한 변수는 재할당이 불가능하다.</p>
<p>const a = 10; a = 20; // 오류 발생</p>
<p>하지만 const로 선언된 객체의 속성은 변경할 수 있다.</p>
<p>const obj = { name: “Alice” }; obj.name = “Bob”; // 가능</p>
<p>var topic = “JavaScript”; // 전역 변수 topic 선언 및 초기화 if (topic) { // topic이 truthy한 값이므로 이 블록이 실행됨 var topic = “React”; // var로 재선언, 전역 스코프에 영향을 미침 console.log(“block”, topic); // block React } console.log(“global”, topic); // global React</p>
<p>let 키워드를 사용하면 var의 전역 스코프 문제를 해결할 수 있다. let은 블록 스코프를 따르므로, 변수가 선언된 블록 내부에서만 유효하게 동작한다.</p>
<p>이를 통해 의도치 않은 값의 덮어쓰기를 방지할 수 있다.</p>
<p>node클릭</p>
<p>var name = “name”; console.log(name);</p>
<p>스칼라를 동적으로 사용하려면, 코딩이 제대로 되어 있는지 인간이 직접 분석하고 판단해야 한다.</p>
<p>세부적인 부분은 반드시 개발자가 직접 처리해야 한다.</p>
<p>C언어는 기초 언어 p.32</p>
<p>ECMA 컴퓨터 제조 위원회는 JavaScript 표준을 만들고 이를 승인하는 역할을 한다.</p>
<p>ES6까지는 var 키워드를 사용해 변수를 선언했으나, 이 방식에는 여러 문제가 있었다. 예를 들어, 상수를 선언할 방법이 없었으며, var로 선언된 변수는 재할당이 가능했다.</p>
<p>ES2015(ES6)부터는 const 키워드를 도입해 상수 선언이 가능해졌다. 현재 JavaScript 표준은 ES2024로 발전했다.</p>
<p>const pizza = true; pizza = false;</p>
<p>함수는 특정 기능을 수행하는 코드의 집합이다. 블록은 중괄호 {}로 감싸진 코드 영역을 의미하며, 일종의 상자로 비유할 수 있다.</p>
<p>블록 안에서 선언된 변수는 지역 변수로, 해당 블록 내에서만 접근이 가능하다.</p>
<p>let &amp; const ES6 (ECMAScript 2015)에서 도입된 새로운 변수 선언 키워드. var 로 인한 몇 가지 문제점을 해결하기 위해 만들어졌다.</p>
<p>1 . 스코프(scope) 문제 var는 함수 스코프를 가지며, 블록(if, for, while 등) 안에서 선언된 변수도 블록을 벗어나면 여전히 접근이 가능하다.</p>
<p>이는 개발자가 의도하지 않은 변수 접근이나 값의 변경을 일으킬 수 있다.</p>
<p>let과 const는 블록 스코프를 따른다.</p>
<p>중괄호 {} 안에서 선언된 변수는 해당 블록 내부에서만 유효하고, 블록을 벗어나면 소멸된다. 이로 인해 변수가 의도하지 않은 곳에서 사용되는 문제를 방지할 수 있다.</p>
<p>2 . 변수 호이스팅(hoisting) 문제 var로 선언된 변수는 호이스팅이 되어, 코드 상에서 변수를 선언하기 전에 접근할 수 있다.</p>
<p>하지만 변수는 선언된 시점 이전에 undefined로 초기화된다. 이로 인해 코드의 가독성이 떨어지고, 오류를 유발할 수 있다.</p>
<p>let과 const는 변수 호이스팅이 발생하지만, 일시적 사각지대(TDZ) 때문에 변수를 선언하기 전에는 접근할 수 없다.</p>
<p>이는 더 안전한 변수 사용을 가능하게 한다.</p>
<p>3 . 중복 선언 문제 var은 같은 스코프 내에서 동일한 이름으로 변수를 중복 선언할 수 있다.</p>
<p>let은 같은 스코프 내에서 동일한 이름으로 변수를 중복 선언할 수 없으며, 중복 선언 시 오류가 발생한다.</p>
<p>var topic = “JavaScript”; if (topic) { var topic = “React”; console.log(“block”, topic); // block React } console.log(“global”, topic); // global React</p>
<p>아래와 같이 작성하여 지역변수와 전역변수를 동작한다. 자바에서는 이것이 당연하게 일어나지 않아 이 문제점을 해결하였다.</p>
<p>var topic = “JavaScript”; if (topic) { let topic = “React”; console.log(“block”, topic); // React } console.log(“global”, topic); // JavaScript</p>
<p>호이스팅(Hoisting)이란 컴퓨터가 코드를 실행하기 전에 전체를 미리 살펴보고, 변수와 함수의 선언을 메모리에 먼저 올려두는 과정을 의미한다.</p>
<p>이로 인해 변수나 함수가 나중에 초기화되더라도 에러 없이 실행이 가능하다. 다만, 변수는 초기화 전에 접근할 경우 기본값인 undefined를 출력한다.</p>
<p>한편, JavaScript는 초기 웹 개발자들의 편의를 위해 변수와 함수 사용에 대한 규제를 느슨하게 설계했다.</p>
<p>이는 코드가 운영체제(기계)에 직접적인 영향을 미친다는 점에서 유연성과 엄격함 사이의 균형을 고려한 결정이었다.</p>
<p>consoloe.log(a) var a = 1; consoloe.log(a)</p>
<p>에러가 발생하지 않고 그대로 출력되는 것을 알 수 있다.</p>
<p>for(var i = 0; i &lt; 5; i++){ console.log(i); } console.log(i);</p>
<p>지역변수와 전역변수의 역할이 나누어져 에러가 나타나는 것을 알 수 있다.</p>
<p>for(let i = 0; i &lt; 5; i++){ console.log(i); } console.log(i);</p>
<p>DOM 개념 본래 각 박스를 클릭할 때, 1 ~ 5 까지 순서대로 출력되어야 하나 어떤 박스를 클릭해도 5가 나오는 에러가 발생한다.</p>
<p>var div, container = document.getElementById(“container”);</p>
<p>for (var i = 0; i &lt; 5; i++) { div = document.createElement(“div”); div.onclick = function() { alert(“This is box #” + i); }; container.appendChild(div); }</p>
<p>따라서, 변수 선언 시에는 항상 let 키워드를 사용하는 것이 좋으며, 특히 React와 같은 환경에서는 let을 더욱 권장한다.</p>
<p>JavaScript는 변수의 자료형을 명시적으로 지정할 필요 없이 자동으로 결정한다. 이 과정을 타입 추론이라고 하며, 이는 var 키워드가 제공하는 특징 중 하나다.</p>
<p>참고:</p>
<p>파이썬의 철학은 최소한의 타이핑으로 간결하게 코드를 작성하자는 데 있다. 이를 구현하기 위해 엔진과 컴파일러가 이러한 원칙에 맞춰 설계되었다.</p>
<p>반면, 자바는 상대적으로 모든 것을 상세히 작성해야 하는 특징이 있다.</p>
<ul>
<li>는 값을 더하는 역할뿐만 아니라 문자열을 연결하는 기능도 수행한다.</li>
</ul>
<p>과거에는 +를 사용해야 할 상황에서 이를 실수로 생략하는 경우가 종종 있었으며, 이로 인해 여러 번 오류가 발생한 경험이 있다.</p>
<p>console.log(lastName + “,” + firstName + ” ” + middleName);</p>
<p>데이터 바인딩 서버에서 데이터를 넘겨줘서 클라이언트에 보여주는 것. 데이터를 담고 보여줘야 할 때, 이때 이 개념을 사용한다.</p>
<p>console.log(<code>${lastName}, ${firstName} ${middleName}</code>);</p>
<p>사람마다 다르다.</p>
<p>const email = <code>Hello ${firstName}, Thanks for ordering ${qty} tickets to ${event}. Order Details ${firstName} ${middleName} ${lastName} ${qty} x $${price} = $${qty*price} to ${event} You can pick your tickets up 30 minutes before the show. Thanks, ${ticketAgent}</code> 이것은 실습을 알 수 없음, 데이터가 있어야 가능하다.</p>
<p>document.body.innerHTML = <code>&lt;section&gt; &lt;header&gt; &lt;h1&gt;The React Blog&lt;/h1&gt; &lt;/header&gt; &lt;article&gt; &lt;h2&gt;${article.title}&lt;/h2&gt; ${article.body} &lt;/article&gt; &lt;footer&gt; &lt;p&gt;copyright ${new Date().getYear()} | The React Blog&lt;/p&gt; &lt;/footer&gt; &lt;/section&gt;</code>; 이러한 것을 템플릿이라고 한다.</p>
<p>모든 것을 객체로 보고, 객체 간에 상호작용을 보는 것</p>
<p>함수 만들기</p>
<p>리텃 유형, ()가 붙은 건 함수, {}는 블럭이다. 이 함수가 호출되면 블럭이 실행되도록 한다.</p>
<p>// 함수 선언 function logCompliment() {</p>
<p>console.log(“You’re doing great!”); }</p>
<p>logCompliment(); 이것은 사용자 정의함수, 파이썬의 print()에 경우 개발자가 미리 만들어 놓았다.</p>
<p>const logCompliment = function() { console.log(“You’re doing great!”); };</p>
<p>logCompliment();</p>
<p>외부 클래스와 상호작용하기 싫다면 함수의 인자로 함수 전달 간단하게 함수를 만들어 쓰기</p>
<p>// Invoking the function before it’s declared hey(); // Function Declaration function hey() { alert(“hey!”); }</p>
<p>그러나 아래의 코드는 에러가 발생한</p>
<p>// Invoking the function before it’s declared hey(); // Function Expression const hey = function() { alert(“hey!”); };</p>
<p>const logCompliment = function(firstName) { console.log(<code>You're doing great, ${firstName}</code>); };</p>
<p>logCompliment(“Molly”);</p>
<p>2가지 선언</p>
<p>const logCompliment = function(firstName, message) { console.log(<code>${firstName}: ${message}</code>); };</p>
<p>logCompliment(“Molly”, “You’re so cool”);</p>
<p>const lordify = firstName =&gt; <code>${firstName} of Canterbury</code></p>
<p>Default Parameters function logActivity(name = “Shane McConkey”, activity = “skiing”) { console.log(<code>${name} loves ${activity}</code>); }</p>
<p>유연하게 대체하도록</p>
<p>function logActivity(name = “Shane McConkey”, activity = “skiing”) { console.log(<code>${name} loves ${activity}</code>); }</p>
<p>화살표</p>
<p>const lordify = firstName =&gt; <code>${firstName} of Canterbury</code>;</p>
<p>// Typical function const lordify = function(firstName, land) { return <code>${firstName} of ${land}</code>; };</p>
<p>// Arrow Function const lordify = (firstName, land) =&gt; <code>${firstName} of ${land}</code>;</p>
<p>console.log(lordify(“Don”, “Piscataway”)); // Don of Piscataway console.log(lordify(“Todd”, “Schenectady”)); // Todd of Schenectady</p>
<p>const lordify = (firstName, land) =&gt; { if (!firstName) { throw new Error(“A firstName is required to lordify”); } if (!land) { throw new Error(“A lord must have a land”); } return <code>${firstName} of ${land}</code>; }; console.log(lordify(“Kelly”, “Sonoma”)); // Kelly of Sonoma console.log(lordify(“Dave”)); // ! JAVASCRIPT ERROR</p>
<p>릭터닝 객체, 44페이</p>
<p>const person = (firstName, lastName) =&gt; { first: firstName, last: lastName } console.log(person(“Brad”, “Janson”)); 람다 1930년, 기본철학은 자바, 파이썬이 쉬워진다.</p>
<p>컴퓨터가 많은 방은 차가워야 맞음, 70, 80도 항상 24도 맞춰 놓음 추석 떄 전자출석이 더워서 서버가 장애를 일으킴</p>
<p>리엑트!!!</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_00.html</guid>
  <pubDate>Sun, 22 Sep 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>React 설치</title>
  <dc:creator>Learning React: Modern Patterns for Developing React Apps</dc:creator>
  <link>https://shinjihan.github.io/studylog/pd/re/re_01.html</link>
  <description><![CDATA[ 




<p>https://github.com/kpyszkowski/kpyszkowski/blob/main/books/Alex%20Banks%20%26%20Eve%20Porcello%20-%20Learning%20React%3A%20Learning%20React%20Modern%20Patterns%20for%20Developing%20React%20Apps%20-%20O%E2%80%B2Reilly%20(2020).pdf</p>
<p>구글 검색창에 Welcome to React - Learning React [Book]이라고 치면 원본 PDF 나온다. 이는 미번역본이다.</p>
<p>https://ko.react.dev/learn 전문 사이트로 참고할 것.</p>
<p>교재의 Chapter 1. Welcome to React를 참고하여 React(리엑트) 설치에 대해 다루고자 한다.</p>
<p>1 . React 개발 도구 설치 React로 만든 웹 애플리케이션을 디버깅하고 검사하기 위한 브라우저 확장 도구이다.</p>
<p>https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?pli=1</p>
<p>이 도구는 크롬이나 파이어폭스와 같은 브라우저의 개발자 도구에 통합되어, React 컴포넌트 구조를 쉽게 탐색할 수 있도록 돕는다.</p>
<p>이 앱을 크롬에 설치한 후 상태 표시를 확인하라.</p>
<ol type="1">
<li>Node.js 설치</li>
</ol>
<p>https://nodejs.org/en</p>
<p>Node.js는 JavaScript 런타임 환경으로, JavaScript를 서버 사이드에서 실행할 수 있게 해준다.</p>
<p>다운로드한 후, 로컬 드라이브에 저장한다.</p>
<p>(가장 아래)</p>
<ol start="3" type="1">
<li>npm 설치 (Node Package Manager)</li>
</ol>
<p>Node.js의 패키지 매니저로, 수많은 자바스크립트 라이브러리와 패키지가 모여 있는 저장소이다. 개발자는 필요한 라이브러리나 모듈을 npm을 통해 간편하게 설치하고 사용할 수 있다.</p>
<p>예를 들어, React나 Express 같은 자주 사용하는 라이브러리도 npm으로 설치할 수 있다.</p>
<ol type="1">
<li>프로젝트 초기화 명령어 프로젝트의 기본 설정을 자동으로 생성해 준다.</li>
</ol>
<p>npm init -y // 기본 설정을 자동으로 생성</p>
<p>이 명령어를 실행하면 package.json 파일이 생성되며, 프로젝트의 이름, 버전, 스크립트 등을 설정하는 데 사용된다.</p>
<p>여기서 -y 옵션은 npm init 명령어의 질문에 대한 기본 값을 자동으로 입력해준다.</p>
<p>만약 사용자가 직접 설정을 수정하거나 설정 내용을 변경하려면 아래 명령어를 입력하고 각 질문에 응답하면 된다.</p>
<p>npm init // 사용자가 직접 수정</p>
<p>이 명령어 자체는 심각한 문제를 일으키지 않으며, 생성된 package.json 파일은 언제든지 수정할 수 있다.</p>
<p>다만, 프로젝트를 관리하고 설정하는 과정에서는 신중함이 필요하다.</p>
<ol start="2" type="1">
<li>Yarn 설치 Yarn 패키지를 현재 프로젝트의 로컬 디렉터리에 설치한다. 이 경우 해당 프로젝트에서만 Yarn을 사용할 수 있다.</li>
</ol>
<p>npm install yarn</p>
<p>Yarn 패키지를 전역(-g: global)으로 설치한다.</p>
<p>이렇게 하면 특정 프로젝트와 상관없이, 컴퓨터의 모든 디렉터리에서 Yarn 명령어를 사용할 수 있다.</p>
<p>npm install -g yarn</p>
<ol start="3" type="1">
<li>버전(version) 확인 명령어 현재 시스템에 설치된 Node.js의 버전을 확인하는 명령어이다.</li>
</ol>
<p>Node -v // v20.17.0</p>
<p>현재 시스템에 설치된 npm의 버전을 확인하는 명령어이다.</p>
<p>npm -v // 10.8.2</p>
<p>이 명령어들은 Node.js와 npm이 올바르게 설치되었는지, 그리고 최신 버전인지 확인할 때 자주 사용된다.</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/pd/re/re_01.html</guid>
  <pubDate>Sun, 22 Sep 2024 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
