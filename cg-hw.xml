<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>StudyLog</title>
<link>https://shinjihan.github.io/studylog/cg-hw.html</link>
<atom:link href="https://shinjihan.github.io/studylog/cg-hw.xml" rel="self" type="application/rss+xml"/>
<description>통계와 AI를 기록하는 개인 블로그</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Mon, 07 Oct 2024 15:00:00 GMT</lastBuildDate>
<item>
  <title>통신 기술의 기초</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_02.html</link>
  <description><![CDATA[ 




<p>통신 기술에 관한 전반적인 개념에 대해 다루고자 한다.</p>
<section id="산술논리연산장치" class="level1">
<h1>01 산술논리연산장치</h1>
<p><code>Arithmetic and Logic Unit, ALU</code></p>
<p>컴퓨터 내부에서 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행하는 하드웨어 부품.</p>
<p>예를 들어, 7을 3으로 나눌 때 몫과 나머지를 각각 구하는 연산은 ALU에서 처리된다.</p>
<p>이때, 몫은 7 / 3 = 2, 나머지는 7 % 3 = 1로 계산된다.</p>
<p>CPU와 MCU 모두 ALU를 가지고 있으며, 산술 연산과 논리 연산을 처리하는 핵심 컴포넌트이다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU는 컴퓨터의 중앙 처리 장치로, 복잡한 계산을 수행하고, 메모리와 입출력 장치와의 데이터 처리를 담당한다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>작은 컴퓨터 시스템을 내장한 마이크로칩으로, 주로 임베디드 시스템에서 사용된다.</p>
<p>MCU는 CPU에 비해 상대적으로 간단하고 저전력, 소형화된 시스템으로, 제한된 리소스 환경에서도 효율적으로 동작한다.</p>
<p>02 레지스터 (Register)</p>
<p>컴퓨터의 CPU 내에서 데이터나 명령어를 저장하고 처리하는 빠른 기억 장치.</p>
<p>CPU는 연산을 수행하거나 메모리와 데이터 교환 시 레지스터를 사용하여 데이터를 중간에 임시로 저장한다.</p>
<p>레지스터는 메모리 역할을 수행하는 일시적인 저장소 역할을 한다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU 내의 레지스터는 매우 빠른 임시 저장소로, 연산에 필요한 데이터나 명령어를 빠르게 저장하고 처리한다.</p>
<p>CPU 자체는 레지스터 외에 큰 저장공간 역할을 하지 않는다.</p>
<p>CPU는 대량의 데이터를 영구적으로 저장하는 역할을 하지 않으며, 주 메모리(RAM)나 저장장치(HDD, SSD 등)처럼 큰 용량의 데이터를 관리하지 않는다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>MCU는 비교적 작은 시스템으로, 자체적으로 내장 메모리(ROM, RAM)를 가지고 있다.</p>
<p>이 메모리는 프로그램 코드, 변수, 데이터를 저장하는 역할을 하며, CPU처럼 레지스터는 연산에 필요한 데이터를 임시로 저장하는 용도로 사용된다.</p>
<p>MCU는 외부 메모리와 연결하여 더 많은 데이터를 처리할 수 있지만, 레지스터는 여전히 임시 저장소 역할을 한다.</p>
<p>③ 레지스터 초기화 특정 비트를 0으로 설정하려면 AND 연산과 마스크(Mask)를 사용하여 원하는 비트를 0으로 만들 수 있다. 반대로, 특정 비트를 1로 설정하려면, OR 연산과 마스크를 사용한다.</p>
<p>8비트 값이 10101101일 때, 3번째 비트를 0으로 설정하려면 마스크 11110111과 AND 연산을 수행한다.</p>
<p>반대로, 5번째 비트를 1로 설정하려면 마스크 00010000과 OR 연산을 수행한다.</p>
<p>모든 비트를 0으로 설정할 경우, 단순히 레지스터 값을 0으로 초기화하는 것이 일반적이다.</p>
<p>03 RS-232 (Recommended Standard 232)</p>
<p>직렬 통신 프로토콜의 한 종류로, 데이터를 한 비트씩 순차적으로 전송하는 방식이다.</p>
<p>직렬 데이터 전송을 위한 초기 표준. 간단한 구현과 넓은 호환성을 바탕으로 임베디드 시스템과 주변 기기 통신에 오랫동안 사용되어 왔다.</p>
<p>① 통신 방식</p>
<p>TX(전송), RX(수신), GND(접지)와 같은 신호선을 사용하여 데이터를 송수신한다.</p>
<p>기본적으로 비동기식 통신 방식을 채택하고 있으며, 송수신 측이 서로 동기화된 상태에서 데이터를 교환하는 방식이다.</p>
<p>비동기식 통신에서 각 데이터는 스타트 비트, 데이터 비트, 패리티 비트, 스톱 비트로 구분된다.</p>
<p>② 사용 범위 RS-232는 동기식 통신 방식으로도 사용할 수 있다. 이 경우, 클럭 신호를 추가하여 데이터 전송 속도를 동기화한다.</p>
<p>이는 컴퓨터, 서버 간의 통신에 널리 사용되며, 특히 임베디드 시스템에서도 사용된다.</p>
<p>또한, 모뎀, 프린터, 터미널 장치 등과의 연결에도 사용된다.</p>
<p>04 기본 논리 연산 디지털 회로와 프로그래밍에서 사용하는 가장 기본적인 연산으로, 논리 상태(0과 1)를 처리하는 데 사용된다.</p>
<p>아래는 기본 논리 연산의 주요 종류이다.</p>
<p>① AND 두 입력이 모두 참(1)일 때만 결과가 참(1)이 되는 연산.</p>
<p>AND 연산의 진리표</p>
<p>② OR 입력 중 하나라도 참(1)이면 결과가 참(1)이 되는 연산.</p>
<p>OR 연산의 진리표</p>
<p>③ NOT 단일 입력에 대해, 입력이 참이면 결과가 거짓(0), 입력이 거짓이면 결과가 참(1)이 되는 연산.</p>
<p>NOT 연산의 진리표</p>
<p>④ XOR 두 입력이 서로 다를 때만 참(1)이 되는 연산. 즉, 둘 중 하나만 참이어야 참이 된다.</p>
<p>XOR 연산의 진리표</p>
<p>⑤ NAND AND 연산 후에 결과를 부정(NOT)한 연산. AND의 반대 결과를 생성한다.</p>
<p>NAND 연산의 진리표</p>
<p>⑥ NOR OR 연산 후에 결과를 부정(NOT)한 연산. OR의 반대 결과를 생성한다.</p>
<p>NOR 연산의 진리표</p>
<p>이러한 논리 연산은 전자 회로와 디지털 컴퓨터에서 기본 연산으로 사용된다.</p>
<p>간단한 결정이나 조건을 설정하는 데 유용하며, 복잡한 연산도 이러한 기본 연산을 조합하여 처리할 수 있다.</p>
<p>05 통신 기술 Wi-Fi, Bluetooth, 5G 같은 무선 통신 기술에서 데이터 송수신 과정에서 모뎀 역할을 하는 칩셋이나 모듈이 사용되며, 동기/비동기 통신 방식과 대역폭이 전송 속도와 품질에 중요한 영향을 미친다.</p>
<p>서버 기반의 제어 시스템을 조작할 때는 C++과 같은 언어를 활용하여 GUI를 개발하거나 데이터를 효율적으로 처리할 수 있으며,</p>
<p>특히 실시간 데이터 처리와 고성능 연산이 요구되는 환경에서 유용하다.</p>
<p>① 제어 흐름 관리 for 문과 if-else 문을 사용하며, 이를 통해 데이터를 수집하거나 명령을 실행하는 프로세스를 제어하는 코드를 작성한다.</p>
<p>이러한 방식은 시리얼 통신, 네트워크 통신 등 다양한 통신 방식에 맞춰 데이터 패킷을 처리하거나, 사용자 입력을 관리하여 프로그램의 동작을 유연하게 제어하는 데 중요한 역할을 한다.</p>
<p>② C++의 활용 C++는 성능과 메모리 관리를 직접 제어할 수 있는 언어로, 이를 활용하면 실시간 통신 시스템에서 응답성을 크게 향상시킬 수 있다.</p>
<p>특히, 서버 제어 시스템에서 통신 장비와 상호 작용하는 프로그램을 개발할 때, C++의 효율성과 네트워크 라이브러리를 활용하면 안정적이고 빠른 성능을 달성할 수 있다.</p>
<p>③ 디지털 (Digital) 0과 1과 같은 이진 값을 사용하여 정보를 표현한다.</p>
<p>디지털 신호는 일정한 시간 간격으로 구분된 이진 상태를 나타내며, 최소 단위는 비트이다.</p>
<p>이진 상태가 “0”과 “1”로만 표현되므로, 값은 이산적이다.</p>
<p>④ 아날로그 (Analog) 시간에 따라 연속적으로 변화하며, 0과 1 사이의 모든 값을 가질 수 있다.</p>
<p>06 데이터 단위</p>
<p>① 비트 (Bit) 0과 1로 이루어진 가장 작은 데이터 단위. 디지털 정보의 기본 단위로, 두 가지 상태를 표현할 수 있다.</p>
<p>② 니블 (Nibble): 4비트 1니블은 4개의 비트로 구성된다. 보통 1바이트를 2니블로 나누는 데 사용된다.</p>
<p>③ 바이트 (Byte): 8비트 1바이트는 8비트로 이루어지며, 컴퓨터에서 문자나 데이터를 표현하는 기본 단위로 많이 사용된다.</p>
<p>④ 워드 (Word) 프로세서가 한 번에 처리할 수 있는 데이터의 크기로, 시스템 아키텍처에 따라 달라진다.</p>
<p>워드 크기는 아키텍처에 따라 대체로 위와 같이 설정된다.</p>
<p>과거에는 16비트 였던 워드 크기가 현재는 32비트 혹은 64비트로 변화되어 사용된다.</p>
<p>07 진법 컴퓨터와 디지털 시스템에서는 데이터를 다양한 진법으로 표현한다.</p>
<p>각 진법은 사용되는 숫자의 개수와 자리 값을 기반으로 데이터를 표현하며, 특정 진법은 특정 상황에서 유용하다.</p>
<p>① 2진수(Binary)</p>
<p>숫자 2를 기반으로 하는 진법으로, 0과 1의 두 가지 숫자만 사용된다. 디지털 회로와 컴퓨터 내부 연산에서 가장 기본적인 진법이다.</p>
<p>2의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>② 8진수(Octal) 숫자 8을 기반으로 하는 진법으로, 0 ~ 7의 8가지 숫자를 사용한다. 3개의 이진수 그룹을 한 자리의 8진수로 표현할 수 있어, 컴퓨터 시스템에서 간단한 데이터 표현에 사용된다.</p>
<p>8의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>③ 10진수 (Decimal) 우리가 일상생활에서 사용하는 기본 진법.</p>
<p>숫자 10을 기반으로 하는 진법으로, 0 ~ 9의 숫자를 사용한다.</p>
<p>10의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>④ 16진수 (Hexadecimal)</p>
<p>숫자 16을 기반으로 하는 진법으로, 숫자 0 ~ 9와 문자 A ~ F를 사용한다.</p>
<p>문자 A ~ F 는 10 ~ 15의 값을 나타낸다.</p>
<p>4개의 이진수 그룹을 한 자리의 16진수로 표현할 수 있어, 메모리 주소나 색상 표현 등에 자주 사용된다.</p>
<p>16의 거듭제곱으로 자리값이 결정된다.</p>
<p>08 8비트의 정의 8자리의 2진수로 표현되며, 각 자리의 가중치는 다음과 같다:</p>
<p>왼쪽에서 오른쪽으로 자리의 가중치가 점점 작아진다.</p>
<p>① 값의 범위</p>
<p>8비트의 최소값과 최대값</p>
<p>총 가능한 값의 개수는 2⁸ = 256 가지이다. 11111111₂은 각 자리의 가중치를 모두 더하는 방식으로 계산된다.</p>
<p>② 응용 8비트의 범위는 0 ~ 255로, 컴퓨터가 데이터를 저장하거나 표현할 때 자주 사용된다.</p>
<p>색상 표현에서 RGB 값은 각각 0 ~ 255로 표현된다. 문자 저장에 사용되는 ASCII 코드도 보통 8비트를 사용한다.</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_02.html</guid>
  <pubDate>Mon, 07 Oct 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>컴퓨터 그래픽스</title>
  <link>https://shinjihan.github.io/studylog/ch/cg_01.html</link>
  <description><![CDATA[ 




<p>과학, 공학, 의학, 경영 등 다양한 분야에서 활용되는 컴퓨터 그래픽스의 응용 분야에 대해 다루고자 한다.</p>
<p>01 컴 퓨 터 그 래 픽 스 (CG, Computer Graphics)</p>
<p>컴퓨터로 그림을 생성하는 기술.</p>
<p>아래는, 이전부터 활발하게 응용된 분야를 나열한 목록이다.</p>
<p>이 중에서 기술의 상호작용이 두드러지는 가상 현실과 애니메이션 및 게임에서의 응용에 대해 알아보고자 한다.</p>
<p>컴퓨터 그래픽스의 응용분야</p>
<p>메 타 버 스 (Metaverse) 가상현실을 구현한 여러 형태나 콘텐츠들을 통칭한다.</p>
<p>메타버스는 기술적 진보와 인터넷의 발전으로 구현된 디지털 환경이며, 이는 가상세계와 달리, 여러 기술적 요소가 결합된 거대한 디지털 생태계이다.</p>
<p>초월(beyond), 가상을 의미하는 meta와 세계를 의미하는 universe의 합성어이다. (1992년 출간된 소설 ‘스노 크래시’ 속 가상 세계 명칭인 ’메타버스’에서 유래한다.)</p>
<p>라 이 프 로 깅 (Lifelogging) 개인의 삶을 디지털로 기록하여 가상세계로 옮기는 개념으로, 메타버스와 관련이 깊다.</p>
<p>메타버스에서는 사용자들이 디지털 아바타를 통해 자신의 삶을 반영하고, 그 기록을 가상세계에서 공유 및 저장할 수 있다.</p>
<p>삶을 뜻하는 life와 일지 작성을 의미하는 logging의 합성어이다. 특히 logging은 일반적으로 컴퓨터 시스템에서의 사용 기록을 포함하여 모든 행위의 기록을 의미한다.</p>
<p>제페토</p>
<p>내 아바타로 즐기는 또 다른 세상</p>
<p>web.zepeto.me</p>
<ol type="1">
<li>가 상 현 실 (VR, Virtual Reality) 실제와 유사하지만 실제가 아닌 인공 환경. 현실 세계에서 할 수 없는 활동을 할 수 있다.</li>
</ol>
<p>Beat Saber on Steam</p>
<p>Beat Saber is a VR rhythm game where you slash the beats of adrenaline-pumping music as they fly towards you, surrounded by a futuristic world.</p>
<p>store.steampowered.com</p>
<p>Half-Life: Alyx on Steam</p>
<p>Half-Life: Alyx is Valve’s VR return to the Half-Life series. It’s the story of an impossible fight against a vicious alien race known as the Combine, set between the events of Half-Life and Half-Life 2. Playing as Alyx Vance, you are humanity’s only</p>
<p>store.steampowered.com</p>
<p>Microsoft Flight Simulator - The next generation of one of the most beloved simulation franchises</p>
<p>Microsoft Flight Simulator is the next generation of one of the most beloved simulation franchises.</p>
<p>www.flightsimulator.com</p>
<ol start="2" type="1">
<li>증 강 현 실 (AR, Augmented Reality) 현실 세계에 디지털 정보를 추가해 현실의 개념을 확장하는 기술.</li>
</ol>
<p>Pokemon GO – Pokémon GO</p>
<p>GO로켓단 GO로켓단의 마수가 “Pokémon GO”의 세계에 뻗쳐오고 있습니다! “스페셜리서치” 클리어나 “그림자 포켓몬”을 구하는 과정에서, GO로켓단에게 승부를 걸어 야망을 저지할 수 있습니다.</p>
<p>pokemongolive.com</p>
<p>이케아, 비주얼 서치 기능 탑재한 ‘이케아 플레이스’ 안드로이드 앱 출시</p>
<p>[서울 - 3월 21일] 글로벌 홈퍼니싱 기업 이케아는 가상으로 가구를 공간에 배치할 수 있는 증강현실(AR) 앱 ’이케아 플레이스(IKEA Place)’를 안드로이드 버전으로 출시한다.</p>
<p>www.ikea.com</p>
<p>4D Interactive Anatomy</p>
<p>www.4danatomy.com</p>
<ol start="3" type="1">
<li><p>혼 합 현 실 (MR, Mixed Reality) 가상 세계와 현실 세계를 섞어서 VR 헤드셋을 통해 보여주는 것으로 두 가지 유형이 있다.</p></li>
<li><p>가상 객체 ⇨ 현실 세계:</p></li>
</ol>
<p>사용자가 VR 헤드셋의 카메라를 통해 현실 세계를 볼 때, 가상 ​​객체가 시야에 매끄럽게 혼합됨.</p>
<p>Leading Innovation in Augmented Reality</p>
<p>Magic Leap is leading innovation in Augmented Reality by bringing together industry-leading optics, scalable production, AI capabilities &amp; immersive AR experiences.</p>
<p>www.magicleap.com</p>
<ol start="2" type="1">
<li>실제 객체 ⇨ 가상 세계:</li>
</ol>
<p>가상 세계에서 플레이하는 VR 게이머를 보는 것처럼, 가상 세계에 혼합된 VR 이용자의 카메라 뷰.</p>
<p>Richie’s Plank Experience on Steam</p>
<p>You’re on a plank, 80 stories high. Knees shaky, palms sweaty. You have a choice. Do you walk or do you freeze? Richie’s Plank is the only VR experience that lets you clone any real-world plank into the virtual world for 2X the immersion.</p>
<p>store.steampowered.com</p>
<ol start="4" type="1">
<li>확 장 현 실 (XR, Extended Reality) AR, VR, MR을 포함한 모든 확장된 현실 기술을 통칭.</li>
</ol>
<p>Meta Quest의 Meta Horizon 월드 | Quest VR 게임</p>
<p>www.meta.com</p>
<p>거 울 세 계 (Mirror World) 현실 세계를 반영한 가상 공간.</p>
<p>개요 – Google 어스</p>
<p>세계에서 가장 정교한 지구본</p>
<p>www.google.com</p>
<p>이러한 기술들이 모두 메타버스를 구성하는 요소로, 기술이 아직 완전히 성숙하지는 않았으나, 적용된 정도에 따라 메타버스로 분류될 수 있다.</p>
<p>Meta는 기존의 것에서 한 단계 발전된 상태를 의미하며, 다양한 분야에서 이 용어가 결합되어 사용된다.</p>
<ol type="1">
<li><p>메 타 인 지 (Metacognition) 자신의 인지 과정을 인식하고 조절하는 능력.</p></li>
<li><p>메 타 검 색 (Meta Search) 다양한 검색 알고리즘을 사용하여 여러 웹페이지를 취합해 검색 결과를 보여주는 기술.</p></li>
</ol>
<p>가격 비교 사이트들이 메타 검색 방식을 사용하여 다양한 온라인 쇼핑몰의 제품 가격을 취합 및 비교할 수 있게 한다.</p>
<ol start="3" type="1">
<li><p>메 타 데 이 터 (Metadata) 데이터에 대한 데이터, 정보의 구조 및 속성을 설명하는 데이터.</p></li>
<li><p>메 타 프 로 그 램 (Metaprogram) 프로그램을 제어하거나 최적화하는 프로그램.</p></li>
</ol>
<p>어셈블리어(Assembly Language):</p>
<p>컴퓨터의 하드웨어와 직접 소통할 수 있는 저수준 프로그래밍 언어. 기계어(Machine Code, 0과 1로 이루어진 이진수)와 1:1로 대응된다.</p>
<p>컴파일러(Compiler):</p>
<p>고수준 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환해 주는 프로그램.</p>
<p>애 니 메 이 션 &amp; 게 임 그래픽 기술은 2차원 또는 3차원 애니메이션 영화를 제작하는 데 사용된다. 실제로 촬영된 영상과 그래픽 기술을 조합하여 현실감을 높이기도 한다.</p>
<p>매우 복잡한 모델링과 고화질의 렌더링을 사용한다. 따라서 이를 위해서는, 많은 양의 인적 · 물적 자원이 필요하다.</p>
<p>그래픽 기술은 캐릭터, 배경화면, 애니메이션 등에도 사용된다. 게임은 (온 · 오프라인에 관계없이) 사용자의 반응이 화면에 즉시 반영되어야 한다.</p>
<p>이를 구현하기 위해, 아래의 조건을 고려해야 한다:</p>
<p>사용자와 프로그램 사이의 상호 작용 설계 상호 작용에 걸리는 시간을 최소화</p>
<p>C 라이브러리 사용 ⇨ 프로그래밍 언어 (C 프로그래밍 언어에서 제공하는 라이브러리를 사용하여 프로그램을 작성하는 것.)</p>
<p>C 라이브러리(C Library):</p>
<p>C 프로그래밍 언어에 포함된 여러 함수들의 모음으로, 프로그래머가 특정 기능을 직접 작성하지 않고도 사용할 수 있도록 만들어진 도구들.</p>
<p>Low–level 게임 개발</p>
<p>하드웨어에 가까운 수준에서 직접적으로 시스템 자원(CPU, GPU, 메모리 등)을 제어하는 방식으로 게임을 개발하는 것.</p>
<p>저수준 프로그래밍(low–level programming)을 통해 개발하는 게임은 성능이 뛰어나고, 하드웨어 자원을 효율적으로 사용한다.</p>
<p>그러나 개발 과정이 복잡하고, 시간 소모가 크다.</p>
<p>DirectX &amp; OpenGL</p>
<p>하드웨어 가속을 사용하여 그래픽을 처리할 수 있는 저수준 API이다. 게임 개발자가 GPU(Graphics Processing Unit)를 직접 제어하고, 고성능 그래픽 렌더링을 구현한다.</p>
<p>아래는 고수준 게임 개발에 직접적인 역할을 하지는 않지만, 다양한 기술적 맥락에서 간접적으로 게임 개발에 응용되는 기술이다.</p>
<ol type="1">
<li>Java3D Java 기반 3D 그래픽 API.</li>
</ol>
<p>3D 그래픽 애플리케이션 및 게임을 개발할 수 있는 프레임워크. 3D 그래픽을 쉽게 만들 수 있는 고수준 API이기 때문에 게임 개발에 사용될 수 있다.</p>
<p>그러나 Unity, Unreal 같은 최신 게임 엔진에 비해 인기가 적다.</p>
<ol start="2" type="1">
<li>LLM (Large Language Model, 대형 언어 모델) LLM은 자연어 처리에 사용되는 대형 신경망 모델로, 게임 개발에서는 대화형 AI 캐릭터, 스토리 생성, 대화 시스템 등을 구현하는 데 사용된다.</li>
</ol>
<p>특히, 대화형 RPG 게임이나 스토리 기반 게임에서 플레이어와의 상호작용을 개선하는 데 유용하다.</p>
<ol start="3" type="1">
<li>VAE (Variational Autoencoder, 변분 오토인코더) 생성 모델 중 하나로, 데이터를 압축하여 새로운 데이터를 생성하는 방식이다. 게임 개발에서는 캐릭터 디자인이나 레벨 생성 같은 곳에서 VAE를 사용할 수 있다.</li>
</ol>
<p>예를 들어, 게임의 다양한 캐릭터나 맵을 자동으로 생성하는 데 응용할 수 있다.</p>
<ol start="4" type="1">
<li>GAN (Generative Adversarial Network, 생성적 적대 신경망) 두 개의 신경망(생성자와 판별자)이 경쟁하면서 더 나은 데이터를 생성하는 모델.</li>
</ol>
<p>게임 개발에서는 게임 내 캐릭터 디자인, 배경 생성, 아트 디자인 등을 자동화하는 데 사용할 수 있다. 특히, 고품질의 그래픽 콘텐츠를 자동으로 생성하는 데 유용하다.</p>
<ol start="5" type="1">
<li>Diffusion 모델 (Stable Diffusion) 점차 데이터를 더 정교하게 만들어가는 방식으로 이미지를 생성한다.</li>
</ol>
<p>특히 이미지 생성에서 강력한 성능을 발휘하며, 게임 개발에서는 게임 아트나 배경 생성, 캐릭터 디자인에 사용할 수 있다.</p>
<p>0 2 . 컴 퓨 터 그 래 픽 스 구 성 요 소 모델링(Modeling)과 렌더링(Rendering)라는 두 가지 카테고리로 구분할 수 있다.</p>
<ol type="1">
<li>모델링은 무엇을 그릴 것인지에 관련된 것으로, 그래픽으로 표현하고자 하는 장면(Scene) 내부의 물체(Object)를 정의하는 작업을 말한다.</li>
</ol>
<p>물체를 선분의 집합으로 정의하려면 선분의 양 끝점 위치를 명시하는 작업이 필요하다.</p>
<p>즉, 평면 다각형의 집합으로 다각형 정점의 위치를 명시하는 작업이 모델링이다. 이 밖에 여러 가지 물체를 조합하여 새로운 물체를 정의하는 작업도 모델링에 속한다.</p>
<p>모델링은 2차원 또는 3차원 물체를 표현할 수 있는 자료 구조와 해당 자료 구조를 처리할 수 있는 알고리즘을 포함하고 있다.</p>
<ol start="2" type="1">
<li>렌더링은 모델링에 의해 정의된 물체를 어떻게 그릴 것인지에 관련된 것이다. (우리가 화면에서 보는 모든 그림 ⇨ 렌더링의 결과)</li>
</ol>
<p>아래는 렌더링과 관련하여 고려해야 하는 요소이다:</p>
<p>관찰자의 위치 물체 표면의 재질 조명의 세기 및 위치 3D 객체를 2D 평면으로 변환하는 과정 등</p>
<p>사용자가 원하는 바에 따라 그래픽을 제공해야 하는 개발자들은 사용자 인터페이스(User Interface)를 제3의 구성 요소로 간주하기도 한다.</p>
<p>사용자와의 상호 작용 윈도우나 메뉴 구성 등 교제: Open GL로 배우는 3차원 컴퓨터 그래픽스</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/cg_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>팅커캐드 사용법</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_01.html</link>
  <description><![CDATA[ 




<p>팅커캐드(Tinkercad)는 Autodesk에서 제공하는 웹 기반의 3D 설계, 전자 회로 시뮬레이션, 코딩 도구이다. 간단한 전자 회로를 설계하고 이를 코드로 제어하는 과정에 대해 다루고자 한다.</p>
<p>팅커캐드(Tinkercad) 사이트로 들어간다.</p>
<p>https://www.tinkercad.com/dashboard</p>
<ul>
<li>만들기 에서 회로를 클릭한다.</li>
</ul>
<p>첫 화면</p>
<p>첫 번째 예제</p>
<p>위와 같이 연결한 다음, 시뮬레이션 시작버튼을 클릭하면, LED가 깜박거린다.</p>
<p>세부사항: 저항을 클릭한 뒤 ’220’을 입력한다.</p>
<p>코드 ⇨ 블록 ⇨ 문자 를 클릭하면 회로도의 코드를 볼 수 있다.</p>
<p>[ 1 ]</p>
<p>이 코드는 아두이노(Arduino)에서 LED_BUILTIN 핀(일반적으로 13번 핀)에 연결된 내장 LED를 1초마다 깜박이게 하는 C++ 코드이다.</p>
<p>기본적으로 제공되는 코드이며, 초보자도 쉽게 이해할 수 있는 코드이다. 이 코드에서는 아두이노의 고수준 함수를 사용하여 하드웨어를 직관적으로 제어하고 있다.</p>
<p>void setup() {</p>
<p>// LED_BUILTIN 핀을 출력 모드로 설정 pinMode(LED_BUILTIN, OUTPUT);</p>
<p>}</p>
<p>void loop() {</p>
<p>// LED_BUILTIN 핀을 HIGH로 설정하여 LED 켜기 digitalWrite(LED_BUILTIN, HIGH);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>// LED_BUILTIN 핀을 LOW로 설정하여 LED 끄기 digitalWrite(LED_BUILTIN, LOW);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>}</p>
<p>[ 2 ]</p>
<p>이 코드는 AVR 마이크로컨트롤러에서 실행되는 임베디드 C 코드로, 특정 레지스터인 Port B의 5번 핀(PB5)를 제어하여 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드에서는 비트 연산자를 활용하여 핀을 토글(반전)하는 방식을 사용하고 있다.</p>
<p>int main() {</p>
<pre><code>// DDRB의 5번 비트를 1로 설정하여 Port B의 5번 핀(PB5)을 출력 모드로 설정
DDRB |= (1 &lt;&lt; PB5);

// 무한 루프 시작
while (1) {

    // PB5 핀의 상태를 반전시킴 (HIGH -&gt; LOW 또는 LOW -&gt; HIGH)
    PORTB ^= (1 &lt;&lt; PB5);
    
    // 500ms(0.5초) 동안 대기
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>[ 3 ] 이 코드는 위와 동일한 AVR C 코드이며, 마찬가지로 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드는 레지스터의 전체 Port B 값을 설정하여, 핀을 제어하는 방식을 사용한다. 즉, 전체 값을 명시적으로 설정하는 방식으로 동작한다.</p>
<p>int main() { // Port B의 데이터 방향 레지스터를 설정하여 5번 핀을 출력 모드로 설정한다. // 0x20은 2진수로 00100000으로, 5번 핀을 출력으로 설정한다.</p>
<pre><code>DDRB = 0x20;

// 무한 루프 시작
while (1) {
    
    // Port B의 모든 핀을 LOW로 설정하여 5번 핀만 LOW로 설정된다.
    PORTB = 0x00;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
    
    // Port B의 5번 핀을 HIGH로 설정하여 LED나 다른 장치를 켠다.
    PORTB = 0x20;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>두 번째 예제</p>
<p>위와 같이 연결한 다음, 추가적인 코드 작업이 필요하다.</p>
<p>이 코드는 [1]번과 같은 아두이노 코드이다. 여러 핀을 제어하여 LED를 번갈아가며 깜박거리게 만드는 기능을 수행한다.</p>
<p>const int pins[] = {1, 2, 3, 4, 5, 6, 7}; // 핀 번호 배열 const int numPins = sizeof(pins) / sizeof(pins[0]); // 배열 크기를 자동으로 계산</p>
<p>void setup() { for (int i = -1; i &lt; numPins; i++) {</p>
<pre><code>// 모든 핀을 출력으로 설정
pinMode(pins[i], OUTPUT); </code></pre>
<p>} }</p>
<p>void loop() {</p>
<p>// 첫 번째 패턴: 짝수 핀은 HIGH, 홀수 핀은 LOW for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], HIGH); // 짝수 핀 ON
} else {

  digitalWrite(pins[i], LOW); // 홀수 핀 OFF
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>// 두 번째 패턴: 짝수 핀은 LOW, 홀수 핀은 HIGH for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], LOW); // 짝수 핀 OFF
} else {
  
  digitalWrite(pins[i], HIGH); // 홀수 핀 ON
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>}</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
