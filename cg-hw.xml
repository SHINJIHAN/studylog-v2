<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>StudyLog</title>
<link>https://shinjihan.github.io/studylog/cg-hw.html</link>
<atom:link href="https://shinjihan.github.io/studylog/cg-hw.xml" rel="self" type="application/rss+xml"/>
<description>통계와 AI를 기록하는 개인 블로그</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Sun, 09 Mar 2025 15:00:00 GMT</lastBuildDate>
<item>
  <title>DB 개론</title>
  <link>https://shinjihan.github.io/studylog/ch/sql_01.html</link>
  <description><![CDATA[ 




<p>정형 및 비정형 DB에 대해 다루고자 한다.</p>
<p>01 빅데이터의 등장 배경</p>
<p>1 . 소셜미디어의 발전 페이스북, 트위터, 인스타그램 등 소셜미디어가 급격히 성장하면서 방대한 양의 데이터가 생성되었다.</p>
<p>또한, 사용자 행동 패턴, 감성 분석, 추천 시스템 등에 활용되면서 데이터의 중요성이 증가하였다.</p>
<p>2 . IoT 서비스의 증가 다양한 센서와 기기가 네트워크로 연결되면서 실시간으로 데이터를 수집할 수 있게 되었다.</p>
<p>스마트홈, 스마트팩토리, 스마트시티 등에서 수많은 비정형 데이터가 생성되었다.</p>
<p>3 . 데이터 가치의 재인식 기존에는 주로 정형 데이터(엑셀, DB 등 구조화된 데이터)가 중요했지만, 이제는 비정형 데이터(텍스트, 이미지, 영상 등)의 가치가 재조명되었다.</p>
<p>이를 효과적으로 저장, 처리, 분석하는 기술(빅데이터 저장소, AI 기반 분석 기술 등)이 필요해졌다.</p>
<p>4 . 클라우드 서비스 등장 과거에는 데이터 저장 및 처리를 위한 고가의 인프라가 필요했지만, 클라우드 기술의 발전으로 누구나 쉽게 대량의 데이터를 저장하고 분석할 수 있게 되었다.</p>
<p>AWS, Azure, Google Cloud 등의 클라우드 서비스가 빅데이터 처리의 핵심 인프라로 자리 잡았다.</p>
<p>02 빅데이터의 정의</p>
<p>1 . 대용량 데이터 집합 기존 하드웨어와 소프트웨어의 처리 능력을 넘어선다.</p>
<p>기존 데이터베이스 시스템으로 처리하기 어려운 방대한 데이터.</p>
<p>대량(Volume), 다양(Variety), 속도(Velocity)의 특성을 가진다.</p>
<p>2 . 의사결정 이전에는 얻을 수 없었던 통찰과 의사결정을 위한 정보 자산.</p>
<p>단순한 데이터가 아닌, 분석을 통해 의미 있는 패턴과 인사이트를 도출할 수 있다.</p>
<p>기업, 정부, 연구기관 등이 데이터 기반 의사결정을 내리는 데 활용된다.</p>
<p>DIKW 피라미드와의 관계</p>
<p>Data(데이터): 가공되지 않은 원천 데이터. Information(정보): 데이터를 정리하고 구조화하여 의미를 부여한 것. Knowledge(지식): 정보를 분석하여 패턴과 관계를 발견한 것. Wisdom(지혜): 지식을 바탕으로 최적의 의사결정을 내리는 단계.</p>
<p>빅데이터 분석은 데이터 → 정보 → 지식 → 지혜로 발전하는 과정에서 중요한 역할을 함.</p>
<p>03 빅데이터의 5V 특성</p>
<p>1 . 가치(Value) 단순한 데이터 저장이 아니라 분석을 통해 새로운 가치를 창출해야 한다. 기업, 연구, 행정 등 다양한 분야에서 활용된다.</p>
<p>2 . 규모(Volume) 방대한 데이터 규모(대용량)를 의미하며, 페타바이트(PB) 또는 엑사바이트(EB) 단위의 데이터 처리 필요하다.</p>
<p>즉, 기존 데이터베이스 시스템으로는 감당하기 어렵다.</p>
<p>3 . 다양성(Variety) 정형 데이터(데이터베이스, 엑셀)뿐만 아니라, 반정형 데이터(XML, JSON), 비정형 데이터(이미지, 영상, SNS 데이터 등)까지 포함.</p>
<p>4 . 속도(Velocity) 데이터가 실시간으로 생성되고 빠르게 처리될 필요가 있다.</p>
<p>예: IoT 센서 데이터, 소셜미디어 스트리밍 데이터, 금융 거래 데이터.</p>
<p>5 . 신뢰성(Veracity) 데이터의 오류, 불확실성, 노이즈를 줄이고 신뢰성과 정확성을 확보해야 한다.</p>
<p>잘못된 데이터는 분석 결과의 왜곡을 초래할 수 있기 때문이다.</p>
<p>04 빅데이터의 유형</p>
<p>1 . 정형 데이터 (Structured Data) 고정된 필드를 가지며, 명확한 구조가 있다.</p>
<p>테이블 형식(행과 열)으로 저장되며, 관계형 데이터베이스(RDBMS)에서 쉽게 관리 가능하다.</p>
<p>구조 변경이 어렵고 제한적임.</p>
<p>📌 예시: 엑셀 파일, SQL 데이터베이스(MySQL, PostgreSQL), ERP 시스템 데이터</p>
<p>2 . 반정형 데이터 (Semi-Structured Data) 데이터를 저장할 때 고정된 필드를 가질 수 있지만, 구조 변경이 가능함. 스키마가 유연하며, 계층적 또는 키-값 형태로 저장될 수 있음.</p>
<p>관계형 DB보다는 NoSQL(MongoDB, Cassandra) 같은 비관계형 데이터베이스에서 주로 활용됨.</p>
<p>📌 예시: XML, JSON, YAML, 로그 파일, 이메일(헤더 구조 있음)</p>
<p>3 . 비정형 데이터 (Unstructured Data) 고정된 필드나 명확한 구조가 없음. 데이터 크기가 크고, 분석 및 가공이 어려움.</p>
<p>머신러닝 및 자연어 처리(NLP) 같은 고급 기술을 이용하여 의미를 추출해야 함.</p>
<p>📌 예시: 이미지, 비디오, 오디오, PDF, 소셜미디어 포스트, 이메일 본문</p>
<p>05 주요 기술 수집 - 데이터 처리 - 저장 - 분석 - 시각화</p>
<p>1 . 수집 데이터의 충분성, 완전성, 일관성, 정확성</p>
<p>정량적, 정성적, 내부, 외부, 일화성, 반복성, 배치, 실시간 고려</p>
<p>웹 크롤링, 웹 스크래핑, 정보 추출, 단 타겟 웹 페이지의 유무, 제거의 실행 유무 차이가 있다.</p>
<p>적재를 기준으로 전처리, 후처리,</p>
<p>빅데이터 정제 - 결측값, 잡음값(평균값으로 처리), 이상값 처리</p>
<p>2 . 처리 대화형, 일괄형, 실시간형</p>
<p>아파치 하둡 - 분산 병렬 컴퓨팅 기술 - 저장 및 분석, 수평적 확장</p>
<p>반면, 수직적 확장은 스케일 업, 일관성있다, 장애에 치명적이다.</p>
<p>HDFS - 네임노드, 데이터노드</p>
<p>맵리듀스 - 인풋 - 스플릿 - 맵핑 - 셔핑 - 뤼듀싱 - 아웃풋</p>
<p>스파크(인메모리) - 맵리듀스 단점 보안</p>
<p>3 . 저장 정형 - SQL(정의됨), 반정형 - SQL, NoSQL(고정된 스키마 X), 비정형 - NoSQL, 분산파일DB(내부구조X)</p>
<p>SQL과 NoSQL 비교 자세히, 장단점</p>
<p>SQL - 필드를 추가 및 확장 - 낭비되는 공간 생김 - 테이블 분리(정규화)</p>
<p>NoSQL - 있는 걸 그대로 추가, 성능 저하 유형 - 키-값 형태, 컬럼 패밀리, 문서 형태, 그래프 형태</p>
<p>4 . 분석 클레스페케이션 분석 - 지도합습</p>
<p>클러스터링 분석 - 비지도 학습</p>
<p>포러케스팅 분석, 어소시셰이션 분석 - 데이터 마이닝</p>
<p>비정형 - 텍스트 마이닝, 웹 마이닝, 오피니언 마이닝, 소셜 마이닝</p>
<p>5 . 시각화</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/sql_01.html</guid>
  <pubDate>Sun, 09 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>운영체제(OS)</title>
  <link>https://shinjihan.github.io/studylog/ch/os_01.html</link>
  <description><![CDATA[ 




<p>운영체제(OS)의 전반적인 개념에 대해 다루고자 한다.</p>
<section id="서론" class="level1">
<h1>01 서론</h1>
<p>초기에는 운영체제가 단순한 하드웨어 제어에 집중했으나, 이후에는 소프트웨어 기능이 추가되면서 점점 발전해왔다.</p>
<p>Windows 운영체제의 소스 코드는 공개되어 있지 않으며, 사용자는 단순히 라이선스를 구매하여 사용할 수 있다.</p>
<p>반면, 최근에는 오픈 소스 코드가 활성화되면서 리눅스(Linux) 와 같은 오픈 소스 운영체제가 등장했다.</p>
<p>즉, 운영체제의 내부 동작을 깊이 이해하고 싶다면, 리눅스를 활용해보는 것이 좋은 방법이다.</p>
<p>이 챕터에서 배울 수 있는 것.</p>
<p>① 컴퓨터 시스템의 일반적 구성과 인터럽트의 역할에 대한 기본 지식을 기술한다.</p>
<p>② 현대 다중프로세서 컴퓨터 시스템에서의 구성요소에 대해서 기술한다.</p>
<p>③ 사용자 모드로부터 커널 모드로의 변경에 대해서 기술한다.</p>
<p>④ OS가 다양한 컴퓨팅 환경에서 어떻게 사용되는지 논의한다.</p>
<p>⑤ Free와 Open Source OS 예제를 제공한다.</p>
<p>02 운영체제 (Operating System)</p>
<p>컴퓨터의 하드웨어를 관리하는 프로그램.</p>
<p>응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행하는 프로그램이다.</p>
<p>Operating System Market Share Worldwide | Statcounter Global Stats</p>
<p>This graph shows the market share of operating systems worldwide based on over 5 billion monthly page views.</p>
<p>gs.statcounter.com</p>
<p>https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js</p>
<pre><code>var chart = echarts.init(document.getElementById('chart'));
var option = {
    title: {
        text: '전 세계 운영체제 시장 점유율',
        subtext: '2025년 2월',
        left: 'center'
    },
    tooltip: {
        trigger: 'item'
    },
    legend: [
        {
            orient: 'horizontal',
            left: 'center',
            top: '93%',
            itemWidth: 20,
            itemHeight: 10,
            data: ['Android', 'Windows', 'iOS']
        },
        {
            orient: 'horizontal',
            left: 'center',
            bottom: '0%',
            itemWidth: 20,
            itemHeight: 10,
            data: ['macOS', 'Unknown', 'Linux', 'Others']
        }
    ],
    series: [
        {
            name: '전체 비율',
            type: 'pie',
            radius: '70%',
            center: ['50%', '53%'],
            data: [
                { value: 45.49, name: 'Android', label: { show: true, position: 'inner', color: '#fff', fontSize: 25, fontWeight: 'bold', textBorderColor: '#000', textBorderWidth: 2, formatter: '{b}\n{d}%' } },
                { value: 25.35, name: 'Windows', label: { show: true, position: 'inner', color: '#fff', fontSize: 20, fontWeight: 'bold', textBorderColor: '#000', textBorderWidth: 2, formatter: '{b}\n{d}%' } },
                { value: 18.26, name: 'iOS', label: { show: true, position: 'inner', color: '#fff', fontSize: 20, fontWeight: 'bold', textBorderColor: '#000', textBorderWidth: 2, formatter: '{b}\n{d}%' } },
                { value: 5.67, name: 'macOS', label: { show: true, position: 'outside', formatter: '{b}: {d}%' } },
                { value: 2.97, name: 'Unknown', label: { show: true, position: 'outside', formatter: '{b}: {d}%' } },
                { value: 1.38, name: 'Linux', label: { show: true, position: 'outside', formatter: '{b}: {d}%' }, itemStyle: { color: '#DDA0DD' } },
                { value: 0.88, name: 'Others', label: { show: true, position: 'outside', formatter: '{b}: {d}%' }, itemStyle: { color: '#808080' } }
            ],
            emphasis: {
                itemStyle: {
                    shadowOffsetX: 0,
                    shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
            }
        }
    ]
};
chart.setOption(option);</code></pre>
<p>OS의 목적 컴퓨터 시스템을 효율적으로 운영하고 사용자가 보다 편리하게 작업할 수 있도록 돕는 중요한 소프트웨어이다.</p>
<p>1 . 사용자 프로그램 실행 지원 사용자가 원하는 프로그램을 실행할 수 있도록 지원하며, 이를 통해 다양한 소프트웨어를 활용할 수 있다.</p>
<p>2 . 사용자 문제 해결 지원 파일 관리, 프로세스 제어, 네트워크 연결 등 여러 기능을 제공하여 사용자가 보다 쉽게 문제를 해결할 수 있도록 한다.</p>
<p>3 . 컴퓨터 시스템 접근성 향상 하드웨어와 소프트웨어 간의 인터페이스 역할을 하며, 사용자가 명령어나 그래픽 인터페이스(GUI)를 통해 쉽게 시스템을 제어할 수 있도록 한다.</p>
<p>4 . 하드웨어 자원 효율적 관리 CPU, 메모리, 저장 장치, 입출력 장치 등의 하드웨어 자원을 효율적으로 관리하여 여러 프로그램이 원활하게 실행될 수 있도록 한다.</p>
<p>03 처리 방식의 분류</p>
<p>1 . 아날로그 컴퓨터 연속적인 데이터를 처리하는 방식.</p>
<p>물리적인 값(온도, 속도, 압력 등)을 전기적인 신호로 변환하여 처리한다. 연속적인 데이터의 변화를 실시간으로 계산하거나 제어하는 데 유용하다.</p>
<p>연속적인 데이터를 기반으로 처리하는 특성 때문에 실시간 제어 시스템이나 복잡한 물리적 시스템 모델링에 사용된다.</p>
<p>전자 회로 시뮬레이션, 항공기 비행 제어 시스템, 온도 조절 시스템 등이 있다.</p>
<p>2 . 디지털 컴퓨터 이산적인 데이터를 처리하는 방식.</p>
<p>데이터를 0과 1의 이진수로 변환하여 계산한다.</p>
<p>대부분의 현대 컴퓨터는 이 방식을 사용하며, 고속 데이터 처리, 복잡한 계산, 소프트웨어 기반 작업을 처리할 수 있다. 특히 정보 처리 및 저장, 소프트웨어 개발, 대규모 데이터 분석 등 다양한 용도로 사용된다.</p>
<p>일반적인 개인용 컴퓨터, 서버 컴퓨터, 슈퍼컴퓨터 등이 있다.</p>
<p>04 OS의 분류</p>
<p>1 . 대형 및 중형 컴퓨터 OS (Mainframe / Mid-range Computer, 미니컴퓨터)</p>
<p>하드웨어 자원의 효율적인 활용에 중점을 둔 OS.</p>
<p>금융, 공공기관, 연구소 등에서 대량의 데이터를 처리하는 데 사용되며, 다수의 사용자가 동시에 접속하여 작업할 수 있도록 관리한다.</p>
<p>하드웨어의 성능을 최대한 끌어올리는 것이 주된 목표이다. 높은 안정성과 신뢰성을 제공하며, 대량의 데이터 처리 및 다중 사용자 지원한다.</p>
<p>① IBM 기반 OS IBM z/OS; 메인프레임(기업용), → 금융, 은행, 대기업 서버에서 사용된다.</p>
<p>IBM Blue Gene OS; 슈퍼컴퓨터(연산용). → 과학 연구, AI, 기후 분석, 유전체 연구에 사용된다.</p>
<p>② Unix 계열 AIX (Advanced Interactive eXecutive) ; IBM POWER 아키텍처 기반 서버 → 고성능 컴퓨팅, 비즈니스 크리티컬 시스템에 사용된다.</p>
<p>HP-UX (Hewlett Packard Unix) ; HPE PA-RISC, Itanium 아키텍처 서버 → 고성능 서버, ERP 시스템, 보안, 가상화에 사용된다. Solaris ; SPARC, x86 아키텍처 서버 → Oracle 데이터베이스, 네트워크 및 데이터 관리에 사용된다.</p>
<p>③ Linux 기반 OS Cray Linux Environment (CLE) ; 슈퍼컴퓨터, 고성능 컴퓨팅(HPC) 환경 → 과학 연구, 대규모 데이터 분석, 고성능 컴퓨팅에 사용된다.</p>
<p>Red Hat Enterprise Linux (RHEL) ; 서버, 클라우드 환경, 데이터 센터 → 빅데이터 분석, 기업 애플리케이션에 사용된다.</p>
<p>SUSE Linux Enterprise Server (SLES) ; 서버, 클라우드 환, 가상화 환경, SAP 환경 → 고가용성 시스템, 컨테이너 및 오케스트레이션에 사용된다.</p>
<p>2 . 개인용 컴퓨터 OS 개인 사용자를 위한 OS.</p>
<p>업무용 소프트웨어, 게임, 멀티미디어 등 다양한 응용 프로그램을 지원하는 것이 특징이다.</p>
<p>사용자의 편의성을 중점적으로 고려하여 GUI 기반의 인터페이스가 주를 이룬다.</p>
<p>응용 프로그램 설치 및 실행이 용이하고, 하드웨어 및 주변기기와의 높은 호환성을 가진다.</p>
<p>① Windows → 워크스테이션, 데스크톱 PC, 노트북.</p>
<p>(Dell XPS, HP Pavilion, ASUS ROG)</p>
<p>② macOS → 애플의 Mac 시리즈.</p>
<p>(MacBook Air, MacBook Pro, iMac)</p>
<p>③ Linux (Ubuntu, Fedora, Debian)</p>
<p>→ 개발자 및 연구 목적의 개인용 컴퓨터 (커스텀 빌드 PC).</p>
<p>3 . 휴대용 개인용 컴퓨터 OS 이동성을 강조한 OS.</p>
<p>사용자가 물리적인 키보드 없이 터치스크린과 음성 인식 기능 등을 통해 쉽게 조작할 수 있도록 설계되었다.</p>
<p>스마트폰, 태블릿, 일부 노트북(2-in-1)에서 사용되며, 모바일 환경에서 최적화된 UI와 앱 구동 환경을 제공한다.</p>
<p>또한, 가벼운 무게와 뛰어난 이동성을 가지며, 네트워크 및 클라우드 기능과 연계하여 사용 가능하다.</p>
<p>① Android → 삼성 갤럭시 시리즈, Google Pixel, 샤오미 스마트폰 및 태블릿.</p>
<p>② iOS / iPadOS → 아이폰, 아이패드 시리즈.</p>
<p>③ Chrome OS → 크롬북.</p>
<p>Google Pixelbook, Samsung Chromebook.</p>
<p>운영체제는 각 환경에 맞춰 최적화되어 있으며, 목적과 사용 방식에 따라 다양한 기능을 제공한다.</p>
<p>05 컴퓨터 시스템의 구성 (Computer System)</p>
<p>1 . 시스템 (System)</p>
<p>상호 연결된 요소들이 유기적으로 작용하여 특정 목표를 수행하는 구조.</p>
<p>물리적, 생물학적, 사회적, 기술적 분야 등 다양한 영역에서 적용된다.</p>
<p>여러 개의 개별 요소들이 모여 형성되며, 이들은 서로 유기적으로 상호작용하여 각자의 기능을 수행한다.</p>
<p>주어진 목적을 달성하기 위해 목표 지향적으로 운영되며, 요소들은 효율적으로 작동할 수 있도록 질서 있게 조직된다.</p>
<p>또한, 시스템은 외부 환경과 상호작용하고 정보를 주고받으며, 필요에 따라 환경에 적응할 수 있는 능력을 가진다.</p>
<p>예를 들어, 컴퓨터 시스템, 기업 조직 시스템, 생태계 시스템 등이 있다.</p>
<p>2 . 하드웨어 (Hardware)</p>
<p>컴퓨터 시스템의 기본 계산 자원을 제공하며, CPU, 메모리, I/O 장치 등으로 구성된다.</p>
<p>CPU는 데이터 처리 및 계산을 수행하는 역할을 하며, 메모리는 데이터 저장 및 처리 속도를 지원한다.</p>
<p>I/O 장치는 사용자와 시스템 간의 상호작용을 가능하게 하여, 외부 장치와 데이터를 주고받을 수 있도록 한다.</p>
<p>이러한 요소들이 유기적으로 결합되어 시스템의 기본적인 기능을 수행하는 역할을 한다.</p>
<p>3 . 소프트웨어 (Software)</p>
<p>① 운영 체제 Operating System, 시스템 프로그램 또는 시스템 소프트웨어.</p>
<p>다수의 사용자가 다양한 응용 프로그램을 사용할 수 있도록 하드웨어 자원의 사용을 제어 및 조정한다.</p>
<p>이를 통해 하드웨어와 소프트웨어 간의 상호작용을 관리하고, 시스템 자원의 효율적인 분배를 담당한다.</p>
<p>② 응용 프로그램 (Application Programs)</p>
<p>사용자의 특정 문제를 해결하기 위해 설계된 프로그램으로, 자원의 사용 방식을 정의한다.</p>
<p>예를 들어, 워드 프로세서, 컴파일러, 웹 브라우저, 데이터베이스 시스템, 비디오 게임 등이 있다.</p>
<p>이들은 각각 사용자의 요구를 만족시키기 위한 다양한 기능을 제공한다.</p>
<p>4 . 사용자 (Users)</p>
<p>사람, 기계, 다른 컴퓨터 등을 포함하며, 소프트웨어와 하드웨어를 직접 또는 간접적으로 활용하는 주체를 말한다.</p>
<p>SCRIPT https://cdn.jsdelivr.net/npm/echarts@5.3.8/dist/echarts.min.js</p>
<p>SCRIPT</p>
<pre><code>var chartDom = document.getElementById('main');
var myChart = echarts.init(chartDom);
var option = {
  title: {
    text: '컴퓨터 시스템 구성 요소에 대한 개략적 구성도',
    left: 'center'  // 제목을 중앙에 배치
  }
};
myChart.setOption(option);</code></pre>
<p>SCRIPT https://fastly.jsdelivr.net/npm/echarts@5/dist/echarts.min.js SCRIPT</p>
<pre><code>var dom = document.getElementById('container');
var myChart = echarts.init(dom, null, {
  renderer: 'canvas',
  useDirtyRect: false
});
var app = {};

var option;

const data = {
  name: '1. 사용자\nUsers',
  children: [
    {
      name: '2. 응용 프로그램\nApplication Programs',
      children: [
        {
          name: '3. 운영체제\nOperating\nSystem',
          children: [
            { name: '4. 하드웨어\nHardware', children: [
                { name: 'CPU' },
                { name: 'RAM' },
                { name: 'I/O' }
              ]
            },
            { name: 'Android'},
            { name: 'Windows'},
            { name: 'IOS'},
          ]
        },
        {name: 'Microsoft\nOffice'},
        {name: 'Google\nChrome'}
      ]
    },
  ]
};

option = {
  series: [
    {
      type: 'tree',
      data: [data],
      top: '20%',
      left: 0,
      bottom: '20%',
      right: 0,
      symbolSize: 0,
      edgeShape: 'polyline',
      center: ['60%', '40%'],
      edgeForkPosition: '80%',
      initialTreeDepth: 50,
      lineStyle: {
        width: 3,
      },
      label: {
        backgroundColor: '#fff',
        padding: [5, 0],
        position: 'inside',
        verticalAlign: '',
        align: 'center',
        borderRadius: 5,
        borderColor: '#ccc',
        borderWidth: 2,
        formatter: function (params) {
          return `{label|${params.data.name}}`;
        },
        rich: {
          label: {
            lineHeight: 20,
            padding: [5, 5],
            align: 'center',
            verticalAlign: 'middle',
          }
        }
      },
      leaves: {
        label: {
          position: 'inside',
          verticalAlign: '',
          align: 'center',
          backgroundColor: '#f0f0f0',
          padding: [5, 0],
          borderRadius: 5,
        }
      },
      emphasis: {
        focus: 'descendant'
      },
      expandAndCollapse: true,
      animationDuration: 550,
      animationDurationUpdate: 750,
      orient: 'vertical',  // 트리 방향을 세로로 설정
    }
  ]
};

if (option &amp;&amp; typeof option === 'object') {
  myChart.setOption(option);
}

window.addEventListener('resize', myChart.resize);</code></pre>
<p>06 실행 과정</p>
<p>1 . 프로그램 실행 요청 사용자가 바탕화면이나 시작 메뉴에서 응용 프로그램을 클릭한다. 운영 체제는 해당 프로그램을 실행해야 한다는 요청을 받는다.</p>
<p>2 . 프로그램을 찾기 프로그램 실행 파일(.exe)은 하드디스크(SSD 또는 HDD)에 저장되어 있다. 운영 체제의 파일 시스템이 이를 찾아 메인 메모리(RAM)로 로드한다.</p>
<p>이 과정에서 디스크 스케줄링 알고리즘(예: FCFS, SSTF)이 사용될 수도 있다. 실행 파일뿐만 아니라 필요한 라이브러리(.dll 파일 등)도 함께 메모리로 적재된다.</p>
<p>3 . 명령어 가져오기 및 실행 프로그램이 메모리에 올라오면, CPU가 실행을 시작한다. PC가 첫 번째 명령어의 주소를 가리킨다.</p>
<p>CPU는 명령어 사이클(Fetch-Decode-Execute-Cycle)을 반복하면서 한 줄씩 명령을 가져와 실행한다.</p>
<p>① Fetch CPU가 메인 메모리(RAM)에서 명령어를 가져온다.</p>
<p>② Decode 가져온 명령어를 해석하여 어떤 작업을 해야 하는지 결정한다.</p>
<p>③ Execute 해당 명령을 실행하여 결과를 만든다.</p>
<p>4 . 프로그램 조작 사용자가 키보드로 문서를 작성하면, 운영 체제가 이를 받아서 응용 프로그램으로 전달한다.</p>
<p>작성한 문서를 저장할 때는 운영 체제가 파일 시스템을 통해 하드디스크에 기록한다.</p>
<p>5 . 프로세스 관리 사용자는 특정 응용 프로그램을 사용하면서 인터넷 브라우저, 음악 플레이어 등 다른 프로그램도 실행할 수 있다.</p>
<p>운영 체제는 스케줄러(CPU 스케줄링)를 통해 여러 프로세스를 관리하며, Round Robin, Priority Scheduling 등을 사용하여 CPU 시간을 나누어 사용한다.</p>
<p>6 . 프로그램 종료 사용자가 응용 프로그램을 닫으면, 운영 체제는 프로세스 테이블에서 해당 프로세스를 제거한다.</p>
<p>프로그램이 사용하던 메모리를 해제하고, 저장된 데이터를 하드디스크에 기록한다.</p>
<p>CPU는 다른 작업을 수행할 준비를 한다.</p>
<p>운영 체제가 할 일은 관점(View)에 따라 달라진다.</p>
<p>07 사용자 관점 (User View)</p>
<p>편의성, 사용의 용이성, 좋은 성능을 원한다. ⌎ Convenience, Ease of Use, Good Performance</p>
<p>이 과정에서 자원 활용(Resource Utilization)에 대한 고려는 크지 않다.</p>
<p>최대의 활용 연결된 여러 대의 터미널을 통해 접근할 수 있는 대형 컴퓨터(Mainframe)나 미니 컴퓨터(Minicomputer)의 경우</p>
<p>사용자의 자원 활용을 극대화하기 위해서 설계된다.</p>
<p>이처럼 운영 체제는 범용 컴퓨터에서도 다양한 요구를 반영하여 작동한다.</p>
<p>① 워크스테이션 사용자 (Workstations)</p>
<p>전용 자원을 자유롭게 사용할 수 있지만, 서버의 공유 자원도 빈번하게 활용할 수 있도록 설계된다.</p>
<p>즉, 사용 용이성과 자원 활용이 균형을 이루는 구조를 갖는다.</p>
<p>② 휴대용 컴퓨터 자원이 제한적이므로 사용성과 배터리 효율을 최적화하는 방식으로 설계된다.</p>
<p>③ 가전제품 및 임베디드 시스템 가전제품이나 자동차 내의 임베디드 컴퓨터처럼 일부 시스템에서는 사용자 관점이 거의 없거나, 매우 제한적으로 적용된다.</p>
<p>08 시스템 관점 (System View)</p>
<p>OS는 하드웨어와 가장 밀접하게 연관된 프로그램.</p>
<p>1 . 자원 할당자 (Resource Allocator)</p>
<p>OS는 모든 자원의 관리자로서 동작하며, 필요한 자원을 적절히 할당하는 역할을 수행한다.</p>
<p>또한, 자원을 둘러싼 상충하는 요청들을 공정하고 효율적으로 조정하여 시스템을 원활하게 운영하도록 결정한다.</p>
<p>운영 체제에 대한 또 다른 관점으로는, 다양한 I/O(입·출력) 장치와 사용자 프로그램을 효과적으로 제어하는 역할이 강조될 수 있다.</p>
<p>2 . 제어 프로그램 (Control Program)</p>
<p>운영 체제는 컴퓨터의 오류 및 부적절한 사용을 방지하기 위해 사용자 프로그램의 실행을 관리한다.</p>
<p>특히, 입·출력 장치의 작동 및 제어와 밀접한 관련이 있다.</p>
<p>OS의 개념과 진화</p>
<p>OS는 한마디로 정의하기 어렵다. 다양한 역할을 포괄하며, 수많은 디자인과 사용 형태가 존재한다.</p>
<p>오늘날 운영 체제는 선박, 우주선, 게임기, TV, 산업 제어 시스템뿐만 아니라 토스터기까지 다양한 기기에 적용되고 있다.</p>
<p>이는 과거 군사용으로 사용되던 고정형 컴퓨터가 점차 범용화되었으며, 자원 관리와 프로그램 제어의 필요성이 증가했기 때문이다.</p>
<p>전통적으로, OS 설치 CD에 포함된 것이 운영 체제이고, 그 외는 응용 프로그램이라는 단순한 관점이 있었다.</p>
<p>그러나, 사용자가 OS를 주문했을 때 공급업체가 제공하는 모든 것이 OS로 간주되기도 하며,</p>
<p>포함된 기능은 시스템에 따라 크게 다르고, IT 환경의 변화에 따라 OS에 대한 개념도 진화하고 있다.</p>
<p>특히 Google, VMware, Microsoft가 새로운 OS 개념을 이끌고 있다.</p>
<p>예를 들어, 검색 엔진과 함께 웹 기반 애플리케이션, 캘린더, Gmail, Google 드라이브 등의 서비스가 OS의 역할을 확장하는 방향으로 변화하고 있다.</p>
<p>1 . Google OS를 단순히 PC를 실행하는 소프트웨어가 아닌, 사용자가 PC를 켠 후 Google Apps, 검색, 웨이브 등 웹 기반 애플리케이션을 이용하는 환경으로 바라본다.</p>
<p>이를 반영한 대표적인 예가 데스크톱용 웹 OS인 Chrome OS이다. 즉, 과거에는 존재하지 않았던 웹 중심의 운영 체제 개념을 제시한 것이다.</p>
<p>2 . VMware 클라우드 데이터 센터에서 애플리케이션과 인프라를 연결하는 역할을 클라우드 OS로 정의한다.</p>
<p>대표적인 예로 vSphere 7이 있으며, 이는 가상화 환경에서 자원을 효율적으로 관리하고 배포하는 운영 체제 개념을 반영한 것이다.</p>
<p>3 . Microsoft 현재 가상화 시장에서는 VMware에, 웹 기반 애플리케이션 분야에서는 Google에 밀리고 있다.</p>
<p>이를 감안하여, MS는 데스크톱 지배력과 클라우드 컴퓨팅의 비전을 결합하는 데 주력하고 있다.</p>
<p>이 과정에서 쉐어포인트 워크스페이스와 같은 서비스가 시도되었으나 실패하였고, 그 후 Azure라는 퍼블릭 클라우드 서비스를 제공하고 있다.</p>
<p>현재 클라우드 시장에서 AWS가 32%, Azure가 20%의 점유율을 기록하고 있다.</p>
<p>10 OS 일반적 정의 컴퓨터에서 메인 메모리에 상주하면서 항상 실행되는 시스템 프로그램을 일반적으로 커널(Kernel)이라고 한다.</p>
<p>커널은 OS의 핵심 부분으로, OS의 부분집합에 포함된다. 시스템 자원 관리, 프로세스 관리, 메모리 관리 등을 담당한다.</p>
<p>OS는 커널을 포함하여, 사용자 공간(User Space)에서 실행되는 응용 프로그램과 시스템 라이브러리, 미들웨어 등으로 구성된다.</p>
<p>커널은 운영 체제의 핵심으로, 하드웨어와 직접적으로 상호작용하며 시스템 자원을 관리하고, 사용자 프로그램의 실행을 제어하는 중요한 역할을 한다.</p>
<p>그 외의 다른 모든 프로그램은 응용 프로그램에 해당한다.</p>
<p>모바일 운영 체제인 iOS와 Android는 데이터베이스, 멀티미디어 및 그래픽을 지원하는 미들웨어와 함께 코어 커널을 갖추고 있다.</p>
<p>11 OS의 처리 공유 메모리에 접근을 제공하는 공통 버스를 통해 연결된 여러 개의 장치 제어기와 하나 이상의 CPU로 구성된다.</p>
<p>CPU와 장치 제어기는 메모리 사이클을 얻기 위해 서로 경쟁하며 병행 수행된다.</p>
<p>각 장치 제어기는 특정 장치를 관리한다. 또한, 각 장치 제어기는 자신만의 로컬 버퍼를 가지고 있다.</p>
<p>공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공된다. 메모리 제어기는 메모리 접근을 동기화하여 충돌을 방지하고 효율적인 자원 관리를 한다.</p>
<p>1 . H/W 장치 시스템 버스를 통해 프로그램을 실행 중인 CPU에 신호를 보내 인터럽트(Interrupt)를 발생시킬 수 있다.</p>
<p>예를 들어, 마우스 인터럽트, 키보드 인터럽트 등은 하드웨어 인터럽트에 해당한다.</p>
<p>이러한 인터럽트는 액션을 취한 장치가 신호를 보내며, 이는 OS와 H/W 간의 상호작용의 핵심 부분이다.</p>
<p>장치 제어기는 이러한 통신을 인터럽트를 통해 실행한다. 이를 인터럽트 구동식 컴퓨터라고 부른다.</p>
<p>(Interrupt Driven Computer)</p>
<p>인터럽트는 적절한 인터럽트 서비스 루틴(ISR)이 있는 시작 주소로 제어를 전달한다.</p>
<p>프로세스는 신호를 받으면 CPU는 해당 작업을 처리할 수 없음을 알리고, 운영체제가 대신 처리하도록 한다.</p>
<p>이 과정에서 인터럽트 벡터 테이블을 참조하여 ISR의 주소를 찾고, 이를 통해 해당 인터럽트를 처리한다.</p>
<p>인터럽트가 요청되면, 인터럽트 벡터를 사용하여 인터럽트를 유발한 장치에 맞는 ISR의 주소를 제공하게 된다.</p>
<p>인터럽트 벡터는 여러 인터럽트 서비스 루틴에 대한 주소 배열을 가지며, 각 인터럽트는 고유한 장치 번호로 색인화되어 인터럽트 요청을 처리한다.</p>
<p>2 . 응용 소프트웨어 트랩(Trap) 또는 예외(Exception)는</p>
<p>오류(예: 0으로 나누기, 유효하지 않은 메모리 접근)나 사용자 프로그램의 운영 체제 서비스 요청에 의해 유발되는 소프트웨어 인터럽트이다.</p>
<p>이러한 인터럽트는 신호를 받으면 CPU는 이를 처리할 수 없다는 신호를 보내고, 운영체제가 대신 처리한다.</p>
<p>그 후, 인터럽트 벡터 테이블을 참조하여 적절한 ISR의 주소를 찾아 이를 수행한다.</p>
<p>OS는 인터럽트 구동(Interrupt Driven) 방식으로 동작한다.</p>
<p>CPU가 인터럽트 요청을 받으면, 현재 실행 중인 명령을 완료한 후,</p>
<p>현재 수행 중인 프로그램을 일시 중단한 다음 해당 프로그램의 상태를 안전한 장소에 저장한다.</p>
<p>그 후, 인터럽트 처리 루틴을 실행하여 인터럽트 원인을 찾아내고 (인터럽트 벡터 테이블을 통해), 해당 ISR 또는 인터럽트 핸들러를 실행하여 인터럽트를 처리한다.</p>
<p>3 . 인터럽트 원인 판별 방법 ① 폴링 방식 (Polling)</p>
<p>주기적으로 상태를 체크하는 방법이다.</p>
<p>하지만 이 방식은 시간이 오래 걸리고 비효율적이어서, 보통 16비트 이하의 단순한 컴퓨터 시스템에서만 사용된다.</p>
<p>② 인터럽트 벡터 방식 (Vectored Interrupt)</p>
<p>인터럽트 발생 시, ISR을 수행하여 인터럽트 원인에 대한 처리를 하며, 이를 통해 빠르게 인터럽트에 대응할 수 있다.</p>
<p>만약 여러 작업이 동시에 이루어지면, 각 작업은 CPU의 의존성이 없이 독립적으로 실행되며, 작업이 완료된 후에는 각각의 결과가 처리된다.</p>
<p>[교제] 운영체제 제 10판 [원그래프 출처] Examples - Apache ECharts</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/os_01.html</guid>
  <pubDate>Thu, 06 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>통신 기술의 기초</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_02.html</link>
  <description><![CDATA[ 




<p>통신 기술에 관한 전반적인 개념에 대해 다루고자 한다.</p>
<section id="산술논리연산장치" class="level1">
<h1>01 산술논리연산장치</h1>
<p><code>Arithmetic and Logic Unit, ALU</code></p>
<p>컴퓨터 내부에서 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행하는 하드웨어 부품.</p>
<p>예를 들어, 7을 3으로 나눌 때 몫과 나머지를 각각 구하는 연산은 ALU에서 처리된다.</p>
<p>이때, 몫은 7 / 3 = 2, 나머지는 7 % 3 = 1로 계산된다.</p>
<p>CPU와 MCU 모두 ALU를 가지고 있으며, 산술 연산과 논리 연산을 처리하는 핵심 컴포넌트이다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU는 컴퓨터의 중앙 처리 장치로, 복잡한 계산을 수행하고, 메모리와 입출력 장치와의 데이터 처리를 담당한다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>작은 컴퓨터 시스템을 내장한 마이크로칩으로, 주로 임베디드 시스템에서 사용된다.</p>
<p>MCU는 CPU에 비해 상대적으로 간단하고 저전력, 소형화된 시스템으로, 제한된 리소스 환경에서도 효율적으로 동작한다.</p>
<p>02 레지스터 (Register)</p>
<p>컴퓨터의 CPU 내에서 데이터나 명령어를 저장하고 처리하는 빠른 기억 장치.</p>
<p>CPU는 연산을 수행하거나 메모리와 데이터 교환 시 레지스터를 사용하여 데이터를 중간에 임시로 저장한다.</p>
<p>레지스터는 메모리 역할을 수행하는 일시적인 저장소 역할을 한다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU 내의 레지스터는 매우 빠른 임시 저장소로, 연산에 필요한 데이터나 명령어를 빠르게 저장하고 처리한다.</p>
<p>CPU 자체는 레지스터 외에 큰 저장공간 역할을 하지 않는다.</p>
<p>CPU는 대량의 데이터를 영구적으로 저장하는 역할을 하지 않으며, 주 메모리(RAM)나 저장장치(HDD, SSD 등)처럼 큰 용량의 데이터를 관리하지 않는다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>MCU는 비교적 작은 시스템으로, 자체적으로 내장 메모리(ROM, RAM)를 가지고 있다.</p>
<p>이 메모리는 프로그램 코드, 변수, 데이터를 저장하는 역할을 하며, CPU처럼 레지스터는 연산에 필요한 데이터를 임시로 저장하는 용도로 사용된다.</p>
<p>MCU는 외부 메모리와 연결하여 더 많은 데이터를 처리할 수 있지만, 레지스터는 여전히 임시 저장소 역할을 한다.</p>
<p>③ 레지스터 초기화 특정 비트를 0으로 설정하려면 AND 연산과 마스크(Mask)를 사용하여 원하는 비트를 0으로 만들 수 있다. 반대로, 특정 비트를 1로 설정하려면, OR 연산과 마스크를 사용한다.</p>
<p>8비트 값이 10101101일 때, 3번째 비트를 0으로 설정하려면 마스크 11110111과 AND 연산을 수행한다.</p>
<p>반대로, 5번째 비트를 1로 설정하려면 마스크 00010000과 OR 연산을 수행한다.</p>
<p>모든 비트를 0으로 설정할 경우, 단순히 레지스터 값을 0으로 초기화하는 것이 일반적이다.</p>
<p>03 RS-232 (Recommended Standard 232)</p>
<p>직렬 통신 프로토콜의 한 종류로, 데이터를 한 비트씩 순차적으로 전송하는 방식이다.</p>
<p>직렬 데이터 전송을 위한 초기 표준. 간단한 구현과 넓은 호환성을 바탕으로 임베디드 시스템과 주변 기기 통신에 오랫동안 사용되어 왔다.</p>
<p>① 통신 방식</p>
<p>TX(전송), RX(수신), GND(접지)와 같은 신호선을 사용하여 데이터를 송수신한다.</p>
<p>기본적으로 비동기식 통신 방식을 채택하고 있으며, 송수신 측이 서로 동기화된 상태에서 데이터를 교환하는 방식이다.</p>
<p>비동기식 통신에서 각 데이터는 스타트 비트, 데이터 비트, 패리티 비트, 스톱 비트로 구분된다.</p>
<p>② 사용 범위 RS-232는 동기식 통신 방식으로도 사용할 수 있다. 이 경우, 클럭 신호를 추가하여 데이터 전송 속도를 동기화한다.</p>
<p>이는 컴퓨터, 서버 간의 통신에 널리 사용되며, 특히 임베디드 시스템에서도 사용된다.</p>
<p>또한, 모뎀, 프린터, 터미널 장치 등과의 연결에도 사용된다.</p>
<p>04 기본 논리 연산 디지털 회로와 프로그래밍에서 사용하는 가장 기본적인 연산으로, 논리 상태(0과 1)를 처리하는 데 사용된다.</p>
<p>아래는 기본 논리 연산의 주요 종류이다.</p>
<p>① AND 두 입력이 모두 참(1)일 때만 결과가 참(1)이 되는 연산.</p>
<p>AND 연산의 진리표</p>
<p>② OR 입력 중 하나라도 참(1)이면 결과가 참(1)이 되는 연산.</p>
<p>OR 연산의 진리표</p>
<p>③ NOT 단일 입력에 대해, 입력이 참이면 결과가 거짓(0), 입력이 거짓이면 결과가 참(1)이 되는 연산.</p>
<p>NOT 연산의 진리표</p>
<p>④ XOR 두 입력이 서로 다를 때만 참(1)이 되는 연산. 즉, 둘 중 하나만 참이어야 참이 된다.</p>
<p>XOR 연산의 진리표</p>
<p>⑤ NAND AND 연산 후에 결과를 부정(NOT)한 연산. AND의 반대 결과를 생성한다.</p>
<p>NAND 연산의 진리표</p>
<p>⑥ NOR OR 연산 후에 결과를 부정(NOT)한 연산. OR의 반대 결과를 생성한다.</p>
<p>NOR 연산의 진리표</p>
<p>이러한 논리 연산은 전자 회로와 디지털 컴퓨터에서 기본 연산으로 사용된다.</p>
<p>간단한 결정이나 조건을 설정하는 데 유용하며, 복잡한 연산도 이러한 기본 연산을 조합하여 처리할 수 있다.</p>
<p>05 통신 기술 Wi-Fi, Bluetooth, 5G 같은 무선 통신 기술에서 데이터 송수신 과정에서 모뎀 역할을 하는 칩셋이나 모듈이 사용되며, 동기/비동기 통신 방식과 대역폭이 전송 속도와 품질에 중요한 영향을 미친다.</p>
<p>서버 기반의 제어 시스템을 조작할 때는 C++과 같은 언어를 활용하여 GUI를 개발하거나 데이터를 효율적으로 처리할 수 있으며,</p>
<p>특히 실시간 데이터 처리와 고성능 연산이 요구되는 환경에서 유용하다.</p>
<p>① 제어 흐름 관리 for 문과 if-else 문을 사용하며, 이를 통해 데이터를 수집하거나 명령을 실행하는 프로세스를 제어하는 코드를 작성한다.</p>
<p>이러한 방식은 시리얼 통신, 네트워크 통신 등 다양한 통신 방식에 맞춰 데이터 패킷을 처리하거나, 사용자 입력을 관리하여 프로그램의 동작을 유연하게 제어하는 데 중요한 역할을 한다.</p>
<p>② C++의 활용 C++는 성능과 메모리 관리를 직접 제어할 수 있는 언어로, 이를 활용하면 실시간 통신 시스템에서 응답성을 크게 향상시킬 수 있다.</p>
<p>특히, 서버 제어 시스템에서 통신 장비와 상호 작용하는 프로그램을 개발할 때, C++의 효율성과 네트워크 라이브러리를 활용하면 안정적이고 빠른 성능을 달성할 수 있다.</p>
<p>③ 디지털 (Digital) 0과 1과 같은 이진 값을 사용하여 정보를 표현한다.</p>
<p>디지털 신호는 일정한 시간 간격으로 구분된 이진 상태를 나타내며, 최소 단위는 비트이다.</p>
<p>이진 상태가 “0”과 “1”로만 표현되므로, 값은 이산적이다.</p>
<p>④ 아날로그 (Analog) 시간에 따라 연속적으로 변화하며, 0과 1 사이의 모든 값을 가질 수 있다.</p>
<p>06 데이터 단위</p>
<p>① 비트 (Bit) 0과 1로 이루어진 가장 작은 데이터 단위. 디지털 정보의 기본 단위로, 두 가지 상태를 표현할 수 있다.</p>
<p>② 니블 (Nibble): 4비트 1니블은 4개의 비트로 구성된다. 보통 1바이트를 2니블로 나누는 데 사용된다.</p>
<p>③ 바이트 (Byte): 8비트 1바이트는 8비트로 이루어지며, 컴퓨터에서 문자나 데이터를 표현하는 기본 단위로 많이 사용된다.</p>
<p>④ 워드 (Word) 프로세서가 한 번에 처리할 수 있는 데이터의 크기로, 시스템 아키텍처에 따라 달라진다.</p>
<p>워드 크기는 아키텍처에 따라 대체로 위와 같이 설정된다.</p>
<p>과거에는 16비트 였던 워드 크기가 현재는 32비트 혹은 64비트로 변화되어 사용된다.</p>
<p>07 진법 컴퓨터와 디지털 시스템에서는 데이터를 다양한 진법으로 표현한다.</p>
<p>각 진법은 사용되는 숫자의 개수와 자리 값을 기반으로 데이터를 표현하며, 특정 진법은 특정 상황에서 유용하다.</p>
<p>① 2진수(Binary)</p>
<p>숫자 2를 기반으로 하는 진법으로, 0과 1의 두 가지 숫자만 사용된다. 디지털 회로와 컴퓨터 내부 연산에서 가장 기본적인 진법이다.</p>
<p>2의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>② 8진수(Octal) 숫자 8을 기반으로 하는 진법으로, 0 ~ 7의 8가지 숫자를 사용한다. 3개의 이진수 그룹을 한 자리의 8진수로 표현할 수 있어, 컴퓨터 시스템에서 간단한 데이터 표현에 사용된다.</p>
<p>8의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>③ 10진수 (Decimal) 우리가 일상생활에서 사용하는 기본 진법.</p>
<p>숫자 10을 기반으로 하는 진법으로, 0 ~ 9의 숫자를 사용한다.</p>
<p>10의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>④ 16진수 (Hexadecimal)</p>
<p>숫자 16을 기반으로 하는 진법으로, 숫자 0 ~ 9와 문자 A ~ F를 사용한다.</p>
<p>문자 A ~ F 는 10 ~ 15의 값을 나타낸다.</p>
<p>4개의 이진수 그룹을 한 자리의 16진수로 표현할 수 있어, 메모리 주소나 색상 표현 등에 자주 사용된다.</p>
<p>16의 거듭제곱으로 자리값이 결정된다.</p>
<p>08 8비트의 정의 8자리의 2진수로 표현되며, 각 자리의 가중치는 다음과 같다:</p>
<p>왼쪽에서 오른쪽으로 자리의 가중치가 점점 작아진다.</p>
<p>① 값의 범위</p>
<p>8비트의 최소값과 최대값</p>
<p>총 가능한 값의 개수는 2⁸ = 256 가지이다. 11111111₂은 각 자리의 가중치를 모두 더하는 방식으로 계산된다.</p>
<p>② 응용 8비트의 범위는 0 ~ 255로, 컴퓨터가 데이터를 저장하거나 표현할 때 자주 사용된다.</p>
<p>색상 표현에서 RGB 값은 각각 0 ~ 255로 표현된다. 문자 저장에 사용되는 ASCII 코드도 보통 8비트를 사용한다.</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_02.html</guid>
  <pubDate>Mon, 07 Oct 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>컴퓨터 그래픽스</title>
  <link>https://shinjihan.github.io/studylog/ch/cg_01.html</link>
  <description><![CDATA[ 




<p>과학, 공학, 의학, 경영 등 다양한 분야에서 활용되는 컴퓨터 그래픽스의 응용 분야에 대해 다루고자 한다.</p>
<p>01 컴 퓨 터 그 래 픽 스 (CG, Computer Graphics)</p>
<p>컴퓨터로 그림을 생성하는 기술.</p>
<p>아래는, 이전부터 활발하게 응용된 분야를 나열한 목록이다.</p>
<p>이 중에서 기술의 상호작용이 두드러지는 가상 현실과 애니메이션 및 게임에서의 응용에 대해 알아보고자 한다.</p>
<p>컴퓨터 그래픽스의 응용분야</p>
<p>메 타 버 스 (Metaverse) 가상현실을 구현한 여러 형태나 콘텐츠들을 통칭한다.</p>
<p>메타버스는 기술적 진보와 인터넷의 발전으로 구현된 디지털 환경이며, 이는 가상세계와 달리, 여러 기술적 요소가 결합된 거대한 디지털 생태계이다.</p>
<p>초월(beyond), 가상을 의미하는 meta와 세계를 의미하는 universe의 합성어이다. (1992년 출간된 소설 ‘스노 크래시’ 속 가상 세계 명칭인 ’메타버스’에서 유래한다.)</p>
<p>라 이 프 로 깅 (Lifelogging) 개인의 삶을 디지털로 기록하여 가상세계로 옮기는 개념으로, 메타버스와 관련이 깊다.</p>
<p>메타버스에서는 사용자들이 디지털 아바타를 통해 자신의 삶을 반영하고, 그 기록을 가상세계에서 공유 및 저장할 수 있다.</p>
<p>삶을 뜻하는 life와 일지 작성을 의미하는 logging의 합성어이다. 특히 logging은 일반적으로 컴퓨터 시스템에서의 사용 기록을 포함하여 모든 행위의 기록을 의미한다.</p>
<p>제페토</p>
<p>내 아바타로 즐기는 또 다른 세상</p>
<p>web.zepeto.me</p>
<ol type="1">
<li>가 상 현 실 (VR, Virtual Reality) 실제와 유사하지만 실제가 아닌 인공 환경. 현실 세계에서 할 수 없는 활동을 할 수 있다.</li>
</ol>
<p>Beat Saber on Steam</p>
<p>Beat Saber is a VR rhythm game where you slash the beats of adrenaline-pumping music as they fly towards you, surrounded by a futuristic world.</p>
<p>store.steampowered.com</p>
<p>Half-Life: Alyx on Steam</p>
<p>Half-Life: Alyx is Valve’s VR return to the Half-Life series. It’s the story of an impossible fight against a vicious alien race known as the Combine, set between the events of Half-Life and Half-Life 2. Playing as Alyx Vance, you are humanity’s only</p>
<p>store.steampowered.com</p>
<p>Microsoft Flight Simulator - The next generation of one of the most beloved simulation franchises</p>
<p>Microsoft Flight Simulator is the next generation of one of the most beloved simulation franchises.</p>
<p>www.flightsimulator.com</p>
<ol start="2" type="1">
<li>증 강 현 실 (AR, Augmented Reality) 현실 세계에 디지털 정보를 추가해 현실의 개념을 확장하는 기술.</li>
</ol>
<p>Pokemon GO – Pokémon GO</p>
<p>GO로켓단 GO로켓단의 마수가 “Pokémon GO”의 세계에 뻗쳐오고 있습니다! “스페셜리서치” 클리어나 “그림자 포켓몬”을 구하는 과정에서, GO로켓단에게 승부를 걸어 야망을 저지할 수 있습니다.</p>
<p>pokemongolive.com</p>
<p>이케아, 비주얼 서치 기능 탑재한 ‘이케아 플레이스’ 안드로이드 앱 출시</p>
<p>[서울 - 3월 21일] 글로벌 홈퍼니싱 기업 이케아는 가상으로 가구를 공간에 배치할 수 있는 증강현실(AR) 앱 ’이케아 플레이스(IKEA Place)’를 안드로이드 버전으로 출시한다.</p>
<p>www.ikea.com</p>
<p>4D Interactive Anatomy</p>
<p>www.4danatomy.com</p>
<ol start="3" type="1">
<li><p>혼 합 현 실 (MR, Mixed Reality) 가상 세계와 현실 세계를 섞어서 VR 헤드셋을 통해 보여주는 것으로 두 가지 유형이 있다.</p></li>
<li><p>가상 객체 ⇨ 현실 세계:</p></li>
</ol>
<p>사용자가 VR 헤드셋의 카메라를 통해 현실 세계를 볼 때, 가상 ​​객체가 시야에 매끄럽게 혼합됨.</p>
<p>Leading Innovation in Augmented Reality</p>
<p>Magic Leap is leading innovation in Augmented Reality by bringing together industry-leading optics, scalable production, AI capabilities &amp; immersive AR experiences.</p>
<p>www.magicleap.com</p>
<ol start="2" type="1">
<li>실제 객체 ⇨ 가상 세계:</li>
</ol>
<p>가상 세계에서 플레이하는 VR 게이머를 보는 것처럼, 가상 세계에 혼합된 VR 이용자의 카메라 뷰.</p>
<p>Richie’s Plank Experience on Steam</p>
<p>You’re on a plank, 80 stories high. Knees shaky, palms sweaty. You have a choice. Do you walk or do you freeze? Richie’s Plank is the only VR experience that lets you clone any real-world plank into the virtual world for 2X the immersion.</p>
<p>store.steampowered.com</p>
<ol start="4" type="1">
<li>확 장 현 실 (XR, Extended Reality) AR, VR, MR을 포함한 모든 확장된 현실 기술을 통칭.</li>
</ol>
<p>Meta Quest의 Meta Horizon 월드 | Quest VR 게임</p>
<p>www.meta.com</p>
<p>거 울 세 계 (Mirror World) 현실 세계를 반영한 가상 공간.</p>
<p>개요 – Google 어스</p>
<p>세계에서 가장 정교한 지구본</p>
<p>www.google.com</p>
<p>이러한 기술들이 모두 메타버스를 구성하는 요소로, 기술이 아직 완전히 성숙하지는 않았으나, 적용된 정도에 따라 메타버스로 분류될 수 있다.</p>
<p>Meta는 기존의 것에서 한 단계 발전된 상태를 의미하며, 다양한 분야에서 이 용어가 결합되어 사용된다.</p>
<ol type="1">
<li><p>메 타 인 지 (Metacognition) 자신의 인지 과정을 인식하고 조절하는 능력.</p></li>
<li><p>메 타 검 색 (Meta Search) 다양한 검색 알고리즘을 사용하여 여러 웹페이지를 취합해 검색 결과를 보여주는 기술.</p></li>
</ol>
<p>가격 비교 사이트들이 메타 검색 방식을 사용하여 다양한 온라인 쇼핑몰의 제품 가격을 취합 및 비교할 수 있게 한다.</p>
<ol start="3" type="1">
<li><p>메 타 데 이 터 (Metadata) 데이터에 대한 데이터, 정보의 구조 및 속성을 설명하는 데이터.</p></li>
<li><p>메 타 프 로 그 램 (Metaprogram) 프로그램을 제어하거나 최적화하는 프로그램.</p></li>
</ol>
<p>어셈블리어(Assembly Language):</p>
<p>컴퓨터의 하드웨어와 직접 소통할 수 있는 저수준 프로그래밍 언어. 기계어(Machine Code, 0과 1로 이루어진 이진수)와 1:1로 대응된다.</p>
<p>컴파일러(Compiler):</p>
<p>고수준 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환해 주는 프로그램.</p>
<p>애 니 메 이 션 &amp; 게 임 그래픽 기술은 2차원 또는 3차원 애니메이션 영화를 제작하는 데 사용된다. 실제로 촬영된 영상과 그래픽 기술을 조합하여 현실감을 높이기도 한다.</p>
<p>매우 복잡한 모델링과 고화질의 렌더링을 사용한다. 따라서 이를 위해서는, 많은 양의 인적 · 물적 자원이 필요하다.</p>
<p>그래픽 기술은 캐릭터, 배경화면, 애니메이션 등에도 사용된다. 게임은 (온 · 오프라인에 관계없이) 사용자의 반응이 화면에 즉시 반영되어야 한다.</p>
<p>이를 구현하기 위해, 아래의 조건을 고려해야 한다:</p>
<p>사용자와 프로그램 사이의 상호 작용 설계 상호 작용에 걸리는 시간을 최소화</p>
<p>C 라이브러리 사용 ⇨ 프로그래밍 언어 (C 프로그래밍 언어에서 제공하는 라이브러리를 사용하여 프로그램을 작성하는 것.)</p>
<p>C 라이브러리(C Library):</p>
<p>C 프로그래밍 언어에 포함된 여러 함수들의 모음으로, 프로그래머가 특정 기능을 직접 작성하지 않고도 사용할 수 있도록 만들어진 도구들.</p>
<p>Low–level 게임 개발</p>
<p>하드웨어에 가까운 수준에서 직접적으로 시스템 자원(CPU, GPU, 메모리 등)을 제어하는 방식으로 게임을 개발하는 것.</p>
<p>저수준 프로그래밍(low–level programming)을 통해 개발하는 게임은 성능이 뛰어나고, 하드웨어 자원을 효율적으로 사용한다.</p>
<p>그러나 개발 과정이 복잡하고, 시간 소모가 크다.</p>
<p>DirectX &amp; OpenGL</p>
<p>하드웨어 가속을 사용하여 그래픽을 처리할 수 있는 저수준 API이다. 게임 개발자가 GPU(Graphics Processing Unit)를 직접 제어하고, 고성능 그래픽 렌더링을 구현한다.</p>
<p>아래는 고수준 게임 개발에 직접적인 역할을 하지는 않지만, 다양한 기술적 맥락에서 간접적으로 게임 개발에 응용되는 기술이다.</p>
<ol type="1">
<li>Java3D Java 기반 3D 그래픽 API.</li>
</ol>
<p>3D 그래픽 애플리케이션 및 게임을 개발할 수 있는 프레임워크. 3D 그래픽을 쉽게 만들 수 있는 고수준 API이기 때문에 게임 개발에 사용될 수 있다.</p>
<p>그러나 Unity, Unreal 같은 최신 게임 엔진에 비해 인기가 적다.</p>
<ol start="2" type="1">
<li>LLM (Large Language Model, 대형 언어 모델) LLM은 자연어 처리에 사용되는 대형 신경망 모델로, 게임 개발에서는 대화형 AI 캐릭터, 스토리 생성, 대화 시스템 등을 구현하는 데 사용된다.</li>
</ol>
<p>특히, 대화형 RPG 게임이나 스토리 기반 게임에서 플레이어와의 상호작용을 개선하는 데 유용하다.</p>
<ol start="3" type="1">
<li>VAE (Variational Autoencoder, 변분 오토인코더) 생성 모델 중 하나로, 데이터를 압축하여 새로운 데이터를 생성하는 방식이다. 게임 개발에서는 캐릭터 디자인이나 레벨 생성 같은 곳에서 VAE를 사용할 수 있다.</li>
</ol>
<p>예를 들어, 게임의 다양한 캐릭터나 맵을 자동으로 생성하는 데 응용할 수 있다.</p>
<ol start="4" type="1">
<li>GAN (Generative Adversarial Network, 생성적 적대 신경망) 두 개의 신경망(생성자와 판별자)이 경쟁하면서 더 나은 데이터를 생성하는 모델.</li>
</ol>
<p>게임 개발에서는 게임 내 캐릭터 디자인, 배경 생성, 아트 디자인 등을 자동화하는 데 사용할 수 있다. 특히, 고품질의 그래픽 콘텐츠를 자동으로 생성하는 데 유용하다.</p>
<ol start="5" type="1">
<li>Diffusion 모델 (Stable Diffusion) 점차 데이터를 더 정교하게 만들어가는 방식으로 이미지를 생성한다.</li>
</ol>
<p>특히 이미지 생성에서 강력한 성능을 발휘하며, 게임 개발에서는 게임 아트나 배경 생성, 캐릭터 디자인에 사용할 수 있다.</p>
<p>0 2 . 컴 퓨 터 그 래 픽 스 구 성 요 소 모델링(Modeling)과 렌더링(Rendering)라는 두 가지 카테고리로 구분할 수 있다.</p>
<ol type="1">
<li>모델링은 무엇을 그릴 것인지에 관련된 것으로, 그래픽으로 표현하고자 하는 장면(Scene) 내부의 물체(Object)를 정의하는 작업을 말한다.</li>
</ol>
<p>물체를 선분의 집합으로 정의하려면 선분의 양 끝점 위치를 명시하는 작업이 필요하다.</p>
<p>즉, 평면 다각형의 집합으로 다각형 정점의 위치를 명시하는 작업이 모델링이다. 이 밖에 여러 가지 물체를 조합하여 새로운 물체를 정의하는 작업도 모델링에 속한다.</p>
<p>모델링은 2차원 또는 3차원 물체를 표현할 수 있는 자료 구조와 해당 자료 구조를 처리할 수 있는 알고리즘을 포함하고 있다.</p>
<ol start="2" type="1">
<li>렌더링은 모델링에 의해 정의된 물체를 어떻게 그릴 것인지에 관련된 것이다. (우리가 화면에서 보는 모든 그림 ⇨ 렌더링의 결과)</li>
</ol>
<p>아래는 렌더링과 관련하여 고려해야 하는 요소이다:</p>
<p>관찰자의 위치 물체 표면의 재질 조명의 세기 및 위치 3D 객체를 2D 평면으로 변환하는 과정 등</p>
<p>사용자가 원하는 바에 따라 그래픽을 제공해야 하는 개발자들은 사용자 인터페이스(User Interface)를 제3의 구성 요소로 간주하기도 한다.</p>
<p>사용자와의 상호 작용 윈도우나 메뉴 구성 등 교제: Open GL로 배우는 3차원 컴퓨터 그래픽스</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/cg_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>팅커캐드 사용법</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_01.html</link>
  <description><![CDATA[ 




<p>팅커캐드(Tinkercad)는 Autodesk에서 제공하는 웹 기반의 3D 설계, 전자 회로 시뮬레이션, 코딩 도구이다. 간단한 전자 회로를 설계하고 이를 코드로 제어하는 과정에 대해 다루고자 한다.</p>
<p>팅커캐드(Tinkercad) 사이트로 들어간다.</p>
<p>https://www.tinkercad.com/dashboard</p>
<ul>
<li>만들기 에서 회로를 클릭한다.</li>
</ul>
<p>첫 화면</p>
<p>첫 번째 예제</p>
<p>위와 같이 연결한 다음, 시뮬레이션 시작버튼을 클릭하면, LED가 깜박거린다.</p>
<p>세부사항: 저항을 클릭한 뒤 ’220’을 입력한다.</p>
<p>코드 ⇨ 블록 ⇨ 문자 를 클릭하면 회로도의 코드를 볼 수 있다.</p>
<p>[ 1 ]</p>
<p>이 코드는 아두이노(Arduino)에서 LED_BUILTIN 핀(일반적으로 13번 핀)에 연결된 내장 LED를 1초마다 깜박이게 하는 C++ 코드이다.</p>
<p>기본적으로 제공되는 코드이며, 초보자도 쉽게 이해할 수 있는 코드이다. 이 코드에서는 아두이노의 고수준 함수를 사용하여 하드웨어를 직관적으로 제어하고 있다.</p>
<p>void setup() {</p>
<p>// LED_BUILTIN 핀을 출력 모드로 설정 pinMode(LED_BUILTIN, OUTPUT);</p>
<p>}</p>
<p>void loop() {</p>
<p>// LED_BUILTIN 핀을 HIGH로 설정하여 LED 켜기 digitalWrite(LED_BUILTIN, HIGH);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>// LED_BUILTIN 핀을 LOW로 설정하여 LED 끄기 digitalWrite(LED_BUILTIN, LOW);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>}</p>
<p>[ 2 ]</p>
<p>이 코드는 AVR 마이크로컨트롤러에서 실행되는 임베디드 C 코드로, 특정 레지스터인 Port B의 5번 핀(PB5)를 제어하여 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드에서는 비트 연산자를 활용하여 핀을 토글(반전)하는 방식을 사용하고 있다.</p>
<p>int main() {</p>
<pre><code>// DDRB의 5번 비트를 1로 설정하여 Port B의 5번 핀(PB5)을 출력 모드로 설정
DDRB |= (1 &lt;&lt; PB5);

// 무한 루프 시작
while (1) {

    // PB5 핀의 상태를 반전시킴 (HIGH -&gt; LOW 또는 LOW -&gt; HIGH)
    PORTB ^= (1 &lt;&lt; PB5);
    
    // 500ms(0.5초) 동안 대기
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>[ 3 ] 이 코드는 위와 동일한 AVR C 코드이며, 마찬가지로 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드는 레지스터의 전체 Port B 값을 설정하여, 핀을 제어하는 방식을 사용한다. 즉, 전체 값을 명시적으로 설정하는 방식으로 동작한다.</p>
<p>int main() { // Port B의 데이터 방향 레지스터를 설정하여 5번 핀을 출력 모드로 설정한다. // 0x20은 2진수로 00100000으로, 5번 핀을 출력으로 설정한다.</p>
<pre><code>DDRB = 0x20;

// 무한 루프 시작
while (1) {
    
    // Port B의 모든 핀을 LOW로 설정하여 5번 핀만 LOW로 설정된다.
    PORTB = 0x00;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
    
    // Port B의 5번 핀을 HIGH로 설정하여 LED나 다른 장치를 켠다.
    PORTB = 0x20;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>두 번째 예제</p>
<p>위와 같이 연결한 다음, 추가적인 코드 작업이 필요하다.</p>
<p>이 코드는 [1]번과 같은 아두이노 코드이다. 여러 핀을 제어하여 LED를 번갈아가며 깜박거리게 만드는 기능을 수행한다.</p>
<p>const int pins[] = {1, 2, 3, 4, 5, 6, 7}; // 핀 번호 배열 const int numPins = sizeof(pins) / sizeof(pins[0]); // 배열 크기를 자동으로 계산</p>
<p>void setup() { for (int i = -1; i &lt; numPins; i++) {</p>
<pre><code>// 모든 핀을 출력으로 설정
pinMode(pins[i], OUTPUT); </code></pre>
<p>} }</p>
<p>void loop() {</p>
<p>// 첫 번째 패턴: 짝수 핀은 HIGH, 홀수 핀은 LOW for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], HIGH); // 짝수 핀 ON
} else {

  digitalWrite(pins[i], LOW); // 홀수 핀 OFF
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>// 두 번째 패턴: 짝수 핀은 LOW, 홀수 핀은 HIGH for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], LOW); // 짝수 핀 OFF
} else {
  
  digitalWrite(pins[i], HIGH); // 홀수 핀 ON
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>}</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>DB 개론</title>
  <link>https://shinjihan.github.io/studylog/ch/db_01.html</link>
  <description><![CDATA[ 




<p>DB의 전반적인 개념에 대해 다루고자 한다.</p>
<p>01 DB 응용 분야 데이터베이스(DB)는 현대 사회 전반에서 핵심적인 역할을 수행하고 있으며, 그 응용 분야는 매우 다양하다.</p>
<p>1 . 금융 &amp; 비즈니스 비용 절감과 수익 극대화를 위해 DB가 폭넓게 활용된다.</p>
<p>고객 관계 관리(CRM)와 전사적 자원 관리(ERP)는 기업 운영의 효율성을 높이는 대표적 시스템이며,</p>
<p>판매 시점 관리(POS)를 통해 거래 데이터를 실시간으로 기록·분석할 수 있다.</p>
<p>또한 데이터 웨어하우스와 데이터 마이닝 기술은 방대한 거래 데이터를 체계적으로 저장하고, 의미 있는 정보를 도출하여 경영 의사결정에 활용된다.</p>
<p>2 . 소셜 네트워크 트위터, 페이스북, 인스타그램과 같은 플랫폼은 방대한 사용자 데이터를 기반으로 운영되며, 이를 통해 긴밀한 커뮤니티 형성과 맞춤형 서비스 제공이 가능하다.</p>
<p>특히 빅데이터 분석은 사용자의 행동 패턴을 파악하고 모바일 라이프로그(Life Log)와 같은 새로운 서비스를 가능하게 한다.</p>
<p>3 . 사회 효율적인 시스템 구축의 기반이 되기도 한다. 교통정보 시스템은 실시간 데이터를 바탕으로 최적의 경로를 안내하며, 개인 일정 관리 시스템(PIMS)과 사물인터넷(IoT)은 개인화된 편의성을 제공한다.</p>
<p>나아가 DB는 인공지능(AI)과 결합되어 다양한 사회 문제 해결과 지능형 서비스 구현에 기여하고 있다.</p>
<p>4 . 클라우드 최근 DB는 삶의 가치를 높이는 핵심 인프라로 자리 잡았다.</p>
<p>클라우드 DB와 데이터 분산 처리 기술은 대규모 데이터를 효율적으로 관리할 수 있게 하며, IaaS, PaaS, SaaS와 같은 클라우드 서비스 모델은 기업과 개인 모두에게 유연하고 확장 가능한 데이터 활용 방안을 제공한다.</p>
<p>특히 빅데이터와 차세대 DB 기술의 융합은 향후 클라우드 생태계의 혁신을 가속화할 것으로 전망된다.</p>
<p>02 발전 과정 전쟁은 과학과 기술의 발전을 촉진하는 강력한 동인이었다. 특히 군대 통제와 전술 운영에서 무전기와 같은 통신 기술의 발전은 필수적이었다.</p>
<p>전쟁 중에는 주파수 도청을 방지하기 위한 암호 기술이 급격히 발전했으며, 이를 해독하는 과정에서 수학자들의 역할이 매우 컸다.</p>
<p>암호 해독은 단순히 군사적 정보 확보에 국한되지 않고, 이후 컴퓨터 과학의 토대를 마련하는 계기가 되었다.</p>
<p>대표적으로 제2차 세계대전 당시 컴퓨터는 암호 해독에 적극 활용되었으며, 전쟁이 끝난 뒤에는 이러한 컴퓨터 기술을 민간 산업에 어떻게 활용할지가 중요한 과제로 떠올랐다.</p>
<p>전후 사회에서는 컴퓨터의 활용 범위가 군사 목적에서 문서와 텍스트 처리로 확장되었다. 행정과 기업 환경에서 대량의 문서를 효율적으로 관리해야 했으므로 저장 장치 개발이 필수적이었다.</p>
<p>이에 따라 자기테이프, 자기디스크 등 문서용 저장 장치 기술이 집중적으로 발전하였으며, 컴퓨터는 단순한 계산 기계에서 대량의 데이터를 분류하고 처리하는 장치로 변모했다.</p>
<p>이러한 변화는 컴퓨터의 상업적 성공을 견인하였고, 이후 정보화 사회로 나아가는 기반을 마련하였다.</p>
<p>03 데이터 데이터는 가공되지 않은 원시적 사실(fact)로, 수치·기호·문자 등 다양한 형태로 존재한다.</p>
<p>이러한 데이터는 단순히 수집된 상태에서는 의미가 제한적이지만, 가공과 처리 과정을 거치면 새로운 의미를 지닌 정보로 변환된다.</p>
<p>이러한 과정을 개념적으로 표현하면 다음과 같이 나타낼 수 있다.</p>
<p>이는 “데이터(D)에 처리(P)를 적용하면 정보(I)가 된다”는 의미의 비유적 수식이다. 여기서 처리(Process)는 단순 계산이나 집계뿐 아니라 분류, 요약, 분석, 의미 부여 등 다양한 가공 과정을 포괄한다.</p>
<p>따라서 정보는 데이터 그 자체가 아니라, 데이터를 특정 목적에 맞게 해석 및 활용할 수 있도록 구조화한 결과물이라고 할 수 있다.</p>
<p>컴퓨터 시스템은 이 과정에서 핵심적인 도구로 작동하며, 데이터를 효과적으로 수집·저장·처리하여 실질적인 결론을 도출한다.</p>
<p>궁극적으로 데이터의 활용도를 높이는 것은 단순한 저장이 아니라, 조직과 개인의 의사결정에 유용한 정보로 가공하는 과정이다.</p>
<p>04 정보 시스템 Information System</p>
<p>이러한 정보를 생성 및 분배하는 구조적 체계를 의미한다. 조직 내외부의 데이터를 수집하고 이를 정보로 변환하며, 사용자에게 필요한 시점에 제공하는 역할을 한다.</p>
<p>이 과정에서 다음의 시스템들이 중요한 하위 단위로 작동한다.</p>
<p>1 . 응용 시스템 Application System</p>
<p>특정 업무 영역에 초점을 맞춘 정보 처리 시스템으로, 예를 들어 학사 관리, 급여 관리, 회계 관리와 같이 개별적인 운영 업무를 지원한다.</p>
<p>이러한 응용 시스템들이 통합적으로 구성되고 운영되는 상위 개념이 바로 정보 시스템이다.</p>
<p>즉, 응용 시스템은 개별적이고 구체적인 업무 단위를 담당하고, 정보 시스템은 이를 아우르는 거시적 틀로서 조직 전체의 정보 흐름을 관리하는 역할을 수행한다.</p>
<p>데이터의 규모가 커짐에 따라, 이를 효율적으로 관리 및 활용하야 한다.</p>
<p>2 . 경영정보시스템 MIS: Management Information System</p>
<p>조직 내외부의 데이터를 체계적으로 수집·처리하여, 경영 관리자가 기획(Planning), 운영(Operation), 통제(Control) 활동을 수행할 수 있도록 정보를 제공하는 시스템이었다.</p>
<p>일정 부분 관리자 의사결정을 지원했으나, 제공되는 정보가 주로 정형화된 보고서 형태로 제한되어 있어 전략적이고 비정형적인 의사결정을 충분히 뒷받침하기에는 한계가 있었다.</p>
<p>3 . 의사결정 지원 시스템 DSS: Decision Support System</p>
<p>DB와 모델베이스(Model Base)를 결합하여 관리자가 직접 데이터를 탐색하고 분석할 수 있도록 지원하였다. 이 시스템은 특히 비정형적이고 전략적인 의사결정을 수행하는 관리자에게 유용했으며, 단순 보고서 제공을 넘어 시뮬레이션, 최적화 기법, 통계 분석을 통해 다양한 대안의 평가를 가능하게 했다. 따라서 DSS는 넓은 의미에서 정보시스템의 발전적 형태로 간주되며, 이후 ERP, 데이터 웨어하우스(DW), 데이터 마이닝(DM), 지식 관리 시스템(KMS) 등과 긴밀히 연결되는 기반이 되었다.</p>
<p>전사적 자원 계획 관리 ERP: Enterprise Resources Planning</p>
<p>이후 기업 활동이 복잡해짐에 따라 전사적 자원 관리(ERP)가 도입되었고, 이를 통해 조직 내 다양한 기능과 부서를 통합 관리할 수 있게 되었다.</p>
<p>데이터 웨어하우스 Data Warehouse</p>
<p>기업 내외부에서 발생하는 방대한 데이터를 체계적으로 저장·관리하기 위한 일종의 정보 저장소(information repository)로 발전하였다.</p>
<p>이는 단순한 DB와는 달리, 분석과 의사결정을 목적으로 데이터를 구조화하고 보관하는 특징을 가진다.</p>
<p>데이터 마이닝 Data Mining</p>
<p>저장된 데이터로부터 의미 있는 규칙이나 패턴을 발견하는 지식 발견(knowledge discovery)의 핵심 기술로 자리 잡았다. 이후 빅데이터 분석의 기초가 되었으며, 예측 분석과 인공지능 기술로 확장되었다.</p>
<p>지식 관리 시스템 KMS: Knowledge Management System</p>
<p>조직 내 축적된 지식을 체계적으로 관리하고 공유함으로써 의사결정의 질을 높이는 데 기여하였다.</p>
<p>더 나아가 의사결정 지원 시스템(DSS: Decision Support System)은 데이터 분석과 시뮬레이션 기능을 통해 경영진의 전략적 선택을 지원하였다.</p>
<p>특히 최근에는 인공지능의 추론 기능이 결합되면서, 데이터의 활용성은 단순한 보고 차원을 넘어 예측과 문제 해결을 지원하는 수준으로 크게 향상되었다.</p>
<p>02 자료 처리 시스템 자료를 정보로 생성해주는 시스템.</p>
<p>1 . 일괄 처리 (Batch Processing)</p>
<p>원시데이터로부터 사전작업 - 데이터 생성 -</p>
<p>데이터를 한꺼번에 모아서 사전에 준비된 상태에서 한 번에 처리하는 방식. 처리 속도는 매우 빠르지만, 실시간 처리가 아닌 사전 준비가 필요하다.</p>
<p>예시: 수능 채점과 같이 데이터를 순차적으로 접근하고 처리한 후 최종 결과를 출력한다.</p>
<p>장점:</p>
<p>대용량 데이터를 처리할 때 효율적이다. 부가적인 장치 필요 없으므로, 비용 절감적이다. 순차처리 기법에 유리하다.</p>
<p>단점:</p>
<p>실시간 처리가 불가능하고, 사전 준비 시간이 소요된다.</p>
<p>2 . 온라인 처리 시스템 (Online Processing)</p>
<p>사용자가 요청하기 전까지 기다림 - 사용자가 요청하기 쉽도록 단말 장치 설치 및 컴퓨터와의 연결 - 통신라인의 온라인 상태를 유지하고 있어야 한다.</p>
<p>서버가 네트워크로 연결되어 실시간으로 데이터를 처리한다. - 리얼 타임 사용자는 즉각적인 고급 서비스를 받을 수 있다. 임의접근처리에 더 유리하다.</p>
<p>예시: 현금 인출 시스템(ATM)처럼 실시간으로 데이터를 처리하고 응답한다.</p>
<p>장점:</p>
<p>실시간 처리로 사용자 경험이 개선된다.</p>
<p>단점:</p>
<p>사용자 서비스 위주.</p>
<p>많은 경우 시스템이 웨이팅 상태에 있으므로 시스템 성능 활용도는 낮다.</p>
<p>유지보수와 통신 제어가 필요하다.</p>
<p>3 . 분산 처리 시스템 (Distributed Processing)</p>
<p>2가지 컴퓨터 중 요청하는 컴퓨터는 클라이언트, 서비스 제공 컴퓨터는 서버가 되어 처리함.</p>
<p>여러 노드나 사이트가 독립적으로 데이터를 처리하며, 각 시스템이 필요할 때 다른 시스템에 요청을 보낸다. 가장 많이 사용되는 시스템.</p>
<p>예시: 분산 데이터베이스 시스템에서, 본인에게 없는 정보가 필요할 때 클라이언트가 되어 다른 서버에 요청하는 방식.</p>
<p>장점</p>
<p>벡업 기능, 분담 기능, 복구 및 정상화 기능을 통해 안정성이 향상된다.</p>
<p>단점</p>
<p>통신 연결 및 데이터 일관성을 유지하는 데 추가적인 제어가 필요한다.</p>
<p>03 용어의 기원</p>
<p>1 . 시대별 1960년: 데이터 관리 개념이 처음으로 소개됨. 1965년: 2차 회의에서, 시스템화 및 개념 정립이 이루어짐.</p>
<p>2 . 정의 한 조직(enterprise)의 여러 응용 시스템들이 공용(shared)하기 위해 통합 (integrated)하여 저장(stored)한 운영 데이터(operational data)의 집합 불편함 없이 모든 부서가 편리하고 쉽게 공유할 수 있어야 한다.</p>
<p>통합 데이터를 묶어 집합으로 관리하며, 중복을 최소화하여 관리함.</p>
<p>중복 제거 필요 없는 중복은 제거할 수 있으며, 서버가 장애를 일으켰을 때 백업본을 통해 복구 가능.</p>
<p>의도적 중복 최소화된, 제어된 중복, 통제된 중복은 시스템 성능을 향상시킬 수 있다.</p>
<p>예: 캐시</p>
<p>저장 및 공용 데이터를 통합적으로 저장하고, 여러 사용자나 시스템에서 공용으로 사용할 수 있음.</p>
<p>운영 데이터가 실시간으로 운영되는 것을 강조.</p>
<p>3 . 특징 실시간 응답 및 요청</p>
<p>데이터를 실시간으로 처리하고 응답할 수 있는 능력.</p>
<p>동적 데이터 특성</p>
<p>데이터를 동적으로 관리하고 변경할 수 있음.</p>
<p>동시 공유</p>
<p>여러 사용자가 동시에 데이터를 접근하고 사용할 수 있음.</p>
<p>멀티 트랜잭션</p>
<p>다중 트랜잭션을 처리하여 여러 작업을 동시에 처리 가능.</p>
<p>내용에 의한 참조</p>
<p>데이터 내부에 있는 또 다른 내용을 참조하여 효율적인 데이터 접근이 가능.</p>
<p>03 개념적 구성 요소</p>
<p>1 . 논리적 구성 요소 개체 (Entity) 와 관계 (Relationship) 로 이루어 졌다.</p>
<p>개체 DB에 기록되는, 반드시 저장해야 하는 중요한 데이터. 정보의 단위. 예, 학생 정보</p>
<p>그러나 이것만으로는 가치가 떨어진다 그러므로 이 가치를 높이히 위해 다른 정보를 주입.</p>
<p>관계 개체 간의 연관성. 이를 통해 데이터를 고급 검색하거나 다양한 방식으로 활용할 수 있다.</p>
<p>2 . 개체의 형식</p>
<p>속성 (Attribute) 개체의 세부 항목들을 의미합니다. 예를 들어, 학생 개체의 속성은 이름, 학번, 생년월일 등이 될 수 있습니다.</p>
<p>개체 타입(Entity Type) 개체의 형태나 틀을 정의합니다. 예를 들어, 학생 개체 타입은 ’학생’이라는 틀에 맞는 모든 정보를 담습니다.</p>
<p>개체 집합(Entity Set) 동일한 개체 타입의 여러 인스턴스를 모은 집합. 개별 개체 타입의 집합.</p>
<p>레코드(엔티티 인스턴스) 개체 타입에 맞춰 실제 값들로 표현된 개체를 레코드라고 합니다. 예를 들어, 특정 학생의 정보는 하나의 레코드로 저장됩니다.</p>
<p>레코드 타입, 레코드 어커런스.</p>
<p>식별자(Identifier) 각 개체는 유일하게 식별되며, 이를 통해 다른 개체를 결정하거나 참조할 수 있다.</p>
<p>ER 다이어그램 이름, 학과는 중복되는 경우가 많으므로, 학번을 사용하여 유일하게 식별. 데이터를 더 가치있게 할 수 있으며, 이러한 구현은 어렵지 않다.</p>
<ol type="1">
<li>물리적 구성 요소</li>
</ol>
<p>컴퓨터의 물리적 관점에서 모든 데이터는 동일한 방식으로 처리된다. 이는 하드웨어나 물리적인 데이터 저장 구조와 관련이 있다.</p>
<ol type="1">
<li>구조: 논리적 구조: 우리가 생각하는 데이터의 배치나 정렬 순서에 따라 데이터를 논리적으로 배치하는 것을 의미합니다.</li>
</ol>
<p>예, 논리적으로 데이터를 오름차순으로 정렬하거나 특정 기준에 맞춰 배열할 수 있다.</p>
<p>물리적 구조: 실제 컴퓨터가 데이터를 저장하는 방식입니다.</p>
<p>이는 논리적 배치와 다를 수 있으며, 컴퓨터 시스템이 데이터를 어떻게 물리적으로 저장하고 처리할지에 대한 관점입니다.</p>
<p>논리적 구조와 물리적 구조는 완전히 다르며, 데이터를 어떻게 논리적으로 설계하느냐와 컴퓨터가 실제로 이를 저장하고 접근하는 방식은 다르게 구현됩니다.</p>
<p>성능향상을 위해서 필요하며, 그외에는 운영체제에 맡기면 된다.</p>
<ol start="2" type="1">
<li><p>링크드 리스트 데이터를 연결된 리스트(Linked List) 형태로 배치하여 각 요소가 다음 요소를 가리키는 방식으로 이어집니다. 이는 논리적으로 순차적인 연결을 제공하지만, 물리적으로는 메모리 내에서 연속적으로 저장되지 않을 수 있습니다.</p></li>
<li><p>클러스터링 (Clustering): 데이터를 의도적으로 가까운 위치에 배치하여, 데이터를 빠르게 접근할 수 있도록 하는 기술입니다.</p></li>
</ol>
<p>이를 통해 액세스 속도가 빨라집니다.</p>
<p>특정 특별한 케이스에서 사용되며, 데이터 검색과 접근을 최적화하기 위해 데이터를 물리적으로도 배치하는 경우가 많습니다.</p>
<p>교제: Fundamentals of Database Systems (7th edition).pdf 데이터베이스실무의 선수과목: 화일처리론</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/db_01.html</guid>
  <pubDate>Wed, 04 Sep 2024 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
