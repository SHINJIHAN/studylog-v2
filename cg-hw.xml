<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>StudyLog</title>
<link>https://shinjihan.github.io/studylog/cg-hw.html</link>
<atom:link href="https://shinjihan.github.io/studylog/cg-hw.xml" rel="self" type="application/rss+xml"/>
<description>통계와 AI를 기록하는 개인 블로그</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Thu, 06 Mar 2025 15:00:00 GMT</lastBuildDate>
<item>
  <title>운영체제(OS)</title>
  <link>https://shinjihan.github.io/studylog/ch/os_01.html</link>
  <description><![CDATA[ 




<p>운영체제(OS)의 전반적인 개념에 대해 다루고자 한다.</p>
<section id="서론" class="level1">
<h1>01 서론</h1>
<p>초기에는 운영체제가 단순한 하드웨어 제어에 집중했으나, 이후에는 소프트웨어 기능이 추가되면서 점점 발전해왔다.</p>
<p>Windows 운영체제의 소스 코드는 공개되어 있지 않으며, 사용자는 단순히 라이선스를 구매하여 사용할 수 있다.</p>
<p>반면, 최근에는 오픈 소스 코드가 활성화되면서 리눅스(Linux) 와 같은 오픈 소스 운영체제가 등장했다.</p>
<p>즉, 운영체제의 내부 동작을 깊이 이해하고 싶다면, 리눅스를 활용해보는 것이 좋은 방법이다.</p>
<p>이 챕터에서 배울 수 있는 것.</p>
<p>① 컴퓨터 시스템의 일반적 구성과 인터럽트의 역할에 대한 기본 지식을 기술한다.</p>
<p>② 현대 다중프로세서 컴퓨터 시스템에서의 구성요소에 대해서 기술한다.</p>
<p>③ 사용자 모드로부터 커널 모드로의 변경에 대해서 기술한다.</p>
<p>④ OS가 다양한 컴퓨팅 환경에서 어떻게 사용되는지 논의한다.</p>
<p>⑤ Free와 Open Source OS 예제를 제공한다.</p>
<p>02 운영체제 (Operating System)</p>
<p>컴퓨터의 하드웨어를 관리하는 프로그램.</p>
<p>응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행하는 프로그램이다.</p>
<p>Operating System Market Share Worldwide | Statcounter Global Stats</p>
<p>This graph shows the market share of operating systems worldwide based on over 5 billion monthly page views.</p>
<p>gs.statcounter.com</p>
<p>https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js</p>
<p>var chart = echarts.init(document.getElementById(‘chart’)); var option = { title: { text: ‘전 세계 운영체제 시장 점유율’, subtext: ‘2025년 2월’, left: ‘center’ }, tooltip: { trigger: ‘item’ }, legend: [ { orient: ‘horizontal’, left: ‘center’, top: ‘93%’, itemWidth: 20, itemHeight: 10, data: [‘Android’, ‘Windows’, ‘iOS’] }, { orient: ‘horizontal’, left: ‘center’, bottom: ‘0%’, itemWidth: 20, itemHeight: 10, data: [‘macOS’, ‘Unknown’, ‘Linux’, ‘Others’] }], series: [ { name: ‘전체 비율’, type: ‘pie’, radius: ‘70%’, center: [‘50%’, ‘53%’], data: [ { value: 45.49, name: ‘Android’, label: { show: true, position: ‘inner’, color: ‘#fff’, fontSize: 25, fontWeight: ‘bold’, textBorderColor: ‘#000’, textBorderWidth: 2, formatter: ‘{b}%’ } }, { value: 25.35, name: ‘Windows’, label: { show: true, position: ‘inner’, color: ‘#fff’, fontSize: 20, fontWeight: ‘bold’, textBorderColor: ‘#000’, textBorderWidth: 2, formatter: ‘{b}%’ } }, { value: 18.26, name: ‘iOS’, label: { show: true, position: ‘inner’, color: ‘#fff’, fontSize: 20, fontWeight: ‘bold’, textBorderColor: ‘#000’, textBorderWidth: 2, formatter: ‘{b}%’ } }, { value: 5.67, name: ‘macOS’, label: { show: true, position: ‘outside’, formatter: ‘{b}: {d}%’ } }, { value: 2.97, name: ‘Unknown’, label: { show: true, position: ‘outside’, formatter: ‘{b}: {d}%’ } }, { value: 1.38, name: ‘Linux’, label: { show: true, position: ‘outside’, formatter: ‘{b}: {d}%’ }, itemStyle: { color: ‘#DDA0DD’ } }, { value: 0.88, name: ‘Others’, label: { show: true, position: ‘outside’, formatter: ‘{b}: {d}%’ }, itemStyle: { color: ‘#808080’ } }], emphasis: { itemStyle: { shadowOffsetX: 0, shadowColor: ‘rgba(0, 0, 0, 0.5)’ } } }] }; chart.setOption(option);</p>
<p>OS의 목적 컴퓨터 시스템을 효율적으로 운영하고 사용자가 보다 편리하게 작업할 수 있도록 돕는 중요한 소프트웨어이다.</p>
<p>1 . 사용자 프로그램 실행 지원 사용자가 원하는 프로그램을 실행할 수 있도록 지원하며, 이를 통해 다양한 소프트웨어를 활용할 수 있다.</p>
<p>2 . 사용자 문제 해결 지원 파일 관리, 프로세스 제어, 네트워크 연결 등 여러 기능을 제공하여 사용자가 보다 쉽게 문제를 해결할 수 있도록 한다.</p>
<p>3 . 컴퓨터 시스템 접근성 향상 하드웨어와 소프트웨어 간의 인터페이스 역할을 하며, 사용자가 명령어나 그래픽 인터페이스(GUI)를 통해 쉽게 시스템을 제어할 수 있도록 한다.</p>
<p>4 . 하드웨어 자원 효율적 관리 CPU, 메모리, 저장 장치, 입출력 장치 등의 하드웨어 자원을 효율적으로 관리하여 여러 프로그램이 원활하게 실행될 수 있도록 한다.</p>
<p>03 처리 방식의 분류</p>
<p>1 . 아날로그 컴퓨터 연속적인 데이터를 처리하는 방식.</p>
<p>물리적인 값(온도, 속도, 압력 등)을 전기적인 신호로 변환하여 처리한다. 연속적인 데이터의 변화를 실시간으로 계산하거나 제어하는 데 유용하다.</p>
<p>연속적인 데이터를 기반으로 처리하는 특성 때문에 실시간 제어 시스템이나 복잡한 물리적 시스템 모델링에 사용된다.</p>
<p>전자 회로 시뮬레이션, 항공기 비행 제어 시스템, 온도 조절 시스템 등이 있다.</p>
<p>2 . 디지털 컴퓨터 이산적인 데이터를 처리하는 방식.</p>
<p>데이터를 0과 1의 이진수로 변환하여 계산한다.</p>
<p>대부분의 현대 컴퓨터는 이 방식을 사용하며, 고속 데이터 처리, 복잡한 계산, 소프트웨어 기반 작업을 처리할 수 있다. 특히 정보 처리 및 저장, 소프트웨어 개발, 대규모 데이터 분석 등 다양한 용도로 사용된다.</p>
<p>일반적인 개인용 컴퓨터, 서버 컴퓨터, 슈퍼컴퓨터 등이 있다.</p>
<p>04 OS의 분류</p>
<p>1 . 대형 및 중형 컴퓨터 OS (Mainframe / Mid-range Computer, 미니컴퓨터)</p>
<p>하드웨어 자원의 효율적인 활용에 중점을 둔 OS.</p>
<p>금융, 공공기관, 연구소 등에서 대량의 데이터를 처리하는 데 사용되며, 다수의 사용자가 동시에 접속하여 작업할 수 있도록 관리한다.</p>
<p>하드웨어의 성능을 최대한 끌어올리는 것이 주된 목표이다. 높은 안정성과 신뢰성을 제공하며, 대량의 데이터 처리 및 다중 사용자 지원한다.</p>
<p>① IBM 기반 OS IBM z/OS; 메인프레임(기업용), → 금융, 은행, 대기업 서버에서 사용된다.</p>
<p>IBM Blue Gene OS; 슈퍼컴퓨터(연산용). → 과학 연구, AI, 기후 분석, 유전체 연구에 사용된다.</p>
<p>② Unix 계열 AIX (Advanced Interactive eXecutive) ; IBM POWER 아키텍처 기반 서버 → 고성능 컴퓨팅, 비즈니스 크리티컬 시스템에 사용된다.</p>
<p>HP-UX (Hewlett Packard Unix) ; HPE PA-RISC, Itanium 아키텍처 서버 → 고성능 서버, ERP 시스템, 보안, 가상화에 사용된다. Solaris ; SPARC, x86 아키텍처 서버 → Oracle 데이터베이스, 네트워크 및 데이터 관리에 사용된다.</p>
<p>③ Linux 기반 OS Cray Linux Environment (CLE) ; 슈퍼컴퓨터, 고성능 컴퓨팅(HPC) 환경 → 과학 연구, 대규모 데이터 분석, 고성능 컴퓨팅에 사용된다.</p>
<p>Red Hat Enterprise Linux (RHEL) ; 서버, 클라우드 환경, 데이터 센터 → 빅데이터 분석, 기업 애플리케이션에 사용된다.</p>
<p>SUSE Linux Enterprise Server (SLES) ; 서버, 클라우드 환, 가상화 환경, SAP 환경 → 고가용성 시스템, 컨테이너 및 오케스트레이션에 사용된다.</p>
<p>2 . 개인용 컴퓨터 OS 개인 사용자를 위한 OS.</p>
<p>업무용 소프트웨어, 게임, 멀티미디어 등 다양한 응용 프로그램을 지원하는 것이 특징이다.</p>
<p>사용자의 편의성을 중점적으로 고려하여 GUI 기반의 인터페이스가 주를 이룬다.</p>
<p>응용 프로그램 설치 및 실행이 용이하고, 하드웨어 및 주변기기와의 높은 호환성을 가진다.</p>
<p>① Windows → 워크스테이션, 데스크톱 PC, 노트북.</p>
<p>(Dell XPS, HP Pavilion, ASUS ROG)</p>
<p>② macOS → 애플의 Mac 시리즈.</p>
<p>(MacBook Air, MacBook Pro, iMac)</p>
<p>③ Linux (Ubuntu, Fedora, Debian)</p>
<p>→ 개발자 및 연구 목적의 개인용 컴퓨터 (커스텀 빌드 PC).</p>
<p>3 . 휴대용 개인용 컴퓨터 OS 이동성을 강조한 OS.</p>
<p>사용자가 물리적인 키보드 없이 터치스크린과 음성 인식 기능 등을 통해 쉽게 조작할 수 있도록 설계되었다.</p>
<p>스마트폰, 태블릿, 일부 노트북(2-in-1)에서 사용되며, 모바일 환경에서 최적화된 UI와 앱 구동 환경을 제공한다.</p>
<p>또한, 가벼운 무게와 뛰어난 이동성을 가지며, 네트워크 및 클라우드 기능과 연계하여 사용 가능하다.</p>
<p>① Android → 삼성 갤럭시 시리즈, Google Pixel, 샤오미 스마트폰 및 태블릿.</p>
<p>② iOS / iPadOS → 아이폰, 아이패드 시리즈.</p>
<p>③ Chrome OS → 크롬북.</p>
<p>Google Pixelbook, Samsung Chromebook.</p>
<p>운영체제는 각 환경에 맞춰 최적화되어 있으며, 목적과 사용 방식에 따라 다양한 기능을 제공한다.</p>
<p>05 컴퓨터 시스템의 구성 (Computer System)</p>
<p>1 . 시스템 (System)</p>
<p>상호 연결된 요소들이 유기적으로 작용하여 특정 목표를 수행하는 구조.</p>
<p>물리적, 생물학적, 사회적, 기술적 분야 등 다양한 영역에서 적용된다.</p>
<p>여러 개의 개별 요소들이 모여 형성되며, 이들은 서로 유기적으로 상호작용하여 각자의 기능을 수행한다.</p>
<p>주어진 목적을 달성하기 위해 목표 지향적으로 운영되며, 요소들은 효율적으로 작동할 수 있도록 질서 있게 조직된다.</p>
<p>또한, 시스템은 외부 환경과 상호작용하고 정보를 주고받으며, 필요에 따라 환경에 적응할 수 있는 능력을 가진다.</p>
<p>예를 들어, 컴퓨터 시스템, 기업 조직 시스템, 생태계 시스템 등이 있다.</p>
<p>2 . 하드웨어 (Hardware)</p>
<p>컴퓨터 시스템의 기본 계산 자원을 제공하며, CPU, 메모리, I/O 장치 등으로 구성된다.</p>
<p>CPU는 데이터 처리 및 계산을 수행하는 역할을 하며, 메모리는 데이터 저장 및 처리 속도를 지원한다.</p>
<p>I/O 장치는 사용자와 시스템 간의 상호작용을 가능하게 하여, 외부 장치와 데이터를 주고받을 수 있도록 한다.</p>
<p>이러한 요소들이 유기적으로 결합되어 시스템의 기본적인 기능을 수행하는 역할을 한다.</p>
<p>3 . 소프트웨어 (Software)</p>
<p>① 운영 체제 Operating System, 시스템 프로그램 또는 시스템 소프트웨어.</p>
<p>다수의 사용자가 다양한 응용 프로그램을 사용할 수 있도록 하드웨어 자원의 사용을 제어 및 조정한다.</p>
<p>이를 통해 하드웨어와 소프트웨어 간의 상호작용을 관리하고, 시스템 자원의 효율적인 분배를 담당한다.</p>
<p>② 응용 프로그램 (Application Programs)</p>
<p>사용자의 특정 문제를 해결하기 위해 설계된 프로그램으로, 자원의 사용 방식을 정의한다.</p>
<p>예를 들어, 워드 프로세서, 컴파일러, 웹 브라우저, 데이터베이스 시스템, 비디오 게임 등이 있다.</p>
<p>이들은 각각 사용자의 요구를 만족시키기 위한 다양한 기능을 제공한다.</p>
<p>4 . 사용자 (Users)</p>
<p>사람, 기계, 다른 컴퓨터 등을 포함하며, 소프트웨어와 하드웨어를 직접 또는 간접적으로 활용하는 주체를 말한다.</p>
<p>SCRIPT https://cdn.jsdelivr.net/npm/echarts@5.3.8/dist/echarts.min.js</p>
<p>SCRIPT</p>
<pre><code>var chartDom = document.getElementById('main');
var myChart = echarts.init(chartDom);
var option = {
  title: {
    text: '컴퓨터 시스템 구성 요소에 대한 개략적 구성도',
    left: 'center'  // 제목을 중앙에 배치
  }
};
myChart.setOption(option);</code></pre>
<p>SCRIPT https://fastly.jsdelivr.net/npm/echarts@5/dist/echarts.min.js SCRIPT</p>
<pre><code>var dom = document.getElementById('container');
var myChart = echarts.init(dom, null, {
  renderer: 'canvas',
  useDirtyRect: false
});
var app = {};

var option;

const data = {
  name: '1. 사용자\nUsers',
  children: [
    {
      name: '2. 응용 프로그램\nApplication Programs',
      children: [
        {
          name: '3. 운영체제\nOperating\nSystem',
          children: [
            { name: '4. 하드웨어\nHardware', children: [
                { name: 'CPU' },
                { name: 'RAM' },
                { name: 'I/O' }
              ]
            },
            { name: 'Android'},
            { name: 'Windows'},
            { name: 'IOS'},
          ]
        },
        {name: 'Microsoft\nOffice'},
        {name: 'Google\nChrome'}
      ]
    },
  ]
};

option = {
  series: [
    {
      type: 'tree',
      data: [data],
      top: '20%',
      left: 0,
      bottom: '20%',
      right: 0,
      symbolSize: 0,
      edgeShape: 'polyline',
      center: ['60%', '40%'],
      edgeForkPosition: '80%',
      initialTreeDepth: 50,
      lineStyle: {
        width: 3,
      },
      label: {
        backgroundColor: '#fff',
        padding: [5, 0],
        position: 'inside',
        verticalAlign: '',
        align: 'center',
        borderRadius: 5,
        borderColor: '#ccc',
        borderWidth: 2,
        formatter: function (params) {
          return `{label|${params.data.name}}`;
        },
        rich: {
          label: {
            lineHeight: 20,
            padding: [5, 5],
            align: 'center',
            verticalAlign: 'middle',
          }
        }
      },
      leaves: {
        label: {
          position: 'inside',
          verticalAlign: '',
          align: 'center',
          backgroundColor: '#f0f0f0',
          padding: [5, 0],
          borderRadius: 5,
        }
      },
      emphasis: {
        focus: 'descendant'
      },
      expandAndCollapse: true,
      animationDuration: 550,
      animationDurationUpdate: 750,
      orient: 'vertical',  // 트리 방향을 세로로 설정
    }
  ]
};

if (option &amp;&amp; typeof option === 'object') {
  myChart.setOption(option);
}

window.addEventListener('resize', myChart.resize);</code></pre>
<p>06 실행 과정</p>
<p>1 . 프로그램 실행 요청 사용자가 바탕화면이나 시작 메뉴에서 응용 프로그램을 클릭한다. 운영 체제는 해당 프로그램을 실행해야 한다는 요청을 받는다.</p>
<p>2 . 프로그램을 찾기 프로그램 실행 파일(.exe)은 하드디스크(SSD 또는 HDD)에 저장되어 있다. 운영 체제의 파일 시스템이 이를 찾아 메인 메모리(RAM)로 로드한다.</p>
<p>이 과정에서 디스크 스케줄링 알고리즘(예: FCFS, SSTF)이 사용될 수도 있다. 실행 파일뿐만 아니라 필요한 라이브러리(.dll 파일 등)도 함께 메모리로 적재된다.</p>
<p>3 . 명령어 가져오기 및 실행 프로그램이 메모리에 올라오면, CPU가 실행을 시작한다. PC가 첫 번째 명령어의 주소를 가리킨다.</p>
<p>CPU는 명령어 사이클(Fetch-Decode-Execute-Cycle)을 반복하면서 한 줄씩 명령을 가져와 실행한다.</p>
<p>① Fetch CPU가 메인 메모리(RAM)에서 명령어를 가져온다.</p>
<p>② Decode 가져온 명령어를 해석하여 어떤 작업을 해야 하는지 결정한다.</p>
<p>③ Execute 해당 명령을 실행하여 결과를 만든다.</p>
<p>4 . 프로그램 조작 사용자가 키보드로 문서를 작성하면, 운영 체제가 이를 받아서 응용 프로그램으로 전달한다.</p>
<p>작성한 문서를 저장할 때는 운영 체제가 파일 시스템을 통해 하드디스크에 기록한다.</p>
<p>5 . 프로세스 관리 사용자는 특정 응용 프로그램을 사용하면서 인터넷 브라우저, 음악 플레이어 등 다른 프로그램도 실행할 수 있다.</p>
<p>운영 체제는 스케줄러(CPU 스케줄링)를 통해 여러 프로세스를 관리하며, Round Robin, Priority Scheduling 등을 사용하여 CPU 시간을 나누어 사용한다.</p>
<p>6 . 프로그램 종료 사용자가 응용 프로그램을 닫으면, 운영 체제는 프로세스 테이블에서 해당 프로세스를 제거한다.</p>
<p>프로그램이 사용하던 메모리를 해제하고, 저장된 데이터를 하드디스크에 기록한다.</p>
<p>CPU는 다른 작업을 수행할 준비를 한다.</p>
<p>운영 체제가 할 일은 관점(View)에 따라 달라진다.</p>
<p>07 사용자 관점 (User View)</p>
<p>편의성, 사용의 용이성, 좋은 성능을 원한다. ⌎ Convenience, Ease of Use, Good Performance</p>
<p>이 과정에서 자원 활용(Resource Utilization)에 대한 고려는 크지 않다.</p>
<p>최대의 활용 연결된 여러 대의 터미널을 통해 접근할 수 있는 대형 컴퓨터(Mainframe)나 미니 컴퓨터(Minicomputer)의 경우</p>
<p>사용자의 자원 활용을 극대화하기 위해서 설계된다.</p>
<p>이처럼 운영 체제는 범용 컴퓨터에서도 다양한 요구를 반영하여 작동한다.</p>
<p>① 워크스테이션 사용자 (Workstations)</p>
<p>전용 자원을 자유롭게 사용할 수 있지만, 서버의 공유 자원도 빈번하게 활용할 수 있도록 설계된다.</p>
<p>즉, 사용 용이성과 자원 활용이 균형을 이루는 구조를 갖는다.</p>
<p>② 휴대용 컴퓨터 자원이 제한적이므로 사용성과 배터리 효율을 최적화하는 방식으로 설계된다.</p>
<p>③ 가전제품 및 임베디드 시스템 가전제품이나 자동차 내의 임베디드 컴퓨터처럼 일부 시스템에서는 사용자 관점이 거의 없거나, 매우 제한적으로 적용된다.</p>
<p>08 시스템 관점 (System View)</p>
<p>OS는 하드웨어와 가장 밀접하게 연관된 프로그램.</p>
<p>1 . 자원 할당자 (Resource Allocator)</p>
<p>OS는 모든 자원의 관리자로서 동작하며, 필요한 자원을 적절히 할당하는 역할을 수행한다.</p>
<p>또한, 자원을 둘러싼 상충하는 요청들을 공정하고 효율적으로 조정하여 시스템을 원활하게 운영하도록 결정한다.</p>
<p>운영 체제에 대한 또 다른 관점으로는, 다양한 I/O(입·출력) 장치와 사용자 프로그램을 효과적으로 제어하는 역할이 강조될 수 있다.</p>
<p>2 . 제어 프로그램 (Control Program)</p>
<p>운영 체제는 컴퓨터의 오류 및 부적절한 사용을 방지하기 위해 사용자 프로그램의 실행을 관리한다.</p>
<p>특히, 입·출력 장치의 작동 및 제어와 밀접한 관련이 있다.</p>
<p>OS의 개념과 진화</p>
<p>OS는 한마디로 정의하기 어렵다. 다양한 역할을 포괄하며, 수많은 디자인과 사용 형태가 존재한다.</p>
<p>오늘날 운영 체제는 선박, 우주선, 게임기, TV, 산업 제어 시스템뿐만 아니라 토스터기까지 다양한 기기에 적용되고 있다.</p>
<p>이는 과거 군사용으로 사용되던 고정형 컴퓨터가 점차 범용화되었으며, 자원 관리와 프로그램 제어의 필요성이 증가했기 때문이다.</p>
<p>전통적으로, OS 설치 CD에 포함된 것이 운영 체제이고, 그 외는 응용 프로그램이라는 단순한 관점이 있었다.</p>
<p>그러나, 사용자가 OS를 주문했을 때 공급업체가 제공하는 모든 것이 OS로 간주되기도 하며,</p>
<p>포함된 기능은 시스템에 따라 크게 다르고, IT 환경의 변화에 따라 OS에 대한 개념도 진화하고 있다.</p>
<p>특히 Google, VMware, Microsoft가 새로운 OS 개념을 이끌고 있다.</p>
<p>예를 들어, 검색 엔진과 함께 웹 기반 애플리케이션, 캘린더, Gmail, Google 드라이브 등의 서비스가 OS의 역할을 확장하는 방향으로 변화하고 있다.</p>
<p>1 . Google OS를 단순히 PC를 실행하는 소프트웨어가 아닌, 사용자가 PC를 켠 후 Google Apps, 검색, 웨이브 등 웹 기반 애플리케이션을 이용하는 환경으로 바라본다.</p>
<p>이를 반영한 대표적인 예가 데스크톱용 웹 OS인 Chrome OS이다. 즉, 과거에는 존재하지 않았던 웹 중심의 운영 체제 개념을 제시한 것이다.</p>
<p>2 . VMware 클라우드 데이터 센터에서 애플리케이션과 인프라를 연결하는 역할을 클라우드 OS로 정의한다.</p>
<p>대표적인 예로 vSphere 7이 있으며, 이는 가상화 환경에서 자원을 효율적으로 관리하고 배포하는 운영 체제 개념을 반영한 것이다.</p>
<p>3 . Microsoft 현재 가상화 시장에서는 VMware에, 웹 기반 애플리케이션 분야에서는 Google에 밀리고 있다.</p>
<p>이를 감안하여, MS는 데스크톱 지배력과 클라우드 컴퓨팅의 비전을 결합하는 데 주력하고 있다.</p>
<p>이 과정에서 쉐어포인트 워크스페이스와 같은 서비스가 시도되었으나 실패하였고, 그 후 Azure라는 퍼블릭 클라우드 서비스를 제공하고 있다.</p>
<p>현재 클라우드 시장에서 AWS가 32%, Azure가 20%의 점유율을 기록하고 있다.</p>
<p>10 OS 일반적 정의 컴퓨터에서 메인 메모리에 상주하면서 항상 실행되는 시스템 프로그램을 일반적으로 커널(Kernel)이라고 한다.</p>
<p>커널은 OS의 핵심 부분으로, OS의 부분집합에 포함된다. 시스템 자원 관리, 프로세스 관리, 메모리 관리 등을 담당한다.</p>
<p>OS는 커널을 포함하여, 사용자 공간(User Space)에서 실행되는 응용 프로그램과 시스템 라이브러리, 미들웨어 등으로 구성된다.</p>
<p>커널은 운영 체제의 핵심으로, 하드웨어와 직접적으로 상호작용하며 시스템 자원을 관리하고, 사용자 프로그램의 실행을 제어하는 중요한 역할을 한다.</p>
<p>그 외의 다른 모든 프로그램은 응용 프로그램에 해당한다.</p>
<p>모바일 운영 체제인 iOS와 Android는 데이터베이스, 멀티미디어 및 그래픽을 지원하는 미들웨어와 함께 코어 커널을 갖추고 있다.</p>
<p>11 OS의 처리 공유 메모리에 접근을 제공하는 공통 버스를 통해 연결된 여러 개의 장치 제어기와 하나 이상의 CPU로 구성된다.</p>
<p>CPU와 장치 제어기는 메모리 사이클을 얻기 위해 서로 경쟁하며 병행 수행된다.</p>
<p>각 장치 제어기는 특정 장치를 관리한다. 또한, 각 장치 제어기는 자신만의 로컬 버퍼를 가지고 있다.</p>
<p>공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공된다. 메모리 제어기는 메모리 접근을 동기화하여 충돌을 방지하고 효율적인 자원 관리를 한다.</p>
<p>1 . H/W 장치 시스템 버스를 통해 프로그램을 실행 중인 CPU에 신호를 보내 인터럽트(Interrupt)를 발생시킬 수 있다.</p>
<p>예를 들어, 마우스 인터럽트, 키보드 인터럽트 등은 하드웨어 인터럽트에 해당한다.</p>
<p>이러한 인터럽트는 액션을 취한 장치가 신호를 보내며, 이는 OS와 H/W 간의 상호작용의 핵심 부분이다.</p>
<p>장치 제어기는 이러한 통신을 인터럽트를 통해 실행한다. 이를 인터럽트 구동식 컴퓨터라고 부른다.</p>
<p>(Interrupt Driven Computer)</p>
<p>인터럽트는 적절한 인터럽트 서비스 루틴(ISR)이 있는 시작 주소로 제어를 전달한다.</p>
<p>프로세스는 신호를 받으면 CPU는 해당 작업을 처리할 수 없음을 알리고, 운영체제가 대신 처리하도록 한다.</p>
<p>이 과정에서 인터럽트 벡터 테이블을 참조하여 ISR의 주소를 찾고, 이를 통해 해당 인터럽트를 처리한다.</p>
<p>인터럽트가 요청되면, 인터럽트 벡터를 사용하여 인터럽트를 유발한 장치에 맞는 ISR의 주소를 제공하게 된다.</p>
<p>인터럽트 벡터는 여러 인터럽트 서비스 루틴에 대한 주소 배열을 가지며, 각 인터럽트는 고유한 장치 번호로 색인화되어 인터럽트 요청을 처리한다.</p>
<p>2 . 응용 소프트웨어 트랩(Trap) 또는 예외(Exception)는</p>
<p>오류(예: 0으로 나누기, 유효하지 않은 메모리 접근)나 사용자 프로그램의 운영 체제 서비스 요청에 의해 유발되는 소프트웨어 인터럽트이다.</p>
<p>이러한 인터럽트는 신호를 받으면 CPU는 이를 처리할 수 없다는 신호를 보내고, 운영체제가 대신 처리한다.</p>
<p>그 후, 인터럽트 벡터 테이블을 참조하여 적절한 ISR의 주소를 찾아 이를 수행한다.</p>
<p>OS는 인터럽트 구동(Interrupt Driven) 방식으로 동작한다.</p>
<p>CPU가 인터럽트 요청을 받으면, 현재 실행 중인 명령을 완료한 후,</p>
<p>현재 수행 중인 프로그램을 일시 중단한 다음 해당 프로그램의 상태를 안전한 장소에 저장한다.</p>
<p>그 후, 인터럽트 처리 루틴을 실행하여 인터럽트 원인을 찾아내고 (인터럽트 벡터 테이블을 통해), 해당 ISR 또는 인터럽트 핸들러를 실행하여 인터럽트를 처리한다.</p>
<p>3 . 인터럽트 원인 판별 방법 ① 폴링 방식 (Polling)</p>
<p>주기적으로 상태를 체크하는 방법이다.</p>
<p>하지만 이 방식은 시간이 오래 걸리고 비효율적이어서, 보통 16비트 이하의 단순한 컴퓨터 시스템에서만 사용된다.</p>
<p>② 인터럽트 벡터 방식 (Vectored Interrupt)</p>
<p>인터럽트 발생 시, ISR을 수행하여 인터럽트 원인에 대한 처리를 하며, 이를 통해 빠르게 인터럽트에 대응할 수 있다.</p>
<p>만약 여러 작업이 동시에 이루어지면, 각 작업은 CPU의 의존성이 없이 독립적으로 실행되며, 작업이 완료된 후에는 각각의 결과가 처리된다.</p>
<p>[교제] 운영체제 제 10판 [원그래프 출처] Examples - Apache ECharts</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/os_01.html</guid>
  <pubDate>Thu, 06 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>통신 기술의 기초</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_02.html</link>
  <description><![CDATA[ 




<p>통신 기술에 관한 전반적인 개념에 대해 다루고자 한다.</p>
<section id="산술논리연산장치" class="level1">
<h1>01 산술논리연산장치</h1>
<p><code>Arithmetic and Logic Unit, ALU</code></p>
<p>컴퓨터 내부에서 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행하는 하드웨어 부품.</p>
<p>예를 들어, 7을 3으로 나눌 때 몫과 나머지를 각각 구하는 연산은 ALU에서 처리된다.</p>
<p>이때, 몫은 7 / 3 = 2, 나머지는 7 % 3 = 1로 계산된다.</p>
<p>CPU와 MCU 모두 ALU를 가지고 있으며, 산술 연산과 논리 연산을 처리하는 핵심 컴포넌트이다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU는 컴퓨터의 중앙 처리 장치로, 복잡한 계산을 수행하고, 메모리와 입출력 장치와의 데이터 처리를 담당한다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>작은 컴퓨터 시스템을 내장한 마이크로칩으로, 주로 임베디드 시스템에서 사용된다.</p>
<p>MCU는 CPU에 비해 상대적으로 간단하고 저전력, 소형화된 시스템으로, 제한된 리소스 환경에서도 효율적으로 동작한다.</p>
<p>02 레지스터 (Register)</p>
<p>컴퓨터의 CPU 내에서 데이터나 명령어를 저장하고 처리하는 빠른 기억 장치.</p>
<p>CPU는 연산을 수행하거나 메모리와 데이터 교환 시 레지스터를 사용하여 데이터를 중간에 임시로 저장한다.</p>
<p>레지스터는 메모리 역할을 수행하는 일시적인 저장소 역할을 한다.</p>
<p>① CPU (Central Processing Unit)</p>
<p>CPU 내의 레지스터는 매우 빠른 임시 저장소로, 연산에 필요한 데이터나 명령어를 빠르게 저장하고 처리한다.</p>
<p>CPU 자체는 레지스터 외에 큰 저장공간 역할을 하지 않는다.</p>
<p>CPU는 대량의 데이터를 영구적으로 저장하는 역할을 하지 않으며, 주 메모리(RAM)나 저장장치(HDD, SSD 등)처럼 큰 용량의 데이터를 관리하지 않는다.</p>
<p>② MCU (Microcontroller Unit)</p>
<p>MCU는 비교적 작은 시스템으로, 자체적으로 내장 메모리(ROM, RAM)를 가지고 있다.</p>
<p>이 메모리는 프로그램 코드, 변수, 데이터를 저장하는 역할을 하며, CPU처럼 레지스터는 연산에 필요한 데이터를 임시로 저장하는 용도로 사용된다.</p>
<p>MCU는 외부 메모리와 연결하여 더 많은 데이터를 처리할 수 있지만, 레지스터는 여전히 임시 저장소 역할을 한다.</p>
<p>③ 레지스터 초기화 특정 비트를 0으로 설정하려면 AND 연산과 마스크(Mask)를 사용하여 원하는 비트를 0으로 만들 수 있다. 반대로, 특정 비트를 1로 설정하려면, OR 연산과 마스크를 사용한다.</p>
<p>8비트 값이 10101101일 때, 3번째 비트를 0으로 설정하려면 마스크 11110111과 AND 연산을 수행한다.</p>
<p>반대로, 5번째 비트를 1로 설정하려면 마스크 00010000과 OR 연산을 수행한다.</p>
<p>모든 비트를 0으로 설정할 경우, 단순히 레지스터 값을 0으로 초기화하는 것이 일반적이다.</p>
<p>03 RS-232 (Recommended Standard 232)</p>
<p>직렬 통신 프로토콜의 한 종류로, 데이터를 한 비트씩 순차적으로 전송하는 방식이다.</p>
<p>직렬 데이터 전송을 위한 초기 표준. 간단한 구현과 넓은 호환성을 바탕으로 임베디드 시스템과 주변 기기 통신에 오랫동안 사용되어 왔다.</p>
<p>① 통신 방식</p>
<p>TX(전송), RX(수신), GND(접지)와 같은 신호선을 사용하여 데이터를 송수신한다.</p>
<p>기본적으로 비동기식 통신 방식을 채택하고 있으며, 송수신 측이 서로 동기화된 상태에서 데이터를 교환하는 방식이다.</p>
<p>비동기식 통신에서 각 데이터는 스타트 비트, 데이터 비트, 패리티 비트, 스톱 비트로 구분된다.</p>
<p>② 사용 범위 RS-232는 동기식 통신 방식으로도 사용할 수 있다. 이 경우, 클럭 신호를 추가하여 데이터 전송 속도를 동기화한다.</p>
<p>이는 컴퓨터, 서버 간의 통신에 널리 사용되며, 특히 임베디드 시스템에서도 사용된다.</p>
<p>또한, 모뎀, 프린터, 터미널 장치 등과의 연결에도 사용된다.</p>
<p>04 기본 논리 연산 디지털 회로와 프로그래밍에서 사용하는 가장 기본적인 연산으로, 논리 상태(0과 1)를 처리하는 데 사용된다.</p>
<p>아래는 기본 논리 연산의 주요 종류이다.</p>
<p>① AND 두 입력이 모두 참(1)일 때만 결과가 참(1)이 되는 연산.</p>
<p>AND 연산의 진리표</p>
<p>② OR 입력 중 하나라도 참(1)이면 결과가 참(1)이 되는 연산.</p>
<p>OR 연산의 진리표</p>
<p>③ NOT 단일 입력에 대해, 입력이 참이면 결과가 거짓(0), 입력이 거짓이면 결과가 참(1)이 되는 연산.</p>
<p>NOT 연산의 진리표</p>
<p>④ XOR 두 입력이 서로 다를 때만 참(1)이 되는 연산. 즉, 둘 중 하나만 참이어야 참이 된다.</p>
<p>XOR 연산의 진리표</p>
<p>⑤ NAND AND 연산 후에 결과를 부정(NOT)한 연산. AND의 반대 결과를 생성한다.</p>
<p>NAND 연산의 진리표</p>
<p>⑥ NOR OR 연산 후에 결과를 부정(NOT)한 연산. OR의 반대 결과를 생성한다.</p>
<p>NOR 연산의 진리표</p>
<p>이러한 논리 연산은 전자 회로와 디지털 컴퓨터에서 기본 연산으로 사용된다.</p>
<p>간단한 결정이나 조건을 설정하는 데 유용하며, 복잡한 연산도 이러한 기본 연산을 조합하여 처리할 수 있다.</p>
<p>05 통신 기술 Wi-Fi, Bluetooth, 5G 같은 무선 통신 기술에서 데이터 송수신 과정에서 모뎀 역할을 하는 칩셋이나 모듈이 사용되며, 동기/비동기 통신 방식과 대역폭이 전송 속도와 품질에 중요한 영향을 미친다.</p>
<p>서버 기반의 제어 시스템을 조작할 때는 C++과 같은 언어를 활용하여 GUI를 개발하거나 데이터를 효율적으로 처리할 수 있으며,</p>
<p>특히 실시간 데이터 처리와 고성능 연산이 요구되는 환경에서 유용하다.</p>
<p>① 제어 흐름 관리 for 문과 if-else 문을 사용하며, 이를 통해 데이터를 수집하거나 명령을 실행하는 프로세스를 제어하는 코드를 작성한다.</p>
<p>이러한 방식은 시리얼 통신, 네트워크 통신 등 다양한 통신 방식에 맞춰 데이터 패킷을 처리하거나, 사용자 입력을 관리하여 프로그램의 동작을 유연하게 제어하는 데 중요한 역할을 한다.</p>
<p>② C++의 활용 C++는 성능과 메모리 관리를 직접 제어할 수 있는 언어로, 이를 활용하면 실시간 통신 시스템에서 응답성을 크게 향상시킬 수 있다.</p>
<p>특히, 서버 제어 시스템에서 통신 장비와 상호 작용하는 프로그램을 개발할 때, C++의 효율성과 네트워크 라이브러리를 활용하면 안정적이고 빠른 성능을 달성할 수 있다.</p>
<p>③ 디지털 (Digital) 0과 1과 같은 이진 값을 사용하여 정보를 표현한다.</p>
<p>디지털 신호는 일정한 시간 간격으로 구분된 이진 상태를 나타내며, 최소 단위는 비트이다.</p>
<p>이진 상태가 “0”과 “1”로만 표현되므로, 값은 이산적이다.</p>
<p>④ 아날로그 (Analog) 시간에 따라 연속적으로 변화하며, 0과 1 사이의 모든 값을 가질 수 있다.</p>
<p>06 데이터 단위</p>
<p>① 비트 (Bit) 0과 1로 이루어진 가장 작은 데이터 단위. 디지털 정보의 기본 단위로, 두 가지 상태를 표현할 수 있다.</p>
<p>② 니블 (Nibble): 4비트 1니블은 4개의 비트로 구성된다. 보통 1바이트를 2니블로 나누는 데 사용된다.</p>
<p>③ 바이트 (Byte): 8비트 1바이트는 8비트로 이루어지며, 컴퓨터에서 문자나 데이터를 표현하는 기본 단위로 많이 사용된다.</p>
<p>④ 워드 (Word) 프로세서가 한 번에 처리할 수 있는 데이터의 크기로, 시스템 아키텍처에 따라 달라진다.</p>
<p>워드 크기는 아키텍처에 따라 대체로 위와 같이 설정된다.</p>
<p>과거에는 16비트 였던 워드 크기가 현재는 32비트 혹은 64비트로 변화되어 사용된다.</p>
<p>07 진법 컴퓨터와 디지털 시스템에서는 데이터를 다양한 진법으로 표현한다.</p>
<p>각 진법은 사용되는 숫자의 개수와 자리 값을 기반으로 데이터를 표현하며, 특정 진법은 특정 상황에서 유용하다.</p>
<p>① 2진수(Binary)</p>
<p>숫자 2를 기반으로 하는 진법으로, 0과 1의 두 가지 숫자만 사용된다. 디지털 회로와 컴퓨터 내부 연산에서 가장 기본적인 진법이다.</p>
<p>2의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>② 8진수(Octal) 숫자 8을 기반으로 하는 진법으로, 0 ~ 7의 8가지 숫자를 사용한다. 3개의 이진수 그룹을 한 자리의 8진수로 표현할 수 있어, 컴퓨터 시스템에서 간단한 데이터 표현에 사용된다.</p>
<p>8의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>③ 10진수 (Decimal) 우리가 일상생활에서 사용하는 기본 진법.</p>
<p>숫자 10을 기반으로 하는 진법으로, 0 ~ 9의 숫자를 사용한다.</p>
<p>10의 거듭제곱으로 자리값이 결정된다.</p>
<p>​</p>
<p>④ 16진수 (Hexadecimal)</p>
<p>숫자 16을 기반으로 하는 진법으로, 숫자 0 ~ 9와 문자 A ~ F를 사용한다.</p>
<p>문자 A ~ F 는 10 ~ 15의 값을 나타낸다.</p>
<p>4개의 이진수 그룹을 한 자리의 16진수로 표현할 수 있어, 메모리 주소나 색상 표현 등에 자주 사용된다.</p>
<p>16의 거듭제곱으로 자리값이 결정된다.</p>
<p>08 8비트의 정의 8자리의 2진수로 표현되며, 각 자리의 가중치는 다음과 같다:</p>
<p>왼쪽에서 오른쪽으로 자리의 가중치가 점점 작아진다.</p>
<p>① 값의 범위</p>
<p>8비트의 최소값과 최대값</p>
<p>총 가능한 값의 개수는 2⁸ = 256 가지이다. 11111111₂은 각 자리의 가중치를 모두 더하는 방식으로 계산된다.</p>
<p>② 응용 8비트의 범위는 0 ~ 255로, 컴퓨터가 데이터를 저장하거나 표현할 때 자주 사용된다.</p>
<p>색상 표현에서 RGB 값은 각각 0 ~ 255로 표현된다. 문자 저장에 사용되는 ASCII 코드도 보통 8비트를 사용한다.</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_02.html</guid>
  <pubDate>Mon, 07 Oct 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>컴퓨터 그래픽스</title>
  <link>https://shinjihan.github.io/studylog/ch/cg_01.html</link>
  <description><![CDATA[ 




<p>과학, 공학, 의학, 경영 등 다양한 분야에서 활용되는 컴퓨터 그래픽스의 응용 분야에 대해 다루고자 한다.</p>
<p>01 컴 퓨 터 그 래 픽 스 (CG, Computer Graphics)</p>
<p>컴퓨터로 그림을 생성하는 기술.</p>
<p>아래는, 이전부터 활발하게 응용된 분야를 나열한 목록이다.</p>
<p>이 중에서 기술의 상호작용이 두드러지는 가상 현실과 애니메이션 및 게임에서의 응용에 대해 알아보고자 한다.</p>
<p>컴퓨터 그래픽스의 응용분야</p>
<p>메 타 버 스 (Metaverse) 가상현실을 구현한 여러 형태나 콘텐츠들을 통칭한다.</p>
<p>메타버스는 기술적 진보와 인터넷의 발전으로 구현된 디지털 환경이며, 이는 가상세계와 달리, 여러 기술적 요소가 결합된 거대한 디지털 생태계이다.</p>
<p>초월(beyond), 가상을 의미하는 meta와 세계를 의미하는 universe의 합성어이다. (1992년 출간된 소설 ‘스노 크래시’ 속 가상 세계 명칭인 ’메타버스’에서 유래한다.)</p>
<p>라 이 프 로 깅 (Lifelogging) 개인의 삶을 디지털로 기록하여 가상세계로 옮기는 개념으로, 메타버스와 관련이 깊다.</p>
<p>메타버스에서는 사용자들이 디지털 아바타를 통해 자신의 삶을 반영하고, 그 기록을 가상세계에서 공유 및 저장할 수 있다.</p>
<p>삶을 뜻하는 life와 일지 작성을 의미하는 logging의 합성어이다. 특히 logging은 일반적으로 컴퓨터 시스템에서의 사용 기록을 포함하여 모든 행위의 기록을 의미한다.</p>
<p>제페토</p>
<p>내 아바타로 즐기는 또 다른 세상</p>
<p>web.zepeto.me</p>
<ol type="1">
<li>가 상 현 실 (VR, Virtual Reality) 실제와 유사하지만 실제가 아닌 인공 환경. 현실 세계에서 할 수 없는 활동을 할 수 있다.</li>
</ol>
<p>Beat Saber on Steam</p>
<p>Beat Saber is a VR rhythm game where you slash the beats of adrenaline-pumping music as they fly towards you, surrounded by a futuristic world.</p>
<p>store.steampowered.com</p>
<p>Half-Life: Alyx on Steam</p>
<p>Half-Life: Alyx is Valve’s VR return to the Half-Life series. It’s the story of an impossible fight against a vicious alien race known as the Combine, set between the events of Half-Life and Half-Life 2. Playing as Alyx Vance, you are humanity’s only</p>
<p>store.steampowered.com</p>
<p>Microsoft Flight Simulator - The next generation of one of the most beloved simulation franchises</p>
<p>Microsoft Flight Simulator is the next generation of one of the most beloved simulation franchises.</p>
<p>www.flightsimulator.com</p>
<ol start="2" type="1">
<li>증 강 현 실 (AR, Augmented Reality) 현실 세계에 디지털 정보를 추가해 현실의 개념을 확장하는 기술.</li>
</ol>
<p>Pokemon GO – Pokémon GO</p>
<p>GO로켓단 GO로켓단의 마수가 “Pokémon GO”의 세계에 뻗쳐오고 있습니다! “스페셜리서치” 클리어나 “그림자 포켓몬”을 구하는 과정에서, GO로켓단에게 승부를 걸어 야망을 저지할 수 있습니다.</p>
<p>pokemongolive.com</p>
<p>이케아, 비주얼 서치 기능 탑재한 ‘이케아 플레이스’ 안드로이드 앱 출시</p>
<p>[서울 - 3월 21일] 글로벌 홈퍼니싱 기업 이케아는 가상으로 가구를 공간에 배치할 수 있는 증강현실(AR) 앱 ’이케아 플레이스(IKEA Place)’를 안드로이드 버전으로 출시한다.</p>
<p>www.ikea.com</p>
<p>4D Interactive Anatomy</p>
<p>www.4danatomy.com</p>
<ol start="3" type="1">
<li><p>혼 합 현 실 (MR, Mixed Reality) 가상 세계와 현실 세계를 섞어서 VR 헤드셋을 통해 보여주는 것으로 두 가지 유형이 있다.</p></li>
<li><p>가상 객체 ⇨ 현실 세계:</p></li>
</ol>
<p>사용자가 VR 헤드셋의 카메라를 통해 현실 세계를 볼 때, 가상 ​​객체가 시야에 매끄럽게 혼합됨.</p>
<p>Leading Innovation in Augmented Reality</p>
<p>Magic Leap is leading innovation in Augmented Reality by bringing together industry-leading optics, scalable production, AI capabilities &amp; immersive AR experiences.</p>
<p>www.magicleap.com</p>
<ol start="2" type="1">
<li>실제 객체 ⇨ 가상 세계:</li>
</ol>
<p>가상 세계에서 플레이하는 VR 게이머를 보는 것처럼, 가상 세계에 혼합된 VR 이용자의 카메라 뷰.</p>
<p>Richie’s Plank Experience on Steam</p>
<p>You’re on a plank, 80 stories high. Knees shaky, palms sweaty. You have a choice. Do you walk or do you freeze? Richie’s Plank is the only VR experience that lets you clone any real-world plank into the virtual world for 2X the immersion.</p>
<p>store.steampowered.com</p>
<ol start="4" type="1">
<li>확 장 현 실 (XR, Extended Reality) AR, VR, MR을 포함한 모든 확장된 현실 기술을 통칭.</li>
</ol>
<p>Meta Quest의 Meta Horizon 월드 | Quest VR 게임</p>
<p>www.meta.com</p>
<p>거 울 세 계 (Mirror World) 현실 세계를 반영한 가상 공간.</p>
<p>개요 – Google 어스</p>
<p>세계에서 가장 정교한 지구본</p>
<p>www.google.com</p>
<p>이러한 기술들이 모두 메타버스를 구성하는 요소로, 기술이 아직 완전히 성숙하지는 않았으나, 적용된 정도에 따라 메타버스로 분류될 수 있다.</p>
<p>Meta는 기존의 것에서 한 단계 발전된 상태를 의미하며, 다양한 분야에서 이 용어가 결합되어 사용된다.</p>
<ol type="1">
<li><p>메 타 인 지 (Metacognition) 자신의 인지 과정을 인식하고 조절하는 능력.</p></li>
<li><p>메 타 검 색 (Meta Search) 다양한 검색 알고리즘을 사용하여 여러 웹페이지를 취합해 검색 결과를 보여주는 기술.</p></li>
</ol>
<p>가격 비교 사이트들이 메타 검색 방식을 사용하여 다양한 온라인 쇼핑몰의 제품 가격을 취합 및 비교할 수 있게 한다.</p>
<ol start="3" type="1">
<li><p>메 타 데 이 터 (Metadata) 데이터에 대한 데이터, 정보의 구조 및 속성을 설명하는 데이터.</p></li>
<li><p>메 타 프 로 그 램 (Metaprogram) 프로그램을 제어하거나 최적화하는 프로그램.</p></li>
</ol>
<p>어셈블리어(Assembly Language):</p>
<p>컴퓨터의 하드웨어와 직접 소통할 수 있는 저수준 프로그래밍 언어. 기계어(Machine Code, 0과 1로 이루어진 이진수)와 1:1로 대응된다.</p>
<p>컴파일러(Compiler):</p>
<p>고수준 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환해 주는 프로그램.</p>
<p>애 니 메 이 션 &amp; 게 임 그래픽 기술은 2차원 또는 3차원 애니메이션 영화를 제작하는 데 사용된다. 실제로 촬영된 영상과 그래픽 기술을 조합하여 현실감을 높이기도 한다.</p>
<p>매우 복잡한 모델링과 고화질의 렌더링을 사용한다. 따라서 이를 위해서는, 많은 양의 인적 · 물적 자원이 필요하다.</p>
<p>그래픽 기술은 캐릭터, 배경화면, 애니메이션 등에도 사용된다. 게임은 (온 · 오프라인에 관계없이) 사용자의 반응이 화면에 즉시 반영되어야 한다.</p>
<p>이를 구현하기 위해, 아래의 조건을 고려해야 한다:</p>
<p>사용자와 프로그램 사이의 상호 작용 설계 상호 작용에 걸리는 시간을 최소화</p>
<p>C 라이브러리 사용 ⇨ 프로그래밍 언어 (C 프로그래밍 언어에서 제공하는 라이브러리를 사용하여 프로그램을 작성하는 것.)</p>
<p>C 라이브러리(C Library):</p>
<p>C 프로그래밍 언어에 포함된 여러 함수들의 모음으로, 프로그래머가 특정 기능을 직접 작성하지 않고도 사용할 수 있도록 만들어진 도구들.</p>
<p>Low–level 게임 개발</p>
<p>하드웨어에 가까운 수준에서 직접적으로 시스템 자원(CPU, GPU, 메모리 등)을 제어하는 방식으로 게임을 개발하는 것.</p>
<p>저수준 프로그래밍(low–level programming)을 통해 개발하는 게임은 성능이 뛰어나고, 하드웨어 자원을 효율적으로 사용한다.</p>
<p>그러나 개발 과정이 복잡하고, 시간 소모가 크다.</p>
<p>DirectX &amp; OpenGL</p>
<p>하드웨어 가속을 사용하여 그래픽을 처리할 수 있는 저수준 API이다. 게임 개발자가 GPU(Graphics Processing Unit)를 직접 제어하고, 고성능 그래픽 렌더링을 구현한다.</p>
<p>아래는 고수준 게임 개발에 직접적인 역할을 하지는 않지만, 다양한 기술적 맥락에서 간접적으로 게임 개발에 응용되는 기술이다.</p>
<ol type="1">
<li>Java3D Java 기반 3D 그래픽 API.</li>
</ol>
<p>3D 그래픽 애플리케이션 및 게임을 개발할 수 있는 프레임워크. 3D 그래픽을 쉽게 만들 수 있는 고수준 API이기 때문에 게임 개발에 사용될 수 있다.</p>
<p>그러나 Unity, Unreal 같은 최신 게임 엔진에 비해 인기가 적다.</p>
<ol start="2" type="1">
<li>LLM (Large Language Model, 대형 언어 모델) LLM은 자연어 처리에 사용되는 대형 신경망 모델로, 게임 개발에서는 대화형 AI 캐릭터, 스토리 생성, 대화 시스템 등을 구현하는 데 사용된다.</li>
</ol>
<p>특히, 대화형 RPG 게임이나 스토리 기반 게임에서 플레이어와의 상호작용을 개선하는 데 유용하다.</p>
<ol start="3" type="1">
<li>VAE (Variational Autoencoder, 변분 오토인코더) 생성 모델 중 하나로, 데이터를 압축하여 새로운 데이터를 생성하는 방식이다. 게임 개발에서는 캐릭터 디자인이나 레벨 생성 같은 곳에서 VAE를 사용할 수 있다.</li>
</ol>
<p>예를 들어, 게임의 다양한 캐릭터나 맵을 자동으로 생성하는 데 응용할 수 있다.</p>
<ol start="4" type="1">
<li>GAN (Generative Adversarial Network, 생성적 적대 신경망) 두 개의 신경망(생성자와 판별자)이 경쟁하면서 더 나은 데이터를 생성하는 모델.</li>
</ol>
<p>게임 개발에서는 게임 내 캐릭터 디자인, 배경 생성, 아트 디자인 등을 자동화하는 데 사용할 수 있다. 특히, 고품질의 그래픽 콘텐츠를 자동으로 생성하는 데 유용하다.</p>
<ol start="5" type="1">
<li>Diffusion 모델 (Stable Diffusion) 점차 데이터를 더 정교하게 만들어가는 방식으로 이미지를 생성한다.</li>
</ol>
<p>특히 이미지 생성에서 강력한 성능을 발휘하며, 게임 개발에서는 게임 아트나 배경 생성, 캐릭터 디자인에 사용할 수 있다.</p>
<p>0 2 . 컴 퓨 터 그 래 픽 스 구 성 요 소 모델링(Modeling)과 렌더링(Rendering)라는 두 가지 카테고리로 구분할 수 있다.</p>
<ol type="1">
<li>모델링은 무엇을 그릴 것인지에 관련된 것으로, 그래픽으로 표현하고자 하는 장면(Scene) 내부의 물체(Object)를 정의하는 작업을 말한다.</li>
</ol>
<p>물체를 선분의 집합으로 정의하려면 선분의 양 끝점 위치를 명시하는 작업이 필요하다.</p>
<p>즉, 평면 다각형의 집합으로 다각형 정점의 위치를 명시하는 작업이 모델링이다. 이 밖에 여러 가지 물체를 조합하여 새로운 물체를 정의하는 작업도 모델링에 속한다.</p>
<p>모델링은 2차원 또는 3차원 물체를 표현할 수 있는 자료 구조와 해당 자료 구조를 처리할 수 있는 알고리즘을 포함하고 있다.</p>
<ol start="2" type="1">
<li>렌더링은 모델링에 의해 정의된 물체를 어떻게 그릴 것인지에 관련된 것이다. (우리가 화면에서 보는 모든 그림 ⇨ 렌더링의 결과)</li>
</ol>
<p>아래는 렌더링과 관련하여 고려해야 하는 요소이다:</p>
<p>관찰자의 위치 물체 표면의 재질 조명의 세기 및 위치 3D 객체를 2D 평면으로 변환하는 과정 등</p>
<p>사용자가 원하는 바에 따라 그래픽을 제공해야 하는 개발자들은 사용자 인터페이스(User Interface)를 제3의 구성 요소로 간주하기도 한다.</p>
<p>사용자와의 상호 작용 윈도우나 메뉴 구성 등 교제: Open GL로 배우는 3차원 컴퓨터 그래픽스</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/cg_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>팅커캐드 사용법</title>
  <link>https://shinjihan.github.io/studylog/ch/uno_01.html</link>
  <description><![CDATA[ 




<p>팅커캐드(Tinkercad)는 Autodesk에서 제공하는 웹 기반의 3D 설계, 전자 회로 시뮬레이션, 코딩 도구이다. 간단한 전자 회로를 설계하고 이를 코드로 제어하는 과정에 대해 다루고자 한다.</p>
<p>팅커캐드(Tinkercad) 사이트로 들어간다.</p>
<p>https://www.tinkercad.com/dashboard</p>
<ul>
<li>만들기 에서 회로를 클릭한다.</li>
</ul>
<p>첫 화면</p>
<p>첫 번째 예제</p>
<p>위와 같이 연결한 다음, 시뮬레이션 시작버튼을 클릭하면, LED가 깜박거린다.</p>
<p>세부사항: 저항을 클릭한 뒤 ’220’을 입력한다.</p>
<p>코드 ⇨ 블록 ⇨ 문자 를 클릭하면 회로도의 코드를 볼 수 있다.</p>
<p>[ 1 ]</p>
<p>이 코드는 아두이노(Arduino)에서 LED_BUILTIN 핀(일반적으로 13번 핀)에 연결된 내장 LED를 1초마다 깜박이게 하는 C++ 코드이다.</p>
<p>기본적으로 제공되는 코드이며, 초보자도 쉽게 이해할 수 있는 코드이다. 이 코드에서는 아두이노의 고수준 함수를 사용하여 하드웨어를 직관적으로 제어하고 있다.</p>
<p>void setup() {</p>
<p>// LED_BUILTIN 핀을 출력 모드로 설정 pinMode(LED_BUILTIN, OUTPUT);</p>
<p>}</p>
<p>void loop() {</p>
<p>// LED_BUILTIN 핀을 HIGH로 설정하여 LED 켜기 digitalWrite(LED_BUILTIN, HIGH);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>// LED_BUILTIN 핀을 LOW로 설정하여 LED 끄기 digitalWrite(LED_BUILTIN, LOW);</p>
<p>// 1000ms(1초) 대기 delay(1000);</p>
<p>}</p>
<p>[ 2 ]</p>
<p>이 코드는 AVR 마이크로컨트롤러에서 실행되는 임베디드 C 코드로, 특정 레지스터인 Port B의 5번 핀(PB5)를 제어하여 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드에서는 비트 연산자를 활용하여 핀을 토글(반전)하는 방식을 사용하고 있다.</p>
<p>int main() {</p>
<pre><code>// DDRB의 5번 비트를 1로 설정하여 Port B의 5번 핀(PB5)을 출력 모드로 설정
DDRB |= (1 &lt;&lt; PB5);

// 무한 루프 시작
while (1) {

    // PB5 핀의 상태를 반전시킴 (HIGH -&gt; LOW 또는 LOW -&gt; HIGH)
    PORTB ^= (1 &lt;&lt; PB5);
    
    // 500ms(0.5초) 동안 대기
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>[ 3 ] 이 코드는 위와 동일한 AVR C 코드이며, 마찬가지로 LED를 0.5초마다 깜박이게 하는 프로그램이다.</p>
<p>이 코드는 레지스터의 전체 Port B 값을 설정하여, 핀을 제어하는 방식을 사용한다. 즉, 전체 값을 명시적으로 설정하는 방식으로 동작한다.</p>
<p>int main() { // Port B의 데이터 방향 레지스터를 설정하여 5번 핀을 출력 모드로 설정한다. // 0x20은 2진수로 00100000으로, 5번 핀을 출력으로 설정한다.</p>
<pre><code>DDRB = 0x20;

// 무한 루프 시작
while (1) {
    
    // Port B의 모든 핀을 LOW로 설정하여 5번 핀만 LOW로 설정된다.
    PORTB = 0x00;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
    
    // Port B의 5번 핀을 HIGH로 설정하여 LED나 다른 장치를 켠다.
    PORTB = 0x20;
    
    // 500ms(0.5초) 동안 대기.
    _delay_ms(500);
}</code></pre>
<p>}</p>
<p>두 번째 예제</p>
<p>위와 같이 연결한 다음, 추가적인 코드 작업이 필요하다.</p>
<p>이 코드는 [1]번과 같은 아두이노 코드이다. 여러 핀을 제어하여 LED를 번갈아가며 깜박거리게 만드는 기능을 수행한다.</p>
<p>const int pins[] = {1, 2, 3, 4, 5, 6, 7}; // 핀 번호 배열 const int numPins = sizeof(pins) / sizeof(pins[0]); // 배열 크기를 자동으로 계산</p>
<p>void setup() { for (int i = -1; i &lt; numPins; i++) {</p>
<pre><code>// 모든 핀을 출력으로 설정
pinMode(pins[i], OUTPUT); </code></pre>
<p>} }</p>
<p>void loop() {</p>
<p>// 첫 번째 패턴: 짝수 핀은 HIGH, 홀수 핀은 LOW for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], HIGH); // 짝수 핀 ON
} else {

  digitalWrite(pins[i], LOW); // 홀수 핀 OFF
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>// 두 번째 패턴: 짝수 핀은 LOW, 홀수 핀은 HIGH for (int i = -1; i &lt; numPins; i++) { if (i % 2 == 0) {</p>
<pre><code>  digitalWrite(pins[i], LOW); // 짝수 핀 OFF
} else {
  
  digitalWrite(pins[i], HIGH); // 홀수 핀 ON
}</code></pre>
<p>}</p>
<p>delay(500); // 0.5초 대기</p>
<p>}</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/ch/uno_01.html</guid>
  <pubDate>Tue, 10 Sep 2024 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
