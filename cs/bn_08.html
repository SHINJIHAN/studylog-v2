<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-06">

<title>라우팅(Routing) – StudyLog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5c49dcdaa1dd0040e71953adad602abc.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">StudyLog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SHINJIHAN"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://sinjihan71.tistory.com/"> 
<span class="menu-text"><img src="Tstory.png" style="width:15px;height:17px;"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#개요" id="toc-개요" class="nav-link active" data-scroll-target="#개요">01 개요</a></li>
  <li><a href="#동적-라우팅-알고리즘의-구조" id="toc-동적-라우팅-알고리즘의-구조" class="nav-link" data-scroll-target="#동적-라우팅-알고리즘의-구조">02 동적 라우팅 알고리즘의 구조</a></li>
  <li><a href="#디스턴스-벡터-알고리즘" id="toc-디스턴스-벡터-알고리즘" class="nav-link" data-scroll-target="#디스턴스-벡터-알고리즘">03 디스턴스 벡터 알고리즘</a></li>
  <li><a href="#링크-스테이트-알고리즘" id="toc-링크-스테이트-알고리즘" class="nav-link" data-scroll-target="#링크-스테이트-알고리즘">04 링크 스테이트 알고리즘</a></li>
  <li><a href="#최단-경로-탐색-알고리즘" id="toc-최단-경로-탐색-알고리즘" class="nav-link" data-scroll-target="#최단-경로-탐색-알고리즘">05 최단 경로 탐색 알고리즘</a></li>
  <li><a href="#플러딩-알고리즘" id="toc-플러딩-알고리즘" class="nav-link" data-scroll-target="#플러딩-알고리즘">06 플러딩 알고리즘</a></li>
  <li><a href="#계층적-라우팅" id="toc-계층적-라우팅" class="nav-link" data-scroll-target="#계층적-라우팅">07 계층적 라우팅</a></li>
  <li><a href="#정적-라우팅의-활용" id="toc-정적-라우팅의-활용" class="nav-link" data-scroll-target="#정적-라우팅의-활용">8. 정적 라우팅의 활용</a>
  <ul class="collapse">
  <li><a href="#종합-관점" id="toc-종합-관점" class="nav-link" data-scroll-target="#종합-관점">9. 종합 관점</a></li>
  <li><a href="#애자일-개발-방법론-전략적-관점" id="toc-애자일-개발-방법론-전략적-관점" class="nav-link" data-scroll-target="#애자일-개발-방법론-전략적-관점">애자일 개발 방법론: 전략적 관점</a>
  <ul class="collapse">
  <li><a href="#개발-방법론의-분류-및-특성" id="toc-개발-방법론의-분류-및-특성" class="nav-link" data-scroll-target="#개발-방법론의-분류-및-특성">1. 개발 방법론의 분류 및 특성</a></li>
  <li><a href="#애자일의-전략적-활용" id="toc-애자일의-전략적-활용" class="nav-link" data-scroll-target="#애자일의-전략적-활용">2. 애자일의 전략적 활용</a></li>
  <li><a href="#폭포수-방식-대비-애자일의-장점과-한계" id="toc-폭포수-방식-대비-애자일의-장점과-한계" class="nav-link" data-scroll-target="#폭포수-방식-대비-애자일의-장점과-한계">3. 폭포수 방식 대비 애자일의 장점과 한계</a></li>
  <li><a href="#적용-사례-및-실무-전략" id="toc-적용-사례-및-실무-전략" class="nav-link" data-scroll-target="#적용-사례-및-실무-전략">4. 적용 사례 및 실무 전략</a></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론">5. 결론</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">라우팅(Routing)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">1</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 6, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="개요" class="level1">
<h1>01 개요</h1>
<p>네트워크 계층(Network Layer)의 핵심 기능으로, 데이터 패킷이 출발지에서 목적지까지 도달하기 위한 <strong>최적의 경로를 결정</strong>하는 과정을 의미한다.</p>
<p>이 과정은 네트워크의 토폴로지 변화, 트래픽 부하, 링크 상태 등에 따라 동적으로 변화하며, 효율성과 안정성 간의 균형이 중요하다.</p>
<p>라우팅은 크게 <strong>정적(Stati</strong>c)과 <strong>동적(Dynamic)</strong> 방식으로 구분된다.</p>
<ul>
<li><p><strong>정적 라우팅 (Static Routing)</strong>:</p></li>
<li><p>관리자가 수동으로 경로를 지정.</p></li>
<li><p>소규모 네트워크에서 안정적이지만, 링크 장애나 토폴로지 변화에 대응 불가.</p></li>
<li><p><strong>동적 라우팅 (Dynamic Routing)</strong>:</p></li>
<li><p>라우터가 인접 노드들과 정보를 교환하며 최적 경로를 실시간 계산.</p></li>
<li><p>자율성과 적응력이 높으나, 연산 부하와 제어 메시지 비용이 증가.</p></li>
</ul>
<hr>
</section>
<section id="동적-라우팅-알고리즘의-구조" class="level1">
<h1>02 동적 라우팅 알고리즘의 구조</h1>
<p>동적 라우팅은 보통 다음의 4단계를 거쳐 작동한다.</p>
<ol type="1">
<li><strong>정보 교환</strong> – 인접 라우터 간의 네트워크 상태 정보 공유.</li>
<li><strong>경로 계산</strong> – 알고리즘을 이용해 최단 경로 계산.</li>
<li><strong>라우팅 테이블 갱신</strong> – 새로운 경로로 테이블을 업데이트.</li>
<li><strong>재배포 및 수렴</strong> – 변경사항을 네트워크 전반에 반영.</li>
</ol>
<p>수렴 시간 <code>Convergence Time</code> 전체 네트워크가 일관된 경로 정보를 갖게 되는 데 걸리는 시간으로, 라우팅 프로토콜의 효율성을 판단하는 주요 지표다.</p>
<hr>
</section>
<section id="디스턴스-벡터-알고리즘" class="level1">
<h1>03 디스턴스 벡터 알고리즘</h1>
<p><code>Distance Vector</code> 각 라우터가 인접 라우터로부터 거리 정보를 받아 자신의 테이블을 갱신하는 방식이다. <strong>인접 노드의 정보만 활용</strong>하므로 구현이 단순하고 <strong>소규모 네트워크</strong>에 적합하다.</p>
<ul>
<li><p><strong>대표 프로토콜</strong>:</p></li>
<li><p>RIP (Routing Information Protocol),</p></li>
<li><p>IGRP (Interior Gateway Routing Protocol)</p></li>
<li><p><strong>장점</strong>: 관리 용이, 계산 단순.</p></li>
<li><p><strong>단점</strong>: 느린 수렴 속도, 루프 형성 가능성, “Count to Infinity” 문제 존재.</p></li>
</ul>
<hr>
</section>
<section id="링크-스테이트-알고리즘" class="level1">
<h1>04 링크 스테이트 알고리즘</h1>
<p><code>Link State = 네트워크 정보 수집 + Dijkstra 기반 최단 경로 계산</code> 각 라우터가 네트워크 전체의 링크 상태 정보를 수집하여 독립적으로 최단 경로를 계산.</p>
<ul>
<li><p><strong>동작 단계</strong>:</p></li>
<li><p>링크 상태 광고(LSA)</p></li>
<li><p>→ 링크 상태 데이터베이스(LSDB) 구축</p></li>
<li><p>→ Dijkstra 알고리즘 수행</p></li>
<li><p>→ 라우팅 테이블 갱신.</p></li>
<li><p><strong>대표 프로토콜</strong>:</p></li>
<li><p>OSPF (Open Shortest Path First)</p></li>
<li><p>IS-IS (Intermediate System to Intermediate System)</p></li>
<li><p><strong>장점</strong>: 빠른 수렴, 대규모 네트워크 적합, 루프 방지 능력 우수.</p></li>
<li><p><strong>단점</strong>: 초기 설정 복잡, 높은 메모리 및 CPU 사용량, 관리 부담.</p></li>
</ul>
<hr>
</section>
<section id="최단-경로-탐색-알고리즘" class="level1">
<h1>05 최단 경로 탐색 알고리즘</h1>
<p><code>Dijkstra 기반</code> 노드 간의 비용(weight)을 기반으로 최소 누적 비용 경로를 찾는다.</p>
<ul>
<li><p><strong>단계</strong>:</p></li>
<li><p>거리 초기화</p></li>
<li><p>→ 최소 거리 노드 선택</p></li>
<li><p>→ 거리 갱신 → 반복 수행.</p></li>
<li><p><strong>특징</strong>: 결정적(Deterministic) 경로 제공, 루프 방지 가능.</p></li>
<li><p><strong>한계</strong>: 계산 복잡도 O(V²), 대규모 네트워크에서는 성능 부하.</p></li>
</ul>
<hr>
</section>
<section id="플러딩-알고리즘" class="level1">
<h1>06 플러딩 알고리즘</h1>
<p><code>Flooding</code> 경로 정보 없이 모든 인접 노드로 패킷을 전송하여 목적지에 도달하게 하는 방식.</p>
<ul>
<li><p><strong>원리</strong>:</p></li>
<li><p>패킷 복사</p></li>
<li><p>→ Hop Count 제한</p></li>
<li><p>→ 중복 방지 처리.</p></li>
<li><p><strong>장점</strong>: 경로 미확보 상태에서도 신뢰성 높은 전송 가능.</p></li>
<li><p><strong>단점</strong>: 불필요한 트래픽 급증, 대규모 환경 비효율적.</p></li>
</ul>
<hr>
</section>
<section id="계층적-라우팅" class="level1">
<h1>07 계층적 라우팅</h1>
<p><code>Hierarchical Routing</code> 네트워크를 여러 영역(Area)으로 분할하여 트래픽을 계층적으로 관리.</p>
<ul>
<li><p><strong>구조</strong>:</p>
<ol type="1">
<li>백본 영역 (Backbone Area)</li>
<li>지역 영역 (Regional Area)</li>
<li>접속망 (Access Network)</li>
</ol></li>
<li><p><strong>장점</strong>: 라우팅 테이블 크기 감소, 트래픽 분산, 대규모 네트워크에 최적.</p></li>
<li><p><strong>단점</strong>: 초기 설계 복잡, 영역 간 병목 발생 위험.</p></li>
<li><p><strong>적용 예시</strong>: OSPF Area 구조, BGP(Border Gateway Protocol) 간 경계 라우팅.</p></li>
</ul>
<hr>
</section>
<section id="정적-라우팅의-활용" class="level1">
<h1>8. 정적 라우팅의 활용</h1>
<p>정적 라우팅은 오늘날에도 ISP 백본망의 <strong>백업 경로</strong> 또는 <strong>보안이 중요한 폐쇄망</strong>에서 여전히 사용된다. 비록 유연성은 부족하지만, 예측 가능한 동작과 낮은 오버헤드로 인해 핵심 네트워크의 안정성을 보완하는 역할을 한다.</p>
<section id="종합-관점" class="level3">
<h3 class="anchored" data-anchor-id="종합-관점">9. 종합 관점</h3>
<p>라우팅의 본질은 <strong>비용(Cost) 최소화와 신뢰성 보장 간의 최적화 문제</strong>다. 이는 수학적으로 그래프 이론, 최적화 이론, 그리고 분산 시스템 이론의 결합으로 해석된다.</p>
<p>현대의 네트워크 라우팅은 단순한 경로 탐색을 넘어 <strong>QoS(Quality of Service)</strong>, <strong>트래픽 엔지니어링</strong>, <strong>자율형 네트워크 관리(Autonomic Networking)</strong> 등의 복합적 목적을 내포한다.</p>
<hr>
<ol type="1">
<li>네트워크 라우팅이 중요한 이유</li>
</ol>
<p>네트워크 라우팅은 단순히 데이터를 목적지까지 전달하는 기술이 아니라, 전체 네트워크의 <strong>데이터 전달 정확성</strong>, <strong>빠르고 효율적인 통신</strong>, <strong>탄력성과 안정성</strong>, <strong>보안</strong>, <strong>유연한 구조와 지도 역할</strong> 등 네트워크 운영의 핵심 요소를 결정하는 전략적 기술이다. 실무적으로 라우팅이 중요한 이유는 매우 구체적이며, 이는 서비스 품질과 운영 효율성에 직접적인 영향을 미친다.</p>
<p>우선, 라우팅은 <strong>데이터 전달의 정확성과 통신 효율성</strong>을 결정한다. 적절하지 않은 경로 설정은 패킷 손실과 지연 시간을 증가시켜 애플리케이션의 성능을 저하시킨다. 실시간 서비스, 클라우드 애플리케이션, 영상회의, VoIP 등에서는 최적 경로 선택이 사용자 경험에 직접적인 영향을 미치므로, 트래픽이 가장 효율적인 경로를 선택하도록 설계하는 것이 필수적이다.</p>
<p>또한, 라우팅은 <strong>탄력성과 안정성</strong>을 확보하는 기반이 된다. 다중 경로 구성과 BGP 다중 연결은 특정 구간의 장애가 발생하더라도 서비스가 지속되도록 하며, 장애 발생 시 <strong>자동 복구와 우회</strong>를 가능하게 한다. 이를 위해 빠른 전환(failover)과 루프 방지 메커니즘이 필수적으로 적용된다. 장애가 발생했을 때 라우팅 테이블이 신속히 갱신되지 않으면 전체 서비스 중단으로 이어질 수 있으므로, 실무에서는 BFD와 같은 신속 복구 기술이 중요하다.</p>
<p>비용과 효율 측면에서도 라우팅은 중요한 역할을 한다. 대규모 네트워크에서는 트래픽을 비용이 낮은 피어링이나 인터넷 교환 지점(IX)으로 유도하여 운영 비용을 절감한다. 잘못된 경로 선택은 불필요한 트랜싯 사용으로 비용을 증가시키므로, 라우팅 정책을 통해 트래픽의 흐름과 비용 구조를 동시에 관리해야 한다.</p>
<p>보안 측면에서는 라우팅이 <strong>네트워크 보호와 정책 집행</strong>의 핵심 수단이다. RPKI, BGP 필터링, 정책 기반 라우팅(PBR)을 통해 IP 하이재킹이나 스푸핑 공격을 방지하고, 내부 네트워크를 세분화하여 공격 확산을 억제할 수 있다.</p>
<p>트래픽 엔지니어링과 서비스 품질 보장도 라우팅의 핵심 기능 중 하나이다. MPLS, SD-WAN, ECMP와 같은 기술을 활용해 트래픽의 지연과 대역폭을 조정하고, SLA를 준수할 수 있다. 실시간 트래픽은 우선 경로로, 백업 트래픽은 비혼잡 경로로 유도하는 등 <strong>유연한 구조와 경로 관리</strong>가 가능하다.</p>
<p>마지막으로, 라우팅은 <strong>네트워크 구조의 지도 역할과 운영 관측성</strong>을 수행한다. 경로 정보, BGP 상태, 트래픽 흐름 데이터를 통해 네트워크 전체의 상태를 시각화하고, 문제 발생 시 근본 원인을 분석할 수 있다. 이는 성능 저하 원인을 신속히 파악하고 애플리케이션 문제와 구분하는 데 필수적이다.</p>
<p>결론적으로, 네트워크 라우팅은 단순한 연결 설정이 아니라, <strong>데이터 전달의 정확성, 통신 효율, 안정성과 탄력성, 보안, 비용 효율, 유연한 구조와 지도 역할</strong>을 모두 통합적으로 관리하는 전략적 기술이다. 실무에서는 라우팅을 서비스 품질을 유지하고 네트워크 자원을 최적화하는 <strong>정책적 제어 체계</strong>로 인식해야 한다.</p>
<ol start="2" type="1">
<li>동적 라우팅 방식은 언제 필요하며, 장단점은?</li>
</ol>
<hr>
</section>
<section id="애자일-개발-방법론-전략적-관점" class="level2">
<h2 class="anchored" data-anchor-id="애자일-개발-방법론-전략적-관점">애자일 개발 방법론: 전략적 관점</h2>
<section id="개발-방법론의-분류-및-특성" class="level3">
<h3 class="anchored" data-anchor-id="개발-방법론의-분류-및-특성">1. 개발 방법론의 분류 및 특성</h3>
<p>소프트웨어 개발 프로젝트는 전통적으로 <strong>폭포수(Waterfall) 방식</strong>과 <strong>애자일(Agile) 방식</strong>으로 구분된다. 폭포수 방식은 요구사항 정의 → 분석 → 설계 → 구현 → 테스트 → 배포로 이어지는 <strong>선형적 단계 모델</strong>을 따르며, 각 단계가 완료되어야 다음 단계로 진행된다. 이 접근법은 명확한 요구사항과 엄격한 일정 관리가 필요할 때 효과적이지만, 요구사항 변경이나 시장 변화에 유연하게 대응하기 어렵다는 한계가 있다.</p>
<p>반면 애자일 방식은 반복적·점진적 개발(iterative and incremental development)을 기반으로 한다. 핵심 원칙은 고객 요구사항의 변화에 민첩하게 대응하며, 기능 단위의 점진적 납품을 통해 피드백을 신속하게 반영하는 것이다. 프로젝트 관리에서는 WBS 기반의 일정 중심 관리보다 <strong>작업(Task) 중심 관리</strong>가 강조되며, 각 개발 주기를 스프린트(Sprint)로 정의한다. 일반적으로 스프린트는 1~4주 단위로 반복되며, 각 사이클 종료 시 실제 동작 가능한 소프트웨어를 제공하여 고객 검증과 요구사항 반영을 동시에 달성한다.</p>
</section>
<section id="애자일의-전략적-활용" class="level3">
<h3 class="anchored" data-anchor-id="애자일의-전략적-활용">2. 애자일의 전략적 활용</h3>
<ul>
<li><strong>고객 중심성</strong>: 초기 버전부터 고객과 지속적으로 상호작용하여 요구사항을 점진적으로 명확화한다.</li>
<li><strong>적응적 계획(Adaptive Planning)</strong>: 시장 변화나 기술적 요건에 맞춰 스프린트 계획을 유연하게 조정한다.</li>
<li><strong>위험 관리</strong>: 단기 목표 기반 반복 개발로 프로젝트 실패 가능성을 조기에 탐지하고 완화한다.</li>
<li><strong>팀 자율성</strong>: 크로스 기능적 팀(Cross-functional Team)이 스스로 우선순위를 판단하고 작업을 수행한다.</li>
</ul>
</section>
<section id="폭포수-방식-대비-애자일의-장점과-한계" class="level3">
<h3 class="anchored" data-anchor-id="폭포수-방식-대비-애자일의-장점과-한계">3. 폭포수 방식 대비 애자일의 장점과 한계</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>구분</th>
<th>폭포수(Waterfall)</th>
<th>애자일(Agile)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>개발 진행</td>
<td>선형, 단계별</td>
<td>반복적, 점진적</td>
</tr>
<tr class="even">
<td>요구사항 변경 대응</td>
<td>어려움</td>
<td>용이, 적응적</td>
</tr>
<tr class="odd">
<td>일정 관리</td>
<td>WBS 중심, 고정</td>
<td>스프린트 중심, 유연</td>
</tr>
<tr class="even">
<td>고객 참여</td>
<td>제한적</td>
<td>지속적 피드백 포함</td>
</tr>
<tr class="odd">
<td>위험 관리</td>
<td>후기 발견</td>
<td>조기 탐지 및 완화</td>
</tr>
<tr class="even">
<td>문서화</td>
<td>상세 문서 중심</td>
<td>최소 문서, 실행 중심</td>
</tr>
</tbody>
</table>
<p>애자일은 무제한적 유연성을 의미하지 않는다. 프로젝트 규모, 조직 구조, 규제 환경, 기술적 복잡성에 따라 적용 전략을 신중히 설계해야 하며, 과도한 변화 반영은 일정 지연과 품질 저하를 초래할 수 있다.</p>
</section>
<section id="적용-사례-및-실무-전략" class="level3">
<h3 class="anchored" data-anchor-id="적용-사례-및-실무-전략">4. 적용 사례 및 실무 전략</h3>
<ul>
<li><strong>스타트업 제품 개발</strong>: 빠른 시장 반응과 경쟁력 확보를 위해 애자일 방식이 적합하다.</li>
<li><strong>대기업 내부 시스템 개발</strong>: 일부 핵심 모듈은 폭포수 방식으로 안정성을 확보하고, 신규 기능 모듈은 애자일 방식으로 점진적 개발을 수행한다.</li>
<li><strong>혼합 접근(Hybrid Approach)</strong>: 전통적 개발 프로세스에 애자일 스프린트를 통합하여 안정성과 민첩성 간 균형을 확보한다.</li>
</ul>
</section>
<section id="결론" class="level3">
<h3 class="anchored" data-anchor-id="결론">5. 결론</h3>
<p>애자일은 단순한 개발 방법론이 아니라, <strong>조직의 전략적 의사결정, 프로젝트 관리 체계, 고객 가치 창출</strong>을 통합적으로 고려한 개발 패러다임이다. 이를 통해 변화하는 요구사항과 시장 환경 속에서도 효과적인 소프트웨어 개발과 관리가 가능하다.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shinjihan\.github\.io\/studylog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>