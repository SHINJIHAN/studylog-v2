<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>StudyLog</title>
<link>https://shinjihan.github.io/studylog/r-and-d.html</link>
<atom:link href="https://shinjihan.github.io/studylog/r-and-d.xml" rel="self" type="application/rss+xml"/>
<description>통계와 AI를 기록하는 개인 블로그</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Mon, 03 Mar 2025 15:00:00 GMT</lastBuildDate>
<item>
  <title>개발 일지4</title>
  <link>https://shinjihan.github.io/studylog/rd/od_06.html</link>
  <description><![CDATA[ 




<p>재실 감지 시스템을 개발하기 위한 기초 개념에 대해 다루고자 한다.</p>
<p>01 기본 개념</p>
<p>1 . 비동기 프로그래밍 (async/await) FastAPI는 비동기 처리를 지원하므로 기본적인 개념을 이해해야 한다.</p>
<p>2 . 데이터베이스 개념 SQL 기본 문법 (SELECT, INSERT, UPDATE, DELETE)</p>
<p>관계형 데이터베이스 (MySQL, PostgreSQL, SQLite 등)</p>
<p>https://www.w3schools.com/sql/</p>
<p>02 FastAPI 기본 사용법 FastAPI 설치 및 프로젝트 구조</p>
<p>기본적인 API 엔드포인트 만들기 (<span class="citation" data-cites="app.get">@app.get</span>(), <span class="citation" data-cites="app.post">@app.post</span>())</p>
<p>Pydantic을 이용한 데이터 검증 (BaseModel)</p>
<p>FastAPI에서 비동기(async def) 사용법</p>
<p>from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/”) async def home(): return {“message”: “Hello, FastAPI!”}</p>
<p>FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>Tutorial - User Guide - FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>03 SQLModel을 활용한 데이터베이스 연동 SQLModel 설치 및 기본 사용법</p>
<p>ORM 개념 이해하기 (객체를 데이터베이스 테이블과 매핑)</p>
<p>데이터베이스 모델 정의 및 CRUD(Create, Read, Update, Delete) 구현</p>
<p>SQLite로 간단한 DB 실습 후, MySQL/PostgreSQL 연동</p>
<p>SQLModel</p>
<p>SQLModel, SQL databases in Python, designed for simplicity, compatibility, and robustness.</p>
<p>sqlmodel.tiangolo.com</p>
<p>04 재실 감지 시스템 API 설계 및 구현 RESTful API 설계 방법</p>
<p>API 요청 및 응답 데이터 형식(Pydantic)</p>
<p>CRUD API 구현</p>
<p>API 테스트(Postman, Curl 활용)</p>
<p>from fastapi import FastAPI, Depends from sqlmodel import Session, select</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(“/rooms/{room_id}/status”) async def update_room_status(room_id: int, is_occupied: bool, session: Session = Depends(get_session)): room = session.exec(select(RoomStatus).where(RoomStatus.id == room_id)).first() if room: room.is_occupied = is_occupied session.commit() return {“message”: “Room status updated”} return {“error”: “Room not found”}</p>
<p>05 실시간 감지 시스템과 연동 (추가 학습) WebSocket을 이용한 실시간 데이터 전송</p>
<p>센서 데이터 연동 (IoT 장치와 연결)</p>
<p>백엔드에서 프론트엔드와 통신 (웹 애플리케이션 또는 모바일 앱과 연동)</p>
<p>WebSockets - FastAPI</p>
<p>FastAPI framework, high performance, easy to learn, fast to code, ready for production</p>
<p>fastapi.tiangolo.com</p>
<p>MQTT - The Standard for IoT Messaging</p>
<p>Why MQTT? Lightweight and Efficient MQTT clients are very small, require minimal resources so can be used on small microcontrollers. MQTT message headers are small to optimize network bandwidth. Bi-directional Communications MQTT allows for messaging betwe</p>
<p>mqtt.org 추가 학습 방향 ✅ Docker와 배포 방법</p>
<p>Docker로 FastAPI + SQLModel 앱 컨테이너화</p>
<p>서버에 배포 (AWS, GCP, Heroku 등)</p>
<p>✅ 보안 및 인증</p>
<p>JWT 인증 방식 (OAuth2)</p>
<p>API 보안 (CORS, CSRF 방어)</p>
<hr>
<p>https://pypi.org/project/paho-mqtt/</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_06.html</guid>
  <pubDate>Mon, 03 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지3</title>
  <link>https://shinjihan.github.io/studylog/rd/od_05.html</link>
  <description><![CDATA[ 




<p>재실감지 프로젝트의 2월 24일 오후 9시 회의에 대해 다루고자 한다.</p>
<p>01 API 정의 응용 프로그램 인터페이스, Application Programming Interface.</p>
<p>다른 프로그램과 소통할 수 있도록 만들어진 인터페이스. 사용하는 대상과 방식에 따라 다르게 분류될 수 있다.</p>
<p>API의 역할을 두 가지 측면에서 구분해서 봐야 한다.</p>
<p>1 . HTTP 통신을 위한 API 웹 애플리케이션이나 모바일 앱에서 백엔드 서버와 데이터를 주고받기 위한 API.</p>
<p>주로 HTTP 프로토콜을 사용하여 데이터를 요청하고 응답을 받는다.</p>
<p>예를 들어, 클라이언트(웹 브라우저, 모바일 앱 등)가 서버의 특정 URL에 요청을 보내면 서버가 JSON 형식으로 데이터를 응답하는 방식.</p>
<p>보통 REST API, GraphQL API 등이 이에 해당된다.</p>
<p>2 . 백엔드 내부에서 DB와 통신하는 API 백엔드 시스템 내부에서만 사용되는 API. 프로그램 내부에서 함수 호출을 통해 사용된다.</p>
<p>예를 들어, 백엔드 코드에서 DB에서 유저 정보를 가져오는 함수 같은 것이 이에 해당된다.</p>
<p>HTTP 요청 없이, 애플리케이션 내부의 모듈 간 통신을 위한 API라고 할 수 있다.</p>
<p>02 재실 확인 정의 연구실 내의 사람들의 재실 즉, 출입 여부를 확인하는 시스템을 구축하는 방식.</p>
<p>이를 이해하려면 프론트엔드(사용자 인터페이스)와 백엔드(서버) 간의 데이터 흐름을 살펴봐야 한다.</p>
<p>1 . 재실 상태 업데이트 방식 연구실 구성원이 출입할 때마다 해당 정보를 서버인 백엔드에 전송해야 한다.</p>
<p>이를 위해 POST 요청을 사용하여 현재 상태(입실/퇴실)를 백엔드에 전달한다. 백엔드는 이를 받아서 DB에 재실 정보를 저장한다.</p>
<p>2 . DB 직접 접근 불가 프론트엔드는 웹 브라우저에서 실행되는 화면(UI).</p>
<p>보안상 프론트엔드가 DB에 직접 접근하면 안 된다. 대신, 백엔드 서버에 GET 요청을 보내서 데이터를 가져와야 한다.</p>
<p>3 . GET 요청 연구실의 재실 상태가 바뀌어도 프론트엔드에서는 이를 자동으로 알 방법이 없다.</p>
<p>따라서 1초마다 백엔드에 GET 요청을 보내 최신 상태를 확인해야 한다. 이를 통해 연구실 출입 상태가 바꿜 때마다 UI가 자동으로 업데이트된다.</p>
<p>연구실 인원 수가 많지 않다면, 1초마다 GET 요청을 보내도 서버가 충분히 감당할 수 있다.</p>
<p>4 . 추가 최적화 방법 위 방식은 불필요한 트래픽이 발생할 수 있다.</p>
<p>웹소켓(WebSocket)을 사용하면 재실 상태가 변경될 때만 프론트엔드로 알림을 보낼 수 있다.</p>
<p>하지만 구현이 조금 더 복잡할 수 있다.</p>
<p>03 DB 설계</p>
<p>1 . DB의 정의 연구실 출입 정보를 저장해야 하므로 DB가 필요하다.</p>
<p>연구실 출입 기록을 관리하지 않고 메모리(RAM)에서만 처리하면 서버를 재시작하면 데이터가 사라진다.</p>
<p>따라서 DB에 출입 기록을 저장해야 한다.</p>
<p>2 . SQLite 연구실 시스템은 트래픽이 많지 않다.</p>
<p>SQLite는 파일 기반 경량 DB로, 연구실 같은 소규모 시스템에서 사용하기 적절하다.</p>
<p>대형 시스템이면 MySQL, PostgreSQL 같은 DB를 고려해야 하지만, 현재 상황에서는 SQLite로 충분하다.</p>
<p>3 . 로그 기록 남기는 방법 연구실 출입 기록을 DB에 어떻게 저장할지 고민하는 부분이다. 로그를 남기는 방식은 여러 가지가 있지만, 최소한의 정보만 저장하면 된다.</p>
<p>즉, 재실 상태를 실시간으로 저장하는 것이 아니라, “출입 로그만 남기면 충분하다”는 의미이다.</p>
<p>예를 들어, 한 사람이 하루에 5번 드나들면, 그 5번의 출입 로그만 기록하면 된다.</p>
<p>“현재 연구실에 있는 사람” 이 누구인지 확인하려면, status = ’ in ’ 중 가장 최신 로그를 보면 된다.</p>
<p>출입할 때만 기록을 남기므로 불필요한 데이터 저장을 최소화할 수 있다.</p>
<p>4 . DB 갱신 보류 데이터가 계속 쌓이면 DB 크기가 커지고 성능 저하 가능성이 있다. 그래서 “1달마다 오래된 로그를 삭제할까?” 라는 고민을 했지만, 결론적으로 필요 없다고 판단하였다.</p>
<p>SQLite는 소규모 데이터 저장에는 충분히 빠르고 효율적이다. 연구실 출입 기록을 하루 수십 ~ 수백 개 수준으로 가정해도 1년치 데이터는 몇 MB가 안 될 것이다.</p>
<p>따라서 데이터가 많아서 생기는 성능 문제는 걱정할 필요 없다.</p>
<p>5 . DB 제약사항 최소화 테이블을 만들 때, 외래키, 복잡한 관계 등 너무 많은 제약을 설정하지 말자는 의미.</p>
<p>SQLite는 간단한 DB이므로, 최대한 단순한 구조로 유지하는 것이 좋다. 최소한의 필드만 저장 (user_id, status, timestamp)</p>
<p>JOIN 남발하는 등 불필요한 복잡한 테이블 관계를 자제한다. ON DELETE CASCADE 같은 것을 최소화하여 강한 외래키 제약한다.</p>
<p>04 DB 라이브러리 선택 데이터베이스와 소통하려면 라이브러리(의존성)가 필요하며 다음과 같은 후보가 있다.</p>
<p>1 . SQLAlchemy Python에서 가장 널리 사용되는 ORM(Object-Relational Mapping) 라이브러리.</p>
<p>SQLAlchemy</p>
<p>The Database Toolkit for Python</p>
<p>www.sqlalchemy.org 트랜잭션, 복잡한 쿼리, DB 최적화 등 강력한 기능 제공하지만 설정이 복잡하고 학습 곡선이 가파르다.</p>
<p>장점 대규모 프로젝트에서 사용하기 좋다.</p>
<p>다양한 데이터베이스 지원 (PostgreSQL, MySQL, SQLite 등) ORM뿐만 아니라 직접 SQL을 실행하는 기능도 제공한다.</p>
<p>단점 문법이 복잡하고 설정이 어려우며, 초보자가 배우기에 부담스러울 수 있다.</p>
<p>추천 대상 ① 대규모 프로젝트에서 강력한 데이터베이스 기능이 필요한 경우 ② SQL을 잘 알고 있고 세부적인 최적화가 필요한 경우</p>
<p>2 . Peewee peewee — peewee 3.17.9 documentation</p>
<p>경량 ORM으로, 코드가 단순하고 배우기 쉽다. SQLAlchemy보다 기능이 적지만, 기본적인 CRUD 작업에는 충분하다.</p>
<p>장점 코드가 간결하고 직관적이며, 설정이 간단해 빠르게 시작 가능하다.</p>
<p>SQLite, PostgreSQL, MySQL을 지원한다.</p>
<p>단점 SQLAlchemy보다 기능이 부족하다. 대규모 프로젝트에는 부적절할 수 있다.</p>
<p>추천 대상 ① 작은 프로젝트나 빠르게 개발해야 하는 경우 ② 복잡한 DB 연산이 필요하지 않은 경우</p>
<p>3 . SQLModel SQLAlchemy를 기반으로 만든 최신 ORM. Pydantic과 통합되어 데이터 검증이 쉽다.</p>
<p>SQLModel</p>
<p>https://www.sqlalchemy.org/ SQLAlchemy의 강력한 기능을 유지하면서도 더 간단한 사용법 제공한다.</p>
<p>장점 공식 지원을 받으며, 최신 기술을 반영한다.</p>
<p>SQLAlchemy보다 더 간단한 문법 가지며, Pydantic과 연계되어 데이터 모델링과 검증이 쉽다.</p>
<p>단점 아직 SQLAlchemy만큼 성숙하지 않다. (상대적으로 신생 라이브러리) 복잡한 DB 기능을 다루려면 결국 SQLAlchemy의 일부 기능을 사용해야 한다.</p>
<p>추천 대상 ① FastAPI 같은 최신 프레임워크와 함께 사용할 경우 ② SQLAlchemy의 복잡함을 줄이고 싶지만, 강력한 기능이 필요한 경우</p>
<p>최종 결정으로 SQLModel을 선택하였다.</p>
<p>05 SQLite과의 비교</p>
<p>1 . 일반적인 DBMS MySQL, PostgreSQL 등이 해당된다.</p>
<p>독립적인 서버로 실행되며, 클라이언트가 네트워크를 통해 서버에 접속하여 데이터 요청한다.</p>
<p>여러 사용자가 동시에 접근할 수 있다.</p>
<p>2 . SQLite 서버가 없으므로, 별도의 프로그램을 실행할 필요 없다. 데이터를 ’ .db 파일 ’ 로 저장한다.</p>
<p>프로그램이 직접 파일을 읽고 쓰는 방식으로 동작한다. 가볍고 간단해서 로컬 데이터 저장용으로 적합하다.</p>
<p>06 쿼리</p>
<p>1 . 유저 테이블 랩원(사용자)에 대한 기본 정보를 저장한다.</p>
<p>2 . 로그 테이블 (presence)</p>
<p>입실 및 퇴실 시간을 기록한다.</p>
<p>각 로그에는 입실/퇴실 여부를 나타내는 정보와, 어떤 유저인지에 대한 정보가 포함된다.</p>
<p>이 쿼리는 presence 테이블에서 유저의 입실 및 퇴실 기록을 조회하는 쿼리이다.</p>
<p>SELECT DISTINCT ON (user_id) * FROM presence ORDER BY at_time, user_id DESC; 이 쿼리는 각 유저별로 가장 최근의 입실/퇴실 기록을 가져온다.</p>
<p>예를 들어, 유저 A가 오전 9시에 입실하고 오후 5시에 퇴실한 경우, presence 테이블에서 유저 A의 두 개의 레코드가 있을 수 있다.</p>
<p>이 쿼리는 유저 A의 가장 최근 퇴실 시간 또는 입실 시간을 선택하게 된다.</p>
<p>SELECT DISTINCT ON (user_id) DISTINCT ON (user_id)는 유저별로 가장 최근의 기록만 선택한다. 즉, 유저가 여러 번 입실/퇴실한 경우, 각 유저의 가장 최근 입실/퇴실 정보만 가져오게 된다.</p>
<p>’ * ’ 테이블의 모든 컬럼을 선택하겠다는 의미이다.</p>
<p>예를 들어, at_time (시간), user_id (유저 ID), 입실/퇴실 여부 등을 포함하는 모든 컬럼을 가져온다.</p>
<p>FROM presence presence 테이블에서 데이터를 가져온다. presence 테이블에는 입실과 퇴실 시간에 대한 기록이 저장되어 있다.</p>
<p>ORDER BY at_time, user_id DESC at_time으로 먼저 시간 순서대로 정렬한다. (입실/퇴실 시간을 기준으로 오름차순 정렬)</p>
<p>그 다음 user_id DESC로 유저 ID를 내림차순으로 정렬한다.</p>
<p>이는 같은 시간에 여러 번 입출입한 기록이 있을 수 있을 때, 가장 최신 기록을 가져오기 위함이다.</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_05.html</guid>
  <pubDate>Thu, 27 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지2</title>
  <link>https://shinjihan.github.io/studylog/rd/od_04.html</link>
  <description><![CDATA[ 




<p>01 VS코드 실행 관리자 권한으로 실행하기.</p>
<p>1 . uv 설치 pip install uv</p>
<p>2 . Python 3.12로 가상 환경 생성 uv venv -p 3.12 fastapi-env</p>
<p>3 . 프로제트 클론하기 djailab/backend를 클론 후 파일 생성 및 폴더에 저장.</p>
<p>git clone https://github.com/djailab/backend.git</p>
<p>4 . 프로젝트 설정 동기화 uv sync</p>
<p>5 . 파일 실행 명령어 uv run hello.py</p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_04.html</guid>
  <pubDate>Sun, 23 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 일지</title>
  <link>https://shinjihan.github.io/studylog/rd/od_03.html</link>
  <description><![CDATA[ 




<p>01 제목1 [ID 사용하기]</p>
<p>1 . 제목2 본문1</p>
<p>본문2</p>
<p>Sign In</p>
<p>Sign in to AILab ID Authenticate yourself with your passkey to access the admin panel. Authenticate</p>
<p>sso.llms.kr</p>
<p>키 값.</p>
<p>비밀번호 입력.</p>
<p>Sign in to Services</p>
<p>Sign in to Services Do you want to sign in to Services with your AILab ID account? Cancel Sign in</p>
<p>sso.llms.kr</p>
<p>재희 작품</p>
<p>깃허브 주소 보내면 이메일로 옴</p>
<p><a href="https://github.com/djailab">djailab</a></p>



 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_03.html</guid>
  <pubDate>Wed, 19 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>FastAPI</title>
  <link>https://shinjihan.github.io/studylog/rd/od_02.html</link>
  <description><![CDATA[ 




<p>CHAPTER 3에 대해 다루고자 한다.</p>
<p>01 소개 https://fastapi.tiangolo.com/#requirements</p>
<p>02 FastAPI 애플리케이션</p>
<p>3 - 1 . hello 파일 생성하기 from fastapi import FastAPI #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI() <span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(): return “Hello? World?”</p>
<p>3 - 2 . cmd 실행 uvicorn hello:app –reload</p>
<p>3 - 3 . 파일에 추가 코드 if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 4 . 검색창 입력 http://localhost:8000/hi</p>
<p>3 - 5 . Requests로 /hi 테스트 import requests r = requests.get(“http://localhost:8000/hi”) r.json()</p>
<p>3 - 6 . Requests와 거의 동일한 HTTPX로 /hi 테스트 # pip install httpx import httpx r = httpx.get(“http://localhost:8000/hi”) r.json()</p>
<p>HTTPie 설치가 안되어 있을 경우 pip install httpie # 설치 명령어 where http # 설치된 경로 출력 명령어</p>
<p>3 - 7 . HTTPie로 /hi 테스트 httpie localhost:8000/hi</p>
<p>3 - 8 . HTTPie로 /hi 를 테스트해 응답 본문만 출력 http -b localhost:8000/hi</p>
<p>3 - 9 . HTTPie로 /hi를 테스트하고 모든 정보 출력 http -v localhost:8000/hi</p>
<p>03 HTTP 요청</p>
<p>3 - 11 . 인사말 경로 변환 from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi/{who}”) def greet(who): return f”Hello? {who}”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 12 . 브라우저에서 hi/Mom 테스트 http://localhost:8000/hi/Mom</p>
<p>3 - 13 . HTTPie로 hi/Mom 테스트 http localhost:8000/hi/Mom</p>
<p>3 - 14 . Requests로 /hi/Mom 테스트 import requests r = requests.get(“http://localhost:8000/hi/Mom”) r.json()</p>
<p>3 - 15 . 인사말 쿼리 매개변수 변환 from fastapi import FastAPI #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(who): return f”Hello? {who}”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 16 . 브라우저에서 테스트 http://localhost:8000/hi?who=Mom</p>
<p>3 - 17 . HTTPie 테스트 http -b localhost:8000/hi?who=Mom</p>
<p>3 - 18 . HTTPie 및 매개변수 사용 테스트 http -b localhost:8000/hi who==Mom</p>
<p>3 - 19 . Requests로 테스트 import requests r = requests.get(“http://localhost:8000/hi?who=Mom”) r.json()</p>
<p>3 - 20 . Requests 및 매개변수 테스트 import requests params = {“who”: “Mom”} r = requests.get(“http://localhost:8000/hi”, params=params) r.json()</p>
<p>3 - 21 . 인사말 본문 반환 from fastapi import FastAPI, Body #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(“/hi”) def greet(who : str = Body(embed=True)): return f”Hello? {who}?”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 22 . HTTPie로 테스트 http -v localhost:8000/hi who=Mom</p>
<p>3 - 23 . Requests로 테스트 import requests r = requests.post(“http://localhost:8000/hi”, json={“who”: “Mom”}) r.json()</p>
<p>3 - 24 . Requests로 테스트 from fastapi import FastAPI, Header #pip install fastapi uvicorn #pip show fastapi uvicorn</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/hi”) def greet(who : str = Header()): return f”Hello? {who}?”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 25 . Requests로 테스트 http -v localhost:8000/hi who:Mom</p>
<p>3 - 26 . 헤더 반환 from fastapi import FastAPI, Header</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/agent”) def get_agent(user_agent : str = Header()): return user_agent</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 27 . HTTPie로 User-Agent 헤더 테스트 http -v localhost:8000/agent</p>
<p>04 HTTP 요청</p>
<p>3 - 28 . HTTP 상태 코드 지정 from fastapi import FastAPI, Header</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/happy”) def happy(status_code=200): return “:)”</p>
<p>if <strong>name</strong> == “<strong>main</strong>”: import uvicorn uvicorn.run(“hello:app”, reload=True)</p>
<p>3 - 29 . HTTP 상태 코드 지정 http localhost:8000/happy</p>
<p>3 - 30 . HTTP 상태 코드 지정 from fastapi import FastAPI, Response</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(“/header/{name}/{value}”) def header(name: str, value: str, response: Response): response.headers[name] = value return “normal body”</p>
<p>3 - 31 . 응답 HTTP 헤더 테스트 http localhost:8000/header/marco/polo</p>
<p>파일 저장</p>
<p>위 코드를 test_json.py 파일로 저장한다.</p>
<p>3 - 32 . JSON 폭발 방지 # pip install pytest import datetime import pytest from fastapi.encoders import jsonable_encoder import json</p>
<p><span class="citation" data-cites="pytest.fixture">@pytest.fixture</span> def data(): return datetime.datetime.now()</p>
<p>def test_json_dump(data): with pytest.raises(TypeError): _ = json.dumps(data)</p>
<p>def test_encoder(data): out = jsonable_encoder(data) assert out json_out = json.dumps(out) assert json_out</p>
<p>pytest 실행 pytest test_json.py</p>
<p>3 - 33 . 모델 변형 from datetime import datetime from pydantic import BaseModel</p>
<section id="pydantic-모델-정의" class="level1">
<h1>Pydantic 모델 정의</h1>
<p>class TagIn(BaseModel): tag: str</p>
<p>class Tag(BaseModel): tag: str created: datetime secret: str</p>
<p>class TagOut(BaseModel): tag: str created: datetime</p>
</section>
<section id="입력-데이터-생성" class="level1">
<h1>입력 데이터 생성</h1>
<p>input_data = {“tag”: “fastapi”}</p>
</section>
<section id="tagin-모델-사용-데이터-검증" class="level1">
<h1>TagIn 모델 사용 (데이터 검증)</h1>
<p>tag_in = TagIn(**input_data) print(tag_in)</p>
</section>
<section id="tag-모델-사용" class="level1">
<h1>Tag 모델 사용</h1>
<p>tag_data = { “tag”: “fastapi”, “created”: datetime.now(), “secret”: “my_secret” } tag = Tag(**tag_data) print(tag)</p>
</section>
<section id="tagout-모델-사용-tag에서-특정-필드-제외" class="level1">
<h1>TagOut 모델 사용 (Tag에서 특정 필드 제외)</h1>
<p>tag_out = TagOut(**tag.dict()) # secret 필드는 자동으로 제외됨 print(tag_out)</p>
<p>pytest 실행 python tag.py</p>
<p>3 - 34 . 모델 변형 from datetime import datetime from model.tag import Tag</p>
<p>def create(tag: Tag) -&gt; Tag: “““태그를 생성한다.”“” return tag</p>
<p>def get(tag_str: str) -&gt; Tag: “““태그를 반환한다.”“” return Tag(tag=tag_str, created=datetime.utcnow(), secret=““)</p>
<p>3 - 35 . 모델 변형 from datetime import datetime from model.tag import TagIn, Tag, TagOut import service.tag as service from fastapi import FastAPI</p>
<p>app = FastAPI()</p>
<p><span class="citation" data-cites="app.post">@app.post</span>(‘/’) def create(tag_in: TagIn) -&gt; TagIn: tag: Tag = Tag(tag=tag_in.tag, created=datetime.utcnow(), secret=“shhhh”) service.create(tag) return tag_in</p>
<p><span class="citation" data-cites="app.get">@app.get</span>(‘/{tag_str}’, response_model=TagOut) def get_one(tag_str) -&gt; TagOut: tag: Tag = service.get(tag_str) return tag</p>
<p>3 - 36 . 실행 uvicorn web.tag:app</p>
<p>3 - 37 . Tag 가져오기 요청 http -b localhost:8000/GoodTag</p>
<p>04 자동 문서화</p>
<p>3 - 1 . 접속하기 http://localhost:8000/docs</p>
<p>3 - 2 . ㅇ</p>
<p>3 - 3 . ㅇ</p>
<p>3 - 4 . ㅇ</p>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_02.html</guid>
  <pubDate>Thu, 13 Feb 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Git 사용법</title>
  <link>https://shinjihan.github.io/studylog/rd/od_01.html</link>
  <description><![CDATA[ 




<p>VS코드로 Git 사용법에 대해 다루고자 한다.</p>
<section id="버전-관리-시스템" class="level1">
<h1>01 버전 관리 시스템</h1>
<p><code>VCS, Version Control System</code> 소프트웨어 개발 및 문서 작업에서 변경 사항을 기록, 추적, 관리, 수정, 복구할 수 있도록 돕는 도구.</p>
<ol type="1">
<li>로컬 버전 관리 시스템 <code>Local VCS</code> 파일 변경 이력을 로컬 컴퓨터에서만 관리하는 시스템을 의미. 대표적인 로컬 버전 관리 시스템은 RCS이며, 이는 파일의 변경 이력을 개별적으로 저장하는 방식이다.</li>
</ol>
<p><code>Revision Control System</code> 과거 macOS 및 UNIX 시스템에서 사용되었으나, 현재는 Git과 같은 분산 버전 관리 시스템(DVCS)의 등장으로 거의 사용되지 않는다.</p>
<ol start="2" type="1">
<li>중앙집중식 버전 관리 시스템 <code>CVCS, Centralized VCS</code> 여러 사용자가 협업할 수 있도록 설계된 중앙 서버 기반의 버전 관리 시스템.</li>
</ol>
<p>모든 변경 사항이 중앙 서버에 저장되며, 사용자는 중앙 서버에서 데이터를 가져와 수정한 후 다시 업로드하는 방식으로 동작한다.</p>
<p>대표적으로, SVN (Subversion), Perforce, CVS (Concurrent Versions System) 등이 있다.</p>
<p>CVCS의 단점 ① 모든 변경 이력이 중앙 서버에 저장되므로, 서버가 다운되거나 손상되면 데이터를 잃거나 작업이 불가능할 수 있다.</p>
<p>② 파일을 가져오거나 변경 사항을 기록하려면 항상 중앙 서버에 연결해야 한다. 네트워크 연결이 불안정하면 효율적으로 작업하기 어렵다.</p>
<p>3 . 분산 버전 관리 시스템 (DVCS, Distributed VCS)</p>
<p>각 개발자가 히스토리가 포함된 전체 저장소를 로컬에 복제하여 관리하는 방식.</p>
<p>Git, Mercurial이 대표적인 DVCS이다.</p>
<p>Git의 장점 ① 모든 변경 이력을 로컬 저장소(Local Repository)에 저장한다. 따라서 네트워크 연결 없이도 히스토리를 조회하고, 로컬에서 자유롭게 작업할 수 있다.</p>
<p>② 가벼운 브랜칭(branching) 기능을 제공하여, 여러 작업을 독립적으로 진행할 수 있다. 브랜치를 쉽게 병합(merging)할 수 있어, 팀 협업 시 코드 충돌을 최소화할 수 있다.</p>
<p>③ 모든 개발자의 로컬 저장소에 프로젝트의 전체 히스토리를 저장한다. 중앙 서버에 문제가 발생해도, 로컬 저장소를 활용하여 데이터를 복구할 수 있다.</p>
<p>이러한 장점 덕분에 Git은 현대적인 소프트웨어 개발에서 가장 널리 사용되는 버전 관리 시스템이 되었다.</p>
<p>02 Git 사용법</p>
<p>1 . Git 설치하기</p>
<p>Git - Downloads</p>
<p>Downloads macOS Windows Linux/Unix Older releases are available and the Git source repository is on GitHub. Latest source Release 2.48.1 Release Notes (2025-01-13) Download Source Code GUI Clients Git comes with built-in GUI tools (git-gui, gitk), but ther</p>
<p>git-scm.com</p>
<p>설치가 완료되었다.</p>
<p>Git Bash를 관리자 권한으로 실행하기.</p>
<p>다음과 같은 창이 나오는 것을 확인할 수 있다.</p>
<p>2 . VS Code 실행하기 Git 창을 닫고 VS Code를 실행하기.</p>
<p>VS Code가 설치되지 않았다면, 먼저 설치한 후 실행하세요.</p>
<p>Visual Studio Code - Code Editing. Redefined</p>
<p>Visual Studio Code redefines AI-powered coding with GitHub Copilot for building and debugging modern web and cloud applications. Visual Studio Code is free and available on your favorite platform - Linux, macOS, and Windows.</p>
<p>code.visualstudio.com</p>
<p>첫 화면.</p>
<p>새 파일 만들기.</p>
<p>Open Folder &gt; New &gt; Folder</p>
<p>파일명이 왼쪽 상단에 생성된 것을 확인할 수 있다. 이제 오른쪽 상단의 Toggle Panel을 클릭한다.</p>
<p>3 . 터미널 (Terminal) 터미널에 Git 저장소를 로컬로 복제(clone)하는 명령어 입력하기.</p>
</section>
<section id="기본구조-git-clone-복제할-원격-저장소의-url" class="level1">
<h1>기본구조: git clone + 복제할 원격 저장소의 URL</h1>
<p>예제: git clone https://github.com/onlybooks/python-algorithm-interview.git</p>
<p>해당 저장소의 모든 파일과 이력이 현재 작업 디렉토리로 다운로드된다.</p>
<p>즉, python-algorithm-interview 폴더가 생성되며, 해당 저장소의 내용을 그대로 가져오게 된다.</p>
<p>4 . GitHub 저장소 클론</p>
<p>Github 업로드를 허용한다.</p>
<p>원하는 계정을 선택한다.</p>
<p>계정이 없으면 새 계정을 생성한다.</p>
<p>열기 버튼 클릭.</p>
<p>Private는 본인만 접근할 수 있고, Public는 모든 사용자가 접근할 수 있다.</p>
<p>필요에 따라 적절한 옵션을 선택한다.</p>
<p>커밋 내역 확인하기.</p>
<p>README.md 파일 확인하기.</p>
<ol start="7" type="1">
<li>파일의 수정 과정을 알 수 있다.</li>
</ol>


</section>

 ]]></description>
  <category>code</category>
  <category>analysis</category>
  <guid>https://shinjihan.github.io/studylog/rd/od_01.html</guid>
  <pubDate>Wed, 05 Feb 2025 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
